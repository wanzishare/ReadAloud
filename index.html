<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
    <title>å¥å­æœ—è¯»å½•éŸ³ç³»ç»Ÿ</title>
    <div class="browser-notice" id="browserNotice" style="display: none;">
        <div class="notice-content">
            <span>âš ï¸ æ£€æµ‹åˆ°æ‚¨æ­£åœ¨ä½¿ç”¨Safariæµè§ˆå™¨ã€‚ä¸ºè·å¾—æœ€ä½³å½•éŸ³ä½“éªŒï¼Œå»ºè®®ï¼š</span>
            <ul>
                <li>ä½¿ç”¨Chromeæˆ–Edgeæµè§ˆå™¨</li>
                <li>ç¡®ä¿ç³»ç»Ÿå·²æ›´æ–°è‡³æœ€æ–°ç‰ˆæœ¬</li>
                <li>å…è®¸ç½‘ç«™è®¿é—®éº¦å…‹é£æƒé™</li>
            </ul>
            <button onclick="document.getElementById('browserNotice').style.display='none'">çŸ¥é“äº†</button>
        </div>
    </div>
    <style>
        /* åº†ç¥æ¶ˆæ¯æ ·å¼ */
        #celebrationMessage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }

        .celebration-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: pulse 2s infinite, bounceIn 1s ease;
            border: 3px solid gold;
        }

        .celebration-title {
            font-size: 3em;
            color: white;
            margin: 20px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            animation: glow 1.5s infinite alternate;
        }

        .celebration-subtitle {
            font-size: 1.5em;
            color: #FFD700;
            margin-bottom: 30px;
        }

        .stars {
            font-size: 2em;
            color: gold;
            animation: spin 3s linear infinite;
        }

        .celebration-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: left;
        }

        .celebration-info p {
            color: white;
            margin: 10px 0;
            font-size: 1.1em;
        }

        .btn-celebration-close {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #333;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-celebration-close:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px gold;
        }

        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes glow {
            from {
                text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }
            to {
                text-shadow: 0 0 20px rgba(255, 215, 0, 1),
                            0 0 30px rgba(255, 215, 0, 0.7),
                            0 0 40px rgba(255, 215, 0, 0.5);
            }
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0.3);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* çƒŸèŠ±ç²’å­æ ·å¼ */
        .firework-particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .celebration-content {
                padding: 20px;
                width: 95%;
            }
            
            .celebration-title {
                font-size: 2em;
            }
            
            .celebration-subtitle {
                font-size: 1.2em;
            }
            
            .stars {
                font-size: 1.5em;
            }
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        .browser-notice {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 10px 15px;
            z-index: 9999;
            max-width: 500px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .notice-content ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        /* å·¦ä¾§å¥å­åˆ—è¡¨ */
        .sentence-list {
            flex: 1;
            border-right: 1px solid #eaeaea;
            overflow-y: auto;
            max-height: 600px;
        }

        .sentence-list-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sentence-item {
            padding: 15px 20px;
            border-bottom: 1px solid #eaeaea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sentence-item:hover {
            background: #f8f9fa;
        }

        .sentence-item.active {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-left: 4px solid #667eea;
        }

        .sentence-text {
            font-size: 16px;
            color: #333;
            margin-bottom: 8px;
        }

        .sentence-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #666;
        }

        .status-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .status-recorded {
            background: #d4edda;
            color: #155724;
        }

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-uploaded {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* å³ä¾§å½•éŸ³åŒºåŸŸ */
        .recording-area {
            flex: 2;
            padding: 30px;
        }

        .current-sentence {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }

        .current-sentence .sentence-id {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .current-sentence-text {
            font-size: 20px;
            line-height: 1.6;
            color: #333;
        }

        /* å½•éŸ³æ§åˆ¶åŒº */
        .recording-controls {
            text-align: center;
            margin: 30px 0;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .btn-record {
            background: #dc3545;
            color: white;
        }

        .btn-record:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn-stop {
            background: #6c757d;
            color: white;
        }

        .btn-stop:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-upload {
            background: #28a745;
            color: white;
        }

        .btn-upload:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-play {
            background: #17a2b8;
            color: white;
        }

        .btn-play:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .timer {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .waveform {
            height: 100px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            position:relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: #667eea;
            border-radius: 3px 3px 0 0;
        }

        /* æ’­æ”¾æŒ‡ç¤ºå™¨ */
        .playback-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2196F3;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(33, 150, 243, 0.3);
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease;
            display: none;
        }

        .status-success {
            background: #4CAF50;
            color: white;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        .status-info {
            background: #2196F3;
            color: white;
        }

        /* è¿›åº¦æ¡ */
        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eaeaea;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* æ—¥æœŸé€‰æ‹©å™¨æ ·å¼ */
        .date-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 40px;
            padding: 15px 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .date-selector label {
            font-weight: bold;
            color: #333;
            font-size: 16px;
        }

        .date-selector input[type="date"] {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 6px;
            font-size: 14px;
            color: #333;
            background: white;
            cursor: pointer;
            flex: 1;
            max-width: 200px;
        }

        .date-quick-buttons {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .date-quick-buttons .btn {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
        }

        .date-quick-buttons .btn-today {
            background: #667eea;
            color: white;
        }

        .date-quick-buttons .btn-yesterday {
            background: #6c757d;
            color: white;
        }

        /* åŠ¨ç”» */
        @keyframes slideIn {
            from { top: -50px; opacity: 0; }
            to { top: 20px; opacity: 1; }
        }

        @keyframes slideOut {
            from { top: 20px; opacity: 1; }
            to { top: -50px; opacity: 0; }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
            100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
        }

        @keyframes recordingPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes waveform {
            0% { height: 20%; }
            50% { height: 100%; }
            100% { height: 20%; }
        }

        .playing .current-sentence {
            animation: pulse 1.5s infinite;
        }

        .btn-play.playing {
            background: #ff9800;
            animation: recordingPulse 1.5s infinite;
        }

        .upload-icon {
            margin-left: 5px;
        }

        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        .loading-indicator {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sentence-list {
                max-height: 300px;
            }
            
            .control-buttons {
                flex-wrap: wrap;
            }
            
            .date-selector {
                flex-direction: column;
                align-items: stretch;
                margin: 20px;
            }
            
            .date-selector input[type="date"] {
                max-width: none;
            }
            
            .date-quick-buttons {
                margin-left: 0;
                justify-content: center;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
    <div class="loading-indicator" id="loadingIndicator">
        <div class="loading-spinner"></div>
    </div>
    <div class="container">
        <!-- å¤´éƒ¨ -->
        <div class="header">
            <h1>ğŸ“ æœ—è¯»å½•éŸ³ç³»ç»Ÿ</h1>
        </div>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <!-- å·¦ä¾§å¥å­åˆ—è¡¨ -->
            <div class="sentence-list">
                <div class="sentence-list-header">
                    <h3>ğŸ“‹ å¥å­åˆ—è¡¨</h3>
                    <span id="progressText">0/0 å·²ä¸Šä¼ </span>
                </div>
                <div id="sentencesContainer">
                    <!-- å¥å­é¡¹å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- å³ä¾§å½•éŸ³åŒº -->
            <div class="recording-area">
                <!-- å½“å‰å¥å­å±•ç¤º -->                
                <div class="current-sentence">
                    <div class="sentence-id" id="currentSentenceId">æœªé€‰æ‹©</div>
                    <div class="current-sentence-text" id="currentSentenceText">
                        <span style="color: #666; font-style: italic;">
                            è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªå¥å­å¼€å§‹å½•éŸ³
                        </span>
                    </div>
                </div>

                <!-- å½•éŸ³æ§åˆ¶ -->
                <div class="recording-controls">
                    <div class="timer" id="timer">00:00</div>
                    <div class="waveform" id="waveform"></div>
                    
                    <div class="control-buttons">
                        <button class="btn btn-record" id="recordBtn">
                            <span>ğŸ¤ å¼€å§‹å½•éŸ³</span>
                        </button>
                        <button class="btn btn-stop" id="stopBtn" disabled>
                            <span>â¹ï¸ åœæ­¢å½•éŸ³</span>
                        </button>
                        <button class="btn btn-upload" id="uploadBtn" disabled>
                            <span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>
                        </button>
                        <button class="btn btn-play" id="playBtn" disabled>
                            <span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>
                        </button>
                    </div>

                    <!-- è¿›åº¦æ¡ -->
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-number" id="totalSentences">0</div>
                        <div class="stat-label">æ€»å¥å­æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="uploadedSentences">0</div>
                        <div class="stat-label">å·²ä¸Šä¼ </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="playback-indicator" id="playbackIndicator">ğŸ”Š æ­£åœ¨æ’­æ”¾...</div>
    <div class="status-message" id="statusMessage"></div>

    <script>
        const AUDIO_CONFIG = {
            // æ£€æµ‹æµè§ˆå™¨æ”¯æŒçš„æ ¼å¼
            getSupportedMimeType() {
                const types = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/mp4',
                    'audio/mp4;codecs=mp4a.40.2',
                    'audio/ogg;codecs=opus',
                    'audio/wav'
                ];
                
                for (let type of types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        console.log('æ”¯æŒæ ¼å¼:', type);
                        return type;
                    }
                }
                return 'audio/webm'; // é»˜è®¤å›é€€
            },
            
            // è·å–æ’­æ”¾å™¨æ”¯æŒçš„æ ¼å¼
            getPlayableFormat(blob) {
                const audio = new Audio();
                const formats = [
                    { type: 'audio/webm', test: 'audio/webm;codecs=opus' },
                    { type: 'audio/mp4', test: 'audio/mp4;codecs=mp4a.40.2' },
                    { type: 'audio/wav', test: 'audio/wav' },
                    { type: 'audio/ogg', test: 'audio/ogg;codecs=opus' }
                ];
                
                for (let format of formats) {
                    if (audio.canPlayType(format.test)) {
                        return format.type;
                    }
                }
                return 'audio/webm';
            }
        };


        // ä¸»è¦ä½¿ç”¨Giteeé…ç½®
        const GITEE_CONFIG = {
            // ä½ çš„Giteeä»“åº“ï¼Œæ ¼å¼ï¼šç”¨æˆ·å/ä»“åº“å
            REPOSITORY: 'bufan1990/read-aloud',
            // ä½ çš„Gitee Personal Access Tokenï¼ˆéœ€è¦repoæƒé™ï¼‰
            TOKEN: 'f62b136877bc9f4a2491f1ef30286857',
            // Gitee APIåŸºç¡€URL
            API_BASE: 'https://gitee.com/api/v5',
            // ä¸Šä¼ æ–‡ä»¶ç›®å½•
            RECORDINGS_DIR: 'recordings/2A',
            // xlsxç›®å½•æ–‡ä»¶
            XLSX_DIR: 'xlsx/read_aloud_2A.xlsx',
        };


        // åœ¨CSSæ ·å¼ä¸­æ·»åŠ é‡æ–°åŠ è½½æŒ‰é’®çš„æ ·å¼
        const additionalStyles = `
        .btn-reload {
            background: #17a2b8;
            color: white;
        }

        .btn-reload:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .loading-text {
            color: white;
            font-size: 18px;
            margin-top: 20px;
        }
        `;

        // å°†æ ·å¼æ·»åŠ åˆ°é¡µé¢
        const styleSheet = document.createElement('style');
        styleSheet.textContent = additionalStyles;
        document.head.appendChild(styleSheet);
        // ç¤ºä¾‹å¥å­æ•°æ®
        const SAMPLE_SENTENCES = [
            // { id: 'S001', text: 'ç”Ÿæ´»å°±åƒä¸€ç›’å·§å…‹åŠ›ï¼Œä½ æ°¸è¿œä¸çŸ¥é“ä¸‹ä¸€é¢—æ˜¯ä»€ä¹ˆå‘³é“ã€‚', recorded: false, hasUploaded: false },
            // { id: 'S002', text: 'æˆåŠŸä¸æ˜¯ç»ˆç‚¹ï¼Œå¤±è´¥ä¹Ÿå¹¶éæœ«æ—¥ï¼Œé‡è¦çš„æ˜¯ç»§ç»­å‰è¿›çš„å‹‡æ°”ã€‚', recorded: false, hasUploaded: false },
            // { id: 'S003', text: 'å­¦ä¹ å¦‚é€†æ°´è¡ŒèˆŸï¼Œä¸è¿›åˆ™é€€ã€‚', recorded: false, hasUploaded: false },
            // { id: 'S004', text: 'æ—¶é—´æ˜¯æœ€å¥½çš„è€å¸ˆï¼Œä½†é—æ†¾çš„æ˜¯ï¼Œå®ƒä¼šæ€æ­»æ‰€æœ‰å­¦ç”Ÿã€‚', recorded: false, hasUploaded: false },
            // { id: 'S005', text: 'æ¢¦æƒ³ä¸ä¼šé€ƒè·‘ï¼Œé€ƒè·‘çš„æ°¸è¿œæ˜¯è‡ªå·±ã€‚', recorded: false, hasUploaded: false },
            // { id: 'S006', text: 'çœŸæ­£çš„å‘ç°ä¹‹æ—…ä¸åœ¨äºå¯»æ‰¾æ–°é£æ™¯ï¼Œè€Œåœ¨äºæ‹¥æœ‰æ–°çœ¼å…‰ã€‚', recorded: false, hasUploaded: false },
            // { id: 'S007', text: 'å¿è€ä¹‹æ ‘ç»“å‡ºé»„é‡‘ä¹‹æœã€‚', recorded: false, hasUploaded: false },
            // { id: 'S008', text: 'äººç”Ÿæ²¡æœ‰å½©æ’ï¼Œæ¯ä¸€å¤©éƒ½æ˜¯ç°åœºç›´æ’­ã€‚', recorded: false, hasUploaded: false },
            // { id: 'S009', text: 'æœºä¼šæ€»æ˜¯ç•™ç»™æœ‰å‡†å¤‡çš„äººã€‚', recorded: false, hasUploaded: false },
            // { id: 'S010', text: 'åƒé‡Œä¹‹è¡Œï¼Œå§‹äºè¶³ä¸‹ã€‚', recorded: false, hasUploaded: false }
        ];

        // ==================== åº”ç”¨çŠ¶æ€ ====================
        const AppState = {
            sentences: [],
            currentSentence: null,
            audioBlob: null,
            audioChunks: [],
            isRecording: false,
            recorder: null,
            timerInterval: null,
            recordingTime: 0,
            selectedDate: (() => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            todayDate: (() => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            isLoadingExcel: false,
            config: GITEE_CONFIG, // ä½¿ç”¨Giteeé…ç½®
            isPlaying: false,
            currentAudio: null,            
            playbackTimerInterval: null,
            playbackTime: 0,
            audioCurrentTime: 0,
            audioDuration: 0,
            isDownloading: false,
            lastDownloadTime: null,
            sentences: [], // åˆå§‹ä¸ºç©ºï¼Œä»ExcelåŠ è½½
            excelData: null, // å­˜å‚¨Excelæ•°æ®
            excelUrl: `${GITEE_CONFIG.XLSX_DIR}`, // Excelæ–‡ä»¶è·¯å¾„
            audioConfig: {
                recordingMimeType: AUDIO_CONFIG.getSupportedMimeType(),
                playableFormat: 'audio/webm'
            }
        };

        // ==================== DOMå…ƒç´  ====================
        const elements = {
            sentencesContainer: document.getElementById('sentencesContainer'),
            currentSentenceId: document.getElementById('currentSentenceId'),
            currentSentenceText: document.getElementById('currentSentenceText'),
            recordBtn: document.getElementById('recordBtn'),
            stopBtn: document.getElementById('stopBtn'),
            uploadBtn: document.getElementById('uploadBtn'),
            playBtn: document.getElementById('playBtn'),
            timer: document.getElementById('timer'),
            waveform: document.getElementById('waveform'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            totalSentences: document.getElementById('totalSentences'),
            uploadedSentences: document.getElementById('uploadedSentences'),
            playbackIndicator: document.getElementById('playbackIndicator'),
            statusMessage: document.getElementById('statusMessage'),
            loadingIndicator: document.getElementById('loadingIndicator')
        };

        // ==================== çŠ¶æ€ç¼“å­˜ç®¡ç† ====================
        const StateCache = {
            // ç¼“å­˜å·²ä¸Šä¼ çŠ¶æ€
            CACHE_PREFIX: 'upload_status_',
            CACHE_TTL: 24 * 60 * 60 * 1000, // 24å°æ—¶
            
            // è·å–ç¼“å­˜çš„ä¸Šä¼ çŠ¶æ€
            getUploadStatus(date, sentenceId) {
                try {
                    const cacheKey = `${this.CACHE_PREFIX}${date}_${sentenceId}`;
                    const cached = localStorage.getItem(cacheKey);
                    
                    if (cached) {
                        const data = JSON.parse(cached);
                        const now = Date.now();
                        
                        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
                        if (now - data.timestamp < this.CACHE_TTL) {
                            console.log(`ä»ç¼“å­˜è·å–ä¸Šä¼ çŠ¶æ€: ${date}_${sentenceId} = ${data.hasUploaded}`);
                            return data.hasUploaded;
                        } else {
                            // ç¼“å­˜è¿‡æœŸï¼Œæ¸…ç†
                            localStorage.removeItem(cacheKey);
                        }
                    }
                } catch (error) {
                    console.warn('è¯»å–ä¸Šä¼ çŠ¶æ€ç¼“å­˜å¤±è´¥:', error);
                }
                return null; // æ²¡æœ‰ç¼“å­˜
            },
            
            // ä¿å­˜ä¸Šä¼ çŠ¶æ€åˆ°ç¼“å­˜
            setUploadStatus(date, sentenceId, hasUploaded) {
                try {
                    const cacheKey = `${this.CACHE_PREFIX}${date}_${sentenceId}`;
                    const cacheData = {
                        hasUploaded: hasUploaded,
                        timestamp: Date.now(),
                        date: date,
                        sentenceId: sentenceId
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                    console.log(`ç¼“å­˜ä¸Šä¼ çŠ¶æ€: ${date}_${sentenceId} = ${hasUploaded}`);
                } catch (error) {
                    console.warn('ä¿å­˜ä¸Šä¼ çŠ¶æ€ç¼“å­˜å¤±è´¥:', error);
                }
            },
            
            // æ‰¹é‡ä¿å­˜ä¸Šä¼ çŠ¶æ€
            batchSetUploadStatus(date, statusMap) {
                console.log(`æ‰¹é‡ç¼“å­˜ ${date} çš„ä¸Šä¼ çŠ¶æ€:`, statusMap);
                Object.keys(statusMap).forEach(sentenceId => {
                    this.setUploadStatus(date, sentenceId, statusMap[sentenceId]);
                });
            },
            
            // æ¸…ç†è¿‡æœŸç¼“å­˜
            cleanupExpiredCache() {
                const now = Date.now();
                const prefix = this.CACHE_PREFIX;
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(prefix)) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (now - data.timestamp > this.CACHE_TTL) {
                                localStorage.removeItem(key);
                            }
                        } catch {
                            localStorage.removeItem(key);
                        }
                    }
                }
            }
        };

        function resetToNoSelectionState() {
            console.log('é‡ç½®åˆ°æ— é€‰æ‹©çŠ¶æ€');
            
            // åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„æ“ä½œ
            if (AppState.isPlaying) stopPlayback();
            if (AppState.isRecording) stopRecording();
            if (AppState.timerInterval) clearInterval(AppState.timerInterval);
            if (AppState.playbackTimerInterval) clearInterval(AppState.playbackTimerInterval);
            
            // é‡ç½®åº”ç”¨çŠ¶æ€
            AppState.currentSentence = null;
            AppState.audioBlob = null;
            AppState.recordingTime = 0;
            AppState.playbackTime = 0;
            
            // é‡ç½®UIæ˜¾ç¤º
            elements.currentSentenceId.textContent = 'æœªé€‰æ‹©';
            elements.currentSentenceText.innerHTML = '<span style="color: #666; font-style: italic;">è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªå¥å­å¼€å§‹å½•éŸ³</span>';
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
            
            // é‡ç½®æŒ‰é’®çŠ¶æ€
            elements.recordBtn.disabled = false;
            elements.recordBtn.innerHTML = '<span>ğŸ¤ å¼€å§‹å½•éŸ³</span>';
            elements.stopBtn.disabled = true;
            elements.playBtn.disabled = true;
            elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
            elements.playBtn.classList.remove('playing');
            elements.uploadBtn.disabled = true;
            elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>';
            
            // ç§»é™¤åˆ—è¡¨æ¿€æ´»çŠ¶æ€
            const items = document.querySelectorAll('.sentence-item');
            items.forEach(item => item.classList.remove('active'));
        }

        // æ™ºèƒ½åŠ è½½å¥å­æ•°æ® - ä¼˜å…ˆåŠ è½½ä»Šå¤©ï¼Œå…¶ä»–å¼‚æ­¥
        async function smartLoadSentences() {
            console.log('æ™ºèƒ½åŠ è½½å¥å­æ•°æ®...');
            
            AppState.isLoadingExcel = true;
            
            try {
                // è·å–å½“å‰æ—¥æœŸçš„å¥å­
                const sentences = getSentencesByDate(AppState.selectedDate);
                
                if (sentences && sentences.length > 0) {
                    AppState.sentences = sentences;
                    console.log('å½“å‰æ—¥æœŸå¥å­åŠ è½½æˆåŠŸ:', sentences.length);
                    
                    // æ£€æŸ¥æœ¬åœ°å½•éŸ³çŠ¶æ€
                    await checkDateRecordings();
                    
                    renderSentenceList();
                    updateStats();
                    // showStatus(`å·²åŠ è½½ ${sentences.length} ä¸ªå¥å­`, 'success');
                    
                    // å¼‚æ­¥é¢„åŠ è½½å…¶ä»–æ—¥æœŸçš„æ•°æ®
                    setTimeout(() => {
                        preloadOtherDates();
                    }, 100);
                    
                } else {
                    console.log('å½“å‰æ—¥æœŸæ²¡æœ‰å¥å­æ•°æ®ï¼Œä½¿ç”¨ç¤ºä¾‹å¥å­');
                    useFallbackSentences();
                    renderSentenceList();
                    updateStats();
                    showStatus('å½“å‰æ—¥æœŸè¿˜æœªå¸ƒç½®ä½œä¸š', 'info');
                }
                
            } catch (error) {
                console.error('æ™ºèƒ½åŠ è½½å¤±è´¥:', error);
                useFallbackSentences();
                renderSentenceList();
                updateStats();
                showStatus('æ•°æ®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç¤ºä¾‹å¥å­', 'error');
            } finally {
                AppState.isLoadingExcel = false;
            }
        }

        // ä¸ºæŒ‡å®šæ—¥æœŸåŠ è½½å¥å­æ•°æ®
        async function loadSentencesForDate(date, isPriority = false) {
            console.log(`${isPriority ? 'ä¼˜å…ˆ' : 'å¼‚æ­¥'}åŠ è½½ ${date} çš„å¥å­æ•°æ®`);
            
            try {
                // æ£€æŸ¥æœ¬åœ°ç¼“å­˜
                const cacheKey = `excel_cache_${date}`;
                const cached = localStorage.getItem(cacheKey);
                
                if (cached && isPriority) {
                    console.log(`ä»ç¼“å­˜åŠ è½½ ${date} çš„æ•°æ®`);
                    const parsed = JSON.parse(cached);
                    if (parsed && parsed.sentences && parsed.timestamp) {
                        const cacheAge = Date.now() - parsed.timestamp;
                        if (cacheAge < 3600000) {
                            return parsed.sentences;
                        }
                    }
                }
                
                // ç¡®ä¿Excelæ•°æ®å·²åŠ è½½
                if (!AppState.excelData) {
                    // ç›´æ¥ä»GiteeåŠ è½½
                    const arrayBuffer = await fetchExcelFromGitee();
                    if (arrayBuffer) {
                        AppState.excelData = parseExcelData(arrayBuffer);
                    }
                }
                
                if (!AppState.excelData) {
                    throw new Error('Excelæ•°æ®åŠ è½½å¤±è´¥');
                }
                
                // è·å–æŒ‡å®šæ—¥æœŸçš„å¥å­
                const sentences = getSentencesByDate(date);
                
                if (sentences && sentences.length > 0) {
                    // ç¼“å­˜æ•°æ®
                    const cacheData = {
                        sentences: sentences,
                        timestamp: Date.now(),
                        date: date
                    };
                    localStorage.setItem(cacheKey, JSON.stringify(cacheData));
                    
                    console.log(`${date} åŠ è½½å®Œæˆ:`, sentences.length, 'ä¸ªå¥å­');
                    return sentences;
                }
                
                return null;
                
            } catch (error) {
                console.error(`åŠ è½½ ${date} æ•°æ®å¤±è´¥:`, error);
                return null;
            }
        }
        // åœ¨åŠ è½½æ—¶æ˜¾ç¤ºè¿›åº¦
        function showProgress(message, progress = 0) {
            const progressElement = document.getElementById('loadingProgress') || createProgressElement();
            
            if (progressElement) {
                progressElement.innerHTML = `
                    <div class="loading-spinner"></div>
                    <div class="loading-text">${message}</div>
                    ${progress > 0 ? `<div class="progress-bar"><div class="progress-fill" style="width: ${progress}%"></div></div>` : ''}
                `;
            }
        }

        function createProgressElement() {
            const existing = document.getElementById('loadingIndicator');
            if (existing) {
                const progressDiv = document.createElement('div');
                progressDiv.id = 'loadingProgress';
                progressDiv.style.cssText = 'text-align: center; margin-top: 20px;';
                existing.appendChild(progressDiv);
                return progressDiv;
            }
            return null;
        }

        // æ¸…ç†è¿‡æœŸç¼“å­˜
        function cleanupExpiredCache() {
            console.log('æ¸…ç†è¿‡æœŸç¼“å­˜...');
            const now = Date.now();
            const datePattern = /^excel_cache_\d{4}-\d{2}-\d{2}$/;
            let cleanedCount = 0;
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (datePattern.test(key)) {
                    try {
                        const cached = localStorage.getItem(key);
                        const parsed = JSON.parse(cached);
                        
                        if (parsed && parsed.timestamp && (now - parsed.timestamp) > 86400000) {
                            localStorage.removeItem(key);
                            cleanedCount++;
                        }
                    } catch (e) {
                        localStorage.removeItem(key);
                        cleanedCount++;
                    }
                }
            }
            
            console.log(`æ¸…ç†äº† ${cleanedCount} ä¸ªè¿‡æœŸç¼“å­˜`);
        }

        // é¢„åŠ è½½å…¶ä»–æ—¥æœŸæ•°æ®
        async function preloadOtherDates() {
            if (!AppState.excelData) return;
            
            console.log('å¼€å§‹é¢„åŠ è½½å…¶ä»–æ—¥æœŸæ•°æ®...');
            
            // è·å–Excelä¸­çš„æ‰€æœ‰å·¥ä½œè¡¨ï¼ˆæ—¥æœŸï¼‰
            const sheetNames = Object.keys(AppState.excelData);
            const datesToPreload = sheetNames.filter(name => 
                name !== AppState.todayDate && // æ’é™¤ä»Šå¤©
                isValidDateString(name) // åªå¤„ç†æœ‰æ•ˆæ—¥æœŸ
            );
            
            console.log('éœ€è¦é¢„åŠ è½½çš„æ—¥æœŸ:', datesToPreload);
            
            // é™åˆ¶åŒæ—¶é¢„åŠ è½½çš„æ•°é‡
            const maxConcurrent = 3;
            for (let i = 0; i < datesToPreload.length; i += maxConcurrent) {
                const batch = datesToPreload.slice(i, i + maxConcurrent);
                
                const promises = batch.map(async (date) => {
                    try {
                        await loadSentencesForDate(date, false);
                        console.log(`é¢„åŠ è½½å®Œæˆ: ${date}`);
                    } catch (error) {
                        console.warn(`é¢„åŠ è½½ ${date} å¤±è´¥:`, error);
                    }
                });
                
                await Promise.allSettled(promises);
            }
            
            console.log('å…¶ä»–æ—¥æœŸæ•°æ®é¢„åŠ è½½å®Œæˆ');
        }

        // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºæœ‰æ•ˆæ—¥æœŸ
        function isValidDateString(dateStr) {
            const regex = /^\d{4}-\d{2}-\d{2}$/;
            if (!regex.test(dateStr)) return false;
            
            const date = new Date(dateStr);
            return date instanceof Date && !isNaN(date);
        }

        // ä½¿ç”¨åå¤‡å¥å­
        function useFallbackSentences() {
            AppState.sentences = SAMPLE_SENTENCES.map(s => ({
                ...s,
                recorded: false,
                hasUploaded: false
            }));
            
            console.log('ä½¿ç”¨åå¤‡å¥å­:', AppState.sentences.length);
            showStatus('ä½¿ç”¨ç¤ºä¾‹å¥å­', 'info');
        }

        // ä»Giteeè·å–Excelæ–‡ä»¶
        async function fetchExcelFromGitee() {
            try {
                console.log('å¼€å§‹ä»Giteeè·å–Excelæ–‡ä»¶...');
                
                // æ–¹æ³•1: ä½¿ç”¨Gitee APIè·å–æ–‡ä»¶å†…å®¹ï¼ˆæœ€å¯é çš„æ–¹å¼ï¼‰
                const apiUrl = `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${AppState.excelUrl}?access_token=${GITEE_CONFIG.TOKEN}`;
                
                console.log('APIè¯·æ±‚URL:', apiUrl);
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    }
                });
                
                console.log('APIå“åº”çŠ¶æ€:', response.status);
                
                if (!response.ok) {
                    throw new Error(`Gitee APIè¿”å›é”™è¯¯: ${response.status} ${response.statusText}`);
                }
                
                const fileData = await response.json();
                console.log('Gitee APIå“åº”:', fileData);
                
                if (!fileData.content) {
                    throw new Error('Giteeè¿”å›çš„æ–‡ä»¶æ•°æ®ä¸­æ²¡æœ‰contentå­—æ®µ');
                }
                
                if (fileData.encoding !== 'base64') {
                    throw new Error(`ä¸æ”¯æŒçš„ç¼–ç æ ¼å¼: ${fileData.encoding}`);
                }
                
                // è§£ç base64å†…å®¹
                console.log('å¼€å§‹è§£ç base64æ•°æ®...');
                const binaryString = atob(fileData.content);
                const bytes = new Uint8Array(binaryString.length);
                
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                const arrayBuffer = bytes.buffer;
                console.log('Excelæ–‡ä»¶ä¸‹è½½æˆåŠŸï¼Œå¤§å°:', arrayBuffer.byteLength, 'bytes');
                
                // éªŒè¯æ–‡ä»¶å¤§å°
                if (arrayBuffer.byteLength < 100) {
                    console.warn('æ–‡ä»¶å¤§å°å¼‚å¸¸ï¼Œå¯èƒ½ä¸‹è½½å¤±è´¥:', arrayBuffer.byteLength, 'bytes');
                }
                
                return arrayBuffer;
                
            } catch (error) {
                console.error('ä»Giteeè·å–Excelå¤±è´¥:', error);
                
                // å°è¯•å¤‡ç”¨æ–¹æ³•ï¼šä½¿ç”¨ç›´æ¥é“¾æ¥ï¼ˆä¸ä½¿ç”¨ä»£ç†ï¼‰
                console.log('å°è¯•å¤‡ç”¨æ–¹æ³•è·å–æ–‡ä»¶...');
                try {
                    const directUrl = `https://gitee.com/${GITEE_CONFIG.REPOSITORY}/raw/master/${AppState.excelUrl}`;
                    console.log('å¤‡ç”¨æ–¹æ³•URL:', directUrl);
                    
                    const response = await fetch(directUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/octet-stream'
                        }
                    });
                    
                    if (response.ok) {
                        const arrayBuffer = await response.arrayBuffer();
                        console.log('å¤‡ç”¨æ–¹æ³•æˆåŠŸï¼Œæ–‡ä»¶å¤§å°:', arrayBuffer.byteLength, 'bytes');
                        return arrayBuffer;
                    }
                } catch (directError) {
                    console.error('å¤‡ç”¨æ–¹æ³•ä¹Ÿå¤±è´¥:', directError);
                }
                
                throw new Error(`æ— æ³•ä»Giteeè·å–Excelæ–‡ä»¶: ${error.message}`);
            }
        }


        // è§£æExcelæ•°æ®
        function parseExcelData(arrayBuffer) {
            try {
                console.log('å¼€å§‹è§£æExcelæ•°æ®...');
                
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                
                console.log('Excelæ–‡ä»¶ä¿¡æ¯:');
                console.log('å·¥ä½œè¡¨æ•°é‡:', workbook.SheetNames.length);
                console.log('å·¥ä½œè¡¨åç§°:', workbook.SheetNames);
                
                const excelData = {};
                
                workbook.SheetNames.forEach(sheetName => {
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                        header: 1,
                        defval: ''
                    });
                    
                    excelData[sheetName] = jsonData;
                    console.log(`å·¥ä½œè¡¨ "${sheetName}" æ•°æ®è¡Œæ•°:`, jsonData.length);
                });
                
                console.log('Excelæ•°æ®è§£æå®Œæˆ');
                return excelData;
                
            } catch (error) {
                console.error('è§£æExcelæ•°æ®å¤±è´¥:', error);
                throw error;
            }
        }

        // æ ¹æ®æ—¥æœŸè·å–å¥å­
        function getSentencesByDate(date) {
            if (!AppState.excelData) {
                console.error('Excelæ•°æ®æœªåŠ è½½');
                return null;
            }
            
            console.log('æ ¹æ®æ—¥æœŸè·å–å¥å­ï¼Œæ—¥æœŸ:', date);
            
            let sheetData = AppState.excelData[date];
            
            if (!sheetData) {
                console.log('æœªæ‰¾åˆ°å¯¹åº”å·¥ä½œè¡¨ï¼Œå°è¯•å…¶ä»–æ ¼å¼...');
                return null;
            }
            
            console.log(`æ‰¾åˆ°å·¥ä½œè¡¨ï¼Œè¡Œæ•°:`, sheetData.length);
            
            const sentences = [];
            
            for (let i = 1; i < sheetData.length; i++) {
                const row = sheetData[i];
                
                if (row && row.length >= 2) {
                    const id = row[0] || `S${i.toString().padStart(3, '0')}`;
                    const text = row[1] || '';
                    
                    if (text.trim()) {
                        sentences.push({
                            id: id.toString(),
                            text: text.trim(),
                            recorded: false,
                            hasUploaded: false
                        });
                    }
                }
            }
            
            console.log('ä»Excelè§£æå‡ºçš„å¥å­æ•°é‡:', sentences.length);
            
            if (sentences.length === 0) {
                return parseAlternativeExcelFormat(sheetData, date);
            }
            
            return sentences;
        }

        // å¤‡ç”¨è§£ææ ¼å¼
        function parseAlternativeExcelFormat(sheetData, date) {
            console.log('å°è¯•å¤‡ç”¨æ ¼å¼è§£æ...');
            
            const sentences = [];
            let sentenceCount = 0;
            
            for (let i = 0; i < sheetData.length; i++) {
                const row = sheetData[i];
                
                if (row && Array.isArray(row)) {
                    for (let j = 0; j < row.length; j++) {
                        const cell = row[j];
                        
                        if (typeof cell === 'string' && 
                            cell.trim().length > 10 &&
                            !cell.includes('æ—¥æœŸ') && 
                            !cell.includes('æ—¶é—´') &&
                            !cell.includes('ID')) {
                            
                            sentenceCount++;
                            sentences.push({
                                id: `S${sentenceCount.toString().padStart(3, '0')}`,
                                text: cell.trim(),
                                recorded: false,
                                hasUploaded: false
                            });
                        }
                    }
                }
            }
            
            console.log('å¤‡ç”¨æ ¼å¼è§£æç»“æœ:', sentences.length, 'ä¸ªå¥å­');
            return sentences.length > 0 ? sentences : null;
        }

        // æ£€æµ‹è‹¹æœè®¾å¤‡å¹¶è°ƒæ•´é…ç½®
        function detectAppleDeviceAndAdjust() {
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isMac = /Macintosh|MacIntel|MacPPC|Mac68K/.test(navigator.userAgent) && !window.MSStream;
            
            console.log('è®¾å¤‡æ£€æµ‹:', { isSafari, isIOS, isMac });
            
            if (isIOS || isSafari) {
                console.log('è‹¹æœ/Safariè®¾å¤‡æ£€æµ‹åˆ°ï¼Œå¯ç”¨å…¼å®¹æ¨¡å¼');
                
                const audio = new Audio();
                if (audio.canPlayType('audio/mp4;codecs=mp4a.40.2')) {
                    AppState.audioConfig.recordingMimeType = 'audio/mp4';
                    AppState.audioConfig.playableFormat = 'audio/mp4';
                } else if (audio.canPlayType('audio/wav')) {
                    AppState.audioConfig.recordingMimeType = 'audio/wav';
                    AppState.audioConfig.playableFormat = 'audio/wav';
                }
                
                // showStatus('æ£€æµ‹åˆ°è‹¹æœè®¾å¤‡ï¼Œå·²å¯ç”¨å…¼å®¹æ¨¡å¼', 'info');
                return true;
            }
            return false;
        }

        // æ·»åŠ ç¼ºå¤±çš„è¾…åŠ©å‡½æ•°
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // ç¦ç”¨æ‰€æœ‰åŠŸèƒ½æŒ‰é’®
        function disableAllFeatureButtons() {
            console.log('ç¦ç”¨æ‰€æœ‰åŠŸèƒ½æŒ‰é’®');
            
            elements.recordBtn.disabled = true;
            elements.stopBtn.disabled = true;
            elements.uploadBtn.disabled = true;
            elements.playBtn.disabled = true;
            
            elements.recordBtn.innerHTML = '<span>ğŸ¤ å¼€å§‹å½•éŸ³</span>';
            elements.stopBtn.innerHTML = '<span>â¹ï¸ åœæ­¢å½•éŸ³</span>';
            elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>';
            elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
        }

        // å¯ç”¨å½•éŸ³æŒ‰é’®ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
        function enableBasicButtons() {
            console.log('å¯ç”¨åŸºç¡€åŠŸèƒ½æŒ‰é’®');
            
            // å½•éŸ³æŒ‰é’®å§‹ç»ˆå¯ç”¨ï¼ˆå‰ææ˜¯æœ‰é€‰ä¸­å¥å­ï¼‰
            elements.recordBtn.disabled = false;
        }

        // ==================== åˆå§‹åŒ–åº”ç”¨ ====================
        async function initApp() {
            console.log('åˆå§‹åŒ–åº”ç”¨...');
            
            // 1. æ¸…ç†ç‰¹å®šç¼“å­˜ï¼ˆæ¯æ¬¡æ‰“å¼€éƒ½æ¸…ç†ï¼‰
            clearTempCacheOnStartup();
            
            // 2. æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆ24å°æ—¶ä»¥ä¸Šï¼‰
            cleanupExpiredCache();
            StateCache.cleanupExpiredCache();
            
            // 3. ç»§ç»­åŸæœ‰çš„åˆå§‹åŒ–é€»è¾‘...
            // æ£€æµ‹è‹¹æœè®¾å¤‡å¹¶è°ƒæ•´é…ç½®
            detectAppleDeviceAndAdjust();
            
            // æ£€æŸ¥éŸ³é¢‘å…¼å®¹æ€§
            checkAudioCompatibility();
            
            // æ£€æŸ¥Giteeé…ç½®
            if (!AppState.config.REPOSITORY || !AppState.config.TOKEN) {
                showStatus('è¯·å…ˆé…ç½®Giteeä¿¡æ¯ï¼', 'error');
                return;
            }
            
            // 4. åˆå§‹åŒ–æ—¥æœŸ
            const now = new Date();
            AppState.todayDate = getLocalDateString(now);
            AppState.selectedDate = AppState.todayDate;
            
            // 5. éªŒè¯å’Œä¿®å¤æ—¥æœŸ
            validateAndFixDates();
            
            // 6. ä»GiteeåŠ è½½Excelæ•°æ®
            try {
                const excelData = await loadExcelData();
                if (excelData) {
                    AppState.excelData = excelData;
                    
                    // 7. è·å–æ‰€æœ‰å¯ç”¨çš„æ—¥æœŸ
                    const availableDates = getAllAvailableDates();
                    console.log('å¯ç”¨çš„æ—¥æœŸ:', availableDates);
                    
                    // 8. æ·»åŠ æ—¥æœŸé€‰æ‹©å™¨
                    createDateSelector(availableDates);
                    
                    // 9. åŠ è½½å½“å‰æ—¥æœŸçš„å¥å­æ•°æ®
                    await smartLoadSentences();
                    
                    // 10. è®¾ç½®äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¿…é¡»åœ¨æ•°æ®åŠ è½½åï¼‰
                    setupEventListeners();
                    
                    // 11. å¦‚æœæœ‰å¥å­ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ª
                    if (AppState.sentences.length > 0) {
                        console.log('åˆå§‹åŒ–å®Œæˆï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªå¥å­');
                        // å»¶è¿Ÿé€‰æ‹©ï¼Œç¡®ä¿UIå®Œå…¨æ¸²æŸ“
                        setTimeout(() => {
                            selectSentence(AppState.sentences[0]);
                        }, 300);
                    } else {
                        console.log('åˆå§‹åŒ–å®Œæˆï¼Œæ²¡æœ‰å¥å­æ•°æ®');
                        // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                        elements.currentSentenceText.innerHTML = `
                            <div style="text-align: center; color: #666;">
                                <p>ğŸ“ å½“å‰æ—¥æœŸæ²¡æœ‰å¥å­æ•°æ®</p>
                                <p style="font-size: 14px; margin-top: 10px;">
                                    è¯·é€‰æ‹©å…¶ä»–æ—¥æœŸæˆ–æ£€æŸ¥Excelæ–‡ä»¶
                                </p>
                            </div>
                        `;
                    }
                    
                    console.log('åº”ç”¨åˆå§‹åŒ–å®Œæˆ');
                    
                } else {
                    showStatus('æ— æ³•åŠ è½½Excelæ•°æ®ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', 'error');
                }
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                showStatus('ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ==================== æ–°å¢å‡½æ•°ï¼šå¯åŠ¨æ—¶æ¸…ç†ä¸´æ—¶ç¼“å­˜ ====================
        function clearTempCacheOnStartup() {
            console.log('æ¸…ç†ä¸´æ—¶ç¼“å­˜...');
            let clearedCount = 0;
            
            // è¦ä¿ç•™çš„ç¼“å­˜å‰ç¼€ï¼ˆé‡è¦æ•°æ®ï¼‰
            const keepPrefixes = [
                'celebrated_',      // åº†ç¥æ ‡è®°
                'last_checked_',    // æœ€åæ£€æŸ¥æ—¶é—´
                'upload_status_'    // ä¸Šä¼ çŠ¶æ€ï¼ˆé‡è¦ï¼ï¼‰
            ];
            
            // è¦æ¸…ç†çš„ç¼“å­˜å‰ç¼€ï¼ˆä¸´æ—¶æ•°æ®ï¼‰
            const clearPrefixes = [
                'audio_',           // éŸ³é¢‘æ–‡ä»¶ï¼ˆæ¯æ¬¡é‡æ–°åŠ è½½ï¼‰
                'sentences_',       // å¥å­æ•°æ®ï¼ˆä»æœåŠ¡å™¨é‡æ–°è·å–ï¼‰
                'excel_cache_',     // Excelç¼“å­˜ï¼ˆé‡æ–°è·å–æœ€æ–°æ•°æ®ï¼‰
                'last_download_'    // æœ€åä¸‹è½½æ—¶é—´
            ];
            
            // éå†localStorage
            for (let i = localStorage.length - 1; i >= 0; i--) {
                const key = localStorage.key(i);
                let shouldClear = false;
                
                // æ£€æŸ¥æ˜¯å¦å±äºéœ€è¦æ¸…ç†çš„ç±»å‹
                for (const prefix of clearPrefixes) {
                    if (key.startsWith(prefix)) {
                        shouldClear = true;
                        break;
                    }
                }
                
                // æ£€æŸ¥æ˜¯å¦å±äºéœ€è¦ä¿ç•™çš„ç±»å‹
                for (const prefix of keepPrefixes) {
                    if (key.startsWith(prefix)) {
                        shouldClear = false;
                        break;
                    }
                }
                
                if (shouldClear) {
                    console.log(`æ¸…ç†ç¼“å­˜: ${key}`);
                    localStorage.removeItem(key);
                    clearedCount++;
                }
            }
            
            console.log(`æ¸…ç†äº† ${clearedCount} ä¸ªä¸´æ—¶ç¼“å­˜é¡¹`);
            showStatus(`å·²æ¸…ç† ${clearedCount} ä¸ªä¸´æ—¶ç¼“å­˜`, 'info');
            
            // å¯é€‰ï¼šæ¸…ç†æ‰€æœ‰cookie
            clearAllCookies();
        }

        // ==================== å¯é€‰ï¼šæ¸…ç†Cookie ====================
        function clearAllCookies() {
            const cookies = document.cookie.split(";");
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i];
                const eqPos = cookie.indexOf("=");
                const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
                document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
            }
            console.log('æ‰€æœ‰Cookieå·²æ¸…ç†');
        }

        // åŒæ—¶ï¼Œä¿®æ”¹ validateAndFixDates å‡½æ•°ï¼š
        function validateAndFixDates() {
            console.log('å½“å‰æ—¥æœŸçŠ¶æ€:', {
                todayDate: AppState.todayDate,
                selectedDate: AppState.selectedDate,
                localToday: getLocalDateString(new Date())
            });
            
            // ç¡®ä¿ selectedDate æœ‰å€¼
            if (!AppState.selectedDate) {
                AppState.selectedDate = AppState.todayDate;
            }
            
            // å¦‚æœ selectedDate æ¯” 30 å¤©å‰è¿˜æ—©ï¼Œè°ƒæ•´ä¸º 30 å¤©å‰
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const minDateStr = getLocalDateString(thirtyDaysAgo);
            
            if (AppState.selectedDate < minDateStr) {
                console.log('è­¦å‘Šï¼šé€‰æ‹©çš„æ—¥æœŸè¶…è¿‡30å¤©é™åˆ¶ï¼Œè°ƒæ•´ä¸º30å¤©å‰');
                AppState.selectedDate = minDateStr;
            }
        }

        // æ–°å¢å‡½æ•°ï¼šåŠ è½½Excelæ•°æ®
        async function loadExcelData() {
            try {
                console.log('å¼€å§‹åŠ è½½Excelæ•°æ®...');
                const arrayBuffer = await fetchExcelFromGitee();
                
                if (arrayBuffer) {
                    const excelData = parseExcelData(arrayBuffer);
                    console.log('Excelæ•°æ®åŠ è½½æˆåŠŸï¼Œå·¥ä½œè¡¨æ•°é‡:', Object.keys(excelData).length);
                    return excelData;
                }
                return null;
            } catch (error) {
                console.error('åŠ è½½Excelæ•°æ®å¤±è´¥:', error);
                return null;
            }
        }

        // æ–°å¢å‡½æ•°ï¼šè·å–æ‰€æœ‰å¯ç”¨çš„æ—¥æœŸ
        function getAllAvailableDates() {
            if (!AppState.excelData) {
                console.log('Excelæ•°æ®æœªåŠ è½½ï¼Œæ— æ³•è·å–æ—¥æœŸåˆ—è¡¨');
                return [];
            }
            
            const availableDates = [];
            
            // 1. ä»Excelå·¥ä½œè¡¨ä¸­è·å–æ—¥æœŸ
            Object.keys(AppState.excelData).forEach(sheetName => {
                // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„æ—¥æœŸæ ¼å¼
                if (isValidDateString(sheetName)) {
                    availableDates.push(sheetName);
                }
            });
            
            // 2. å¦‚æœæœ‰éœ€è¦ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æœªæ¥çš„æ—¥æœŸ
            // ä¾‹å¦‚ï¼šæ·»åŠ æœªæ¥7å¤©çš„æ—¥æœŸ
            addFutureDates(availableDates, 7);
            
            // 3. æŒ‰æ—¥æœŸæ’åº
            availableDates.sort();
            
            console.log('å¯ç”¨çš„æ—¥æœŸåˆ—è¡¨:', availableDates);
            return availableDates;
        }

        // æ–°å¢å‡½æ•°ï¼šæ·»åŠ æœªæ¥æ—¥æœŸ
        function addFutureDates(dateArray, daysToAdd) {
            const today = new Date();
            
            for (let i = 1; i <= daysToAdd; i++) {
                const futureDate = new Date(today);
                futureDate.setDate(today.getDate() + i);
                
                const year = futureDate.getFullYear();
                const month = String(futureDate.getMonth() + 1).padStart(2, '0');
                const day = String(futureDate.getDate()).padStart(2, '0');
                const dateStr = `${year}-${month}-${day}`;
                
                // é¿å…é‡å¤æ·»åŠ 
                if (!dateArray.includes(dateStr)) {
                    dateArray.push(dateStr);
                }
            }
        }


        // æ·»åŠ æŒ‰é’®çŠ¶æ€åˆå§‹åŒ–å‡½æ•°
        function initializeButtonStates() {
            console.log('åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€...');
            
            // å¦‚æœæ²¡æœ‰é€‰ä¸­å¥å­ï¼Œç¦ç”¨æ‰€æœ‰åŠŸèƒ½æŒ‰é’®
            if (!AppState.currentSentence) {
                console.log('æ²¡æœ‰é€‰ä¸­å¥å­ï¼Œç¦ç”¨åŠŸèƒ½æŒ‰é’®');
                
                // å½•éŸ³æŒ‰é’®ï¼šå¯ä»¥ç‚¹å‡»ï¼ˆä½†ç‚¹å‡»æ—¶ä¼šæ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­å¥å­ï¼‰
                elements.recordBtn.disabled = false;
                
                // å…¶ä»–æŒ‰é’®ï¼šç¦ç”¨
                elements.stopBtn.disabled = true;
                elements.playBtn.disabled = true;
                elements.uploadBtn.disabled = true;
                
                // æ›´æ–°å½“å‰å¥å­æ˜¾ç¤º
                elements.currentSentenceId.textContent = 'æœªé€‰æ‹©';
                elements.currentSentenceText.textContent = 'è¯·ä»å·¦ä¾§åˆ—è¡¨ä¸­é€‰æ‹©ä¸€ä¸ªå¥å­å¼€å§‹å½•éŸ³';
                elements.timer.textContent = '00:00';
                elements.progressFill.style.width = '0%';
            }
        }

        // æ·»åŠ è°ƒè¯•å‡½æ•°æ¥æ£€æŸ¥æ—¥æœŸ
        function debugDateInfo() {
            console.log('=== æ—¥æœŸä¿¡æ¯è°ƒè¯• ===');
            
            // å½“å‰æ—¶é—´
            const now = new Date();
            console.log('å½“å‰æ—¶é—´å¯¹è±¡:', now);
            console.log('UTCæ—¶é—´:', now.toISOString());
            console.log('æœ¬åœ°æ—¶é—´:', now.toString());
            
            // å„ç§æ ¼å¼
            console.log('ISOåˆ†å‰²:', now.toISOString().split('T')[0]);
            console.log('æœ¬åœ°æ ¼å¼åŒ–:', 
                now.getFullYear() + '-' + 
                String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                String(now.getDate()).padStart(2, '0')
            );
            
            // æ£€æŸ¥æ—¥æœŸè¾“å…¥
            const dateInput = document.getElementById('datePicker');
            if (dateInput) {
                console.log('æ—¥æœŸè¾“å…¥æ¡†:', {
                    value: dateInput.value,
                    min: dateInput.min,
                    max: dateInput.max,
                    step: dateInput.step
                });
            }
            
            // æ£€æŸ¥AppState
            console.log('AppStateæ—¥æœŸ:', {
                todayDate: AppState.todayDate,
                selectedDate: AppState.selectedDate
            });
        }

        // ä¿®æ”¹åˆ›å»ºæ—¥æœŸé€‰é¡¹çš„é€»è¾‘
        function createDateOption(date) {
            const option = document.createElement('option');
            option.value = date;
            option.textContent = formatDateDisplay(date);
            
            // å¦‚æœæ˜¯ä»Šå¤©ï¼Œæ·»åŠ ç‰¹æ®Šæ ·å¼
            if (date === AppState.todayDate) {
                option.classList.add('date-option-today');
            }
            
            return option;
        }

        // åˆ›å»ºæ—¥æœŸé€‰æ‹©å™¨
        function createDateSelector(availableDates) {
            if (!availableDates || availableDates.length === 0) {
                console.log('æ²¡æœ‰å¯ç”¨çš„æ—¥æœŸæ•°æ®');
                showStatus('æ²¡æœ‰æ‰¾åˆ°æ—¥æœŸæ•°æ®', 'error');
                return null;
            }
            
            // åˆ›å»ºæ—¥æœŸé€‰æ‹©å™¨å®¹å™¨
            const dateSelector = document.createElement('div');
            dateSelector.className = 'date-selector';
            
            // æ—¥æœŸé€‰æ‹©å™¨æ ‡ç­¾
            const label = document.createElement('label');
            label.textContent = 'ğŸ“… é€‰æ‹©æ—¥æœŸ:';
            label.htmlFor = 'datePicker';
            
            // åˆ›å»ºä¸‹æ‹‰é€‰æ‹©æ¡†
            const dateSelect = document.createElement('select');
            dateSelect.id = 'datePicker';
            dateSelect.className = 'date-select';
            dateSelect.title = 'é€‰æ‹©è¦å½•éŸ³çš„æ—¥æœŸ';
            
            // æ·»åŠ CSSæ ·å¼ï¼ˆå¦‚æœå°šæœªæ·»åŠ ï¼‰
            if (!document.querySelector('#date-selector-styles')) {
                const style = document.createElement('style');
                style.id = 'date-selector-styles';
                style.textContent = `
                    .date-selector {
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        margin: 20px 40px;
                        padding: 15px 20px;
                        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
                        border-radius: 10px;
                        border: 1px solid rgba(102, 126, 234, 0.2);
                    }
                    
                    .date-selector label {
                        font-weight: bold;
                        color: #333;
                        font-size: 16px;
                        white-space: nowrap;
                    }
                    
                    .date-select {
                        padding: 8px 12px;
                        border: 2px solid #667eea;
                        border-radius: 6px;
                        font-size: 14px;
                        color: #333;
                        background: white;
                        cursor: pointer;
                        flex: 1;
                        max-width: 250px;
                        min-width: 180px;
                        outline: none;
                        transition: all 0.3s ease;
                    }
                    
                    .date-select:hover {
                        border-color: #764ba2;
                    }
                    
                    .date-select:focus {
                        border-color: #764ba2;
                        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
                    }
                    
                    .date-select option {
                        padding: 8px;
                        font-size: 14px;
                    }
                    
                    .date-option-today {
                        color: #ff6b6b;
                        font-weight: bold;
                        background-color: rgba(255, 107, 107, 0.1);
                    }
                    
                    .date-quick-buttons {
                        display: flex;
                        gap: 8px;
                        margin-left: auto;
                    }
                    
                    .date-info {
                        font-size: 14px;
                        color: #666;
                        margin-left: 10px;
                        font-style: italic;
                        align-self: center;
                    }
                    
                    @media (max-width: 768px) {
                        .date-selector {
                            flex-direction: column;
                            align-items: stretch;
                            margin: 20px;
                        }
                        
                        .date-select {
                            max-width: none;
                            width: 100%;
                        }
                        
                        .date-quick-buttons {
                            margin-left: 0;
                            justify-content: center;
                            margin-top: 10px;
                            flex-wrap: wrap;
                        }
                        
                        .date-info {
                            margin-left: 0;
                            margin-top: 10px;
                            text-align: center;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            console.log('åˆ›å»ºæ—¥æœŸé€‰æ‹©å™¨ï¼Œå¯ç”¨æ—¥æœŸæ•°é‡:', availableDates.length);
            console.log('å¯ç”¨æ—¥æœŸ:', availableDates);
            console.log('ä»Šå¤©æ—¥æœŸ:', AppState.todayDate);
            console.log('å½“å‰é€‰ä¸­æ—¥æœŸ:', AppState.selectedDate);
            
            // å…ˆæ‰¾åˆ°ä»Šå¤©çš„é€‰é¡¹ï¼Œç¡®ä¿é€‰ä¸­
            let todayIndex = -1;
            
            // æ·»åŠ æ—¥æœŸé€‰é¡¹
            availableDates.forEach((date, index) => {
                // éªŒè¯æ—¥æœŸæ ¼å¼
                if (!isValidDateString(date)) {
                    console.warn('è·³è¿‡æ— æ•ˆçš„æ—¥æœŸæ ¼å¼:', date);
                    return;
                }
                
                const option = document.createElement('option');
                option.value = date;
                option.textContent = formatDateDisplay(date);
                
                // å¦‚æœæ˜¯ä»Šå¤©ï¼Œæ·»åŠ ç‰¹æ®Šæ ·å¼
                if (date === AppState.todayDate) {
                    option.classList.add('date-option-today');
                    todayIndex = index;
                    console.log('æ‰¾åˆ°ä»Šå¤©é€‰é¡¹ï¼Œç´¢å¼•:', todayIndex, 'æ—¥æœŸ:', date);
                }
                
                dateSelect.appendChild(option);
            });
            
            // è®¾ç½®é»˜è®¤é€‰ä¸­é¡¹
            let selectedIndex = 0;
            
            // ä¼˜å…ˆé€‰ä¸­ä»Šå¤©
            if (todayIndex !== -1) {
                selectedIndex = todayIndex;
                console.log('é»˜è®¤é€‰ä¸­ä»Šå¤©ï¼Œç´¢å¼•:', selectedIndex);
            } 
            // å¦‚æœæ²¡æœ‰ä»Šå¤©é€‰é¡¹ï¼Œå°è¯•é€‰ä¸­å½“å‰é€‰ä¸­çš„æ—¥æœŸ
            else if (AppState.selectedDate) {
                const selectedDateIndex = availableDates.indexOf(AppState.selectedDate);
                if (selectedDateIndex !== -1) {
                    selectedIndex = selectedDateIndex;
                    console.log('é€‰ä¸­å½“å‰é€‰æ‹©çš„æ—¥æœŸï¼Œç´¢å¼•:', selectedIndex);
                }
            }
            
            // è®¾ç½®é€‰ä¸­é¡¹
            dateSelect.selectedIndex = selectedIndex;
            AppState.selectedDate = dateSelect.value;
            
            console.log('æœ€ç»ˆé€‰æ‹©çš„æ—¥æœŸ:', AppState.selectedDate, 'ç´¢å¼•:', selectedIndex);
            
            // æ—¥æœŸå˜åŒ–äº‹ä»¶
            dateSelect.addEventListener('change', async (e) => {
                const newDate = e.target.value;
                console.log('æ—¥æœŸé€‰æ‹©å™¨å˜åŒ–ï¼Œæ–°æ—¥æœŸ:', newDate);
    
                // æ¸…ç†æ–°æ—¥æœŸçš„åº†ç¥æ ‡è®°ï¼ˆè®©æ–°æ—¥æœŸå¯ä»¥é‡æ–°åº†ç¥ï¼‰
                const newCelebrationKey = `celebrated_${newDate}`;
                localStorage.removeItem(newCelebrationKey);
                
                if (newDate === AppState.selectedDate) {
                    console.log('æ—¥æœŸæœªå˜åŒ–ï¼Œè·³è¿‡');
                    return;
                }
                
                console.log('åˆ‡æ¢åˆ°æ—¥æœŸ:', newDate);
                showLoading(true);

                // é‡ç½®å½“å‰é€‰æ‹©çŠ¶æ€
                resetToNoSelectionState();
                
                // åœæ­¢æ­£åœ¨è¿›è¡Œçš„æ“ä½œ
                if (AppState.isRecording) stopRecording();
                if (AppState.isPlaying) stopPlayback();
                
                // ä¿å­˜å½“å‰æ—¥æœŸçš„çŠ¶æ€
                saveCurrentState();
                
                // æ›´æ–°æ—¥æœŸ
                AppState.selectedDate = newDate;
                
                try {
                    // 1. å°è¯•ä»ç¼“å­˜åŠ è½½
                    const cacheKey = `excel_cache_${newDate}`;
                    const cached = localStorage.getItem(cacheKey);
                    
                    let sentences = null;
                    
                    if (cached) {
                        try {
                            const parsed = JSON.parse(cached);
                            if (parsed && parsed.sentences) {
                                sentences = parsed.sentences;
                                console.log(`ä»ç¼“å­˜åŠ è½½ ${newDate} çš„å¥å­:`, sentences.length);
                            }
                        } catch (parseError) {
                            console.warn('è§£æç¼“å­˜æ•°æ®å¤±è´¥:', parseError);
                        }
                    }
                    
                    // 2. å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œä»ExcelåŠ è½½
                    if (!sentences) {
                        console.log('ç¼“å­˜æœªå‘½ä¸­ï¼Œä»ExcelåŠ è½½:', newDate);
                        
                        if (AppState.excelData) {
                            sentences = getSentencesByDate(newDate);
                        }
                    }
                    
                    // 3. æ›´æ–°å¥å­åˆ—è¡¨
                    if (sentences && sentences.length > 0) {
                        AppState.sentences = sentences;
                        console.log(`åŠ è½½ ${newDate} å¥å­æˆåŠŸ:`, sentences.length);
                        
                        // æ£€æŸ¥æœ¬åœ°å½•éŸ³çŠ¶æ€
                        await checkDateRecordings();
                        
                        // æ¸²æŸ“åˆ—è¡¨
                        renderSentenceList();
                        updateStats();
                        
                        // showStatus(`å·²åˆ‡æ¢åˆ° ${newDate} çš„æ•°æ®`, 'success');
                        
                    } else {
                        // ä½¿ç”¨ç¤ºä¾‹å¥å­
                        console.log(`${newDate} æ²¡æœ‰æ•°æ®ï¼Œä½¿ç”¨ç¤ºä¾‹å¥å­`);
                        useFallbackSentences();
                        renderSentenceList();
                        updateStats();
                        showStatus(`${newDate} è¿˜æœªå¸ƒç½®ä½œä¸š`, 'info');
                    }
                    
                    // 4. é‡ç½®å½“å‰å¥å­
                    resetCurrentSentence();
                    
                    // 5. æ£€æŸ¥æœåŠ¡å™¨æ–‡ä»¶ï¼ˆå¦‚æœä¸æ˜¯æœªæ¥æ—¥æœŸï¼‰
                    if (newDate <= AppState.todayDate) {
                        setTimeout(() => {
                            checkServerFilesInBackground();
                        }, 300);
                    }
                    
                    // 6. æ›´æ–°æ—¥æœŸä¿¡æ¯æ˜¾ç¤º
                    updateDateInfo();
                    
                } catch (error) {
                    console.error('åˆ‡æ¢æ—¥æœŸå¤±è´¥:', error);
                    showStatus('åŠ è½½æ–°æ—¥æœŸæ•°æ®å¤±è´¥', 'error');
                    
                    // å‡ºé”™æ—¶ä½¿ç”¨åå¤‡å¥å­
                    useFallbackSentences();
                    renderSentenceList();
                    updateStats();
                } finally {
                    showLoading(false);
                }
            });
            
            // æ·»åŠ å¿«æ·æŒ‰é’®å®¹å™¨
            const quickButtons = document.createElement('div');
            quickButtons.className = 'date-quick-buttons';
            
            // é‡æ–°åŠ è½½æŒ‰é’®
            const reloadBtn = document.createElement('button');
            reloadBtn.textContent = 'ğŸ”„ é‡æ–°åŠ è½½';
            reloadBtn.className = 'btn btn-reload';
            reloadBtn.title = 'é‡æ–°ä»ExcelåŠ è½½å¥å­æ•°æ®';
            reloadBtn.onclick = async () => {
                showLoading(true);
                try {
                    // é‡æ–°åŠ è½½Excelæ•°æ®
                    const excelData = await loadExcelData();
                    if (excelData) {
                        AppState.excelData = excelData;
                        
                        // é‡æ–°åŠ è½½å½“å‰æ—¥æœŸçš„å¥å­
                        await reloadCurrentDateSentences();
                        
                        showStatus('æ•°æ®å·²é‡æ–°åŠ è½½', 'success');
                    } else {
                        showStatus('é‡æ–°åŠ è½½å¤±è´¥', 'error');
                    }
                } catch (error) {
                    console.error('é‡æ–°åŠ è½½å¤±è´¥:', error);
                    showStatus('é‡æ–°åŠ è½½å¤±è´¥', 'error');
                } finally {
                    showLoading(false);
                }
            };
            
            // ä»Šå¤©æŒ‰é’®
            const todayBtn = document.createElement('button');
            todayBtn.textContent = 'ä»Šå¤©';
            todayBtn.className = 'btn btn-today';
            todayBtn.title = 'åˆ‡æ¢åˆ°ä»Šå¤©';
            todayBtn.onclick = () => {
                const todayStr = AppState.todayDate;
                
                // æ£€æŸ¥ä»Šå¤©æ˜¯å¦åœ¨å¯é€‰åˆ—è¡¨ä¸­
                const optionExists = Array.from(dateSelect.options).some(opt => opt.value === todayStr);
                
                if (optionExists) {
                    dateSelect.value = todayStr;
                    dateSelect.dispatchEvent(new Event('change'));
                } else {
                    showStatus('ä»Šå¤©è¿˜æœªå¸ƒç½®ä½œä¸šï¼Œè¯·é€‰æ‹©å…¶ä»–æ—¥æœŸ', 'info');
                }
            };
            
            // ä¿¡æ¯æç¤º
            const infoSpan = document.createElement('span');
            infoSpan.className = 'date-info';
            infoSpan.textContent = `å½“å‰: ${formatDateDisplay(AppState.selectedDate)}`;
            infoSpan.style.cssText = 'font-size: 14px; color: #666; margin-left: 10px; font-style: italic;';
            
            // æ·»åŠ æ‰€æœ‰æŒ‰é’®
            quickButtons.appendChild(reloadBtn);
            quickButtons.appendChild(todayBtn);
            
            dateSelector.appendChild(label);
            dateSelector.appendChild(dateSelect);
            dateSelector.appendChild(quickButtons);
            dateSelector.appendChild(infoSpan);
            
            // æ’å…¥åˆ°æ ‡é¢˜ä¸‹é¢
            const header = document.querySelector('.header');
            if (header) {
                header.parentNode.insertBefore(dateSelector, header.nextSibling);
                console.log('æ—¥æœŸé€‰æ‹©å™¨å·²æ·»åŠ åˆ°é¡µé¢');
            } else {
                console.error('æ‰¾ä¸åˆ°.headerå…ƒç´ ï¼Œæ— æ³•æ·»åŠ æ—¥æœŸé€‰æ‹©å™¨');
            }
            
            return dateSelect;
        }

        // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤ºï¼šä»Šå¤©æ˜¾ç¤º"ä»Šå¤©"ï¼Œå…¶ä»–æ—¥æœŸæ˜¾ç¤º"æ—¥æœŸ å‘¨å‡ "
        function formatDateDisplay(dateStr) {
            if (!dateStr) return '';
            
            // ç¡®ä¿æ—¥æœŸå­—ç¬¦ä¸²æ˜¯æœ‰æ•ˆçš„
            if (!isValidDateString(dateStr)) {
                console.warn('æ— æ•ˆçš„æ—¥æœŸæ ¼å¼:', dateStr);
                return dateStr;
            }
            
            try {
                const date = new Date(dateStr);
                const now = new Date();
                const todayStr = getLocalDateString(now);
                
                // å‘¨å‡ çš„æ˜ å°„
                const weekDays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
                const weekDay = weekDays[date.getDay()];
                
                // å¦‚æœæ˜¯ä»Šå¤©
                if (dateStr === todayStr) {
                    return `${dateStr} ${weekDay} (ä»Šå¤©)`;
                }
                
                // å…¶ä»–æƒ…å†µåªæ˜¾ç¤ºæ—¥æœŸå’Œå‘¨å‡ 
                return `${dateStr} ${weekDay}`;
            } catch (error) {
                console.error('æ ¼å¼åŒ–æ—¥æœŸæ—¶å‡ºé”™:', error, 'æ—¥æœŸå­—ç¬¦ä¸²:', dateStr);
                return dateStr;
            }
        }

        // æ–°å¢å‡½æ•°ï¼šæ›´æ–°æ—¥æœŸé€‰æ‹©å™¨
        function updateDateSelector() {
            const dateSelect = document.getElementById('datePicker');
            if (!dateSelect) return;
            
            // è·å–æ‰€æœ‰å¯ç”¨çš„æ—¥æœŸ
            const availableDates = getAllAvailableDates();
            
            // ä¿å­˜å½“å‰é€‰ä¸­çš„å€¼
            const currentValue = dateSelect.value;
            
            // æ¸…ç©ºé€‰é¡¹
            dateSelect.innerHTML = '';
            
            // é‡æ–°æ·»åŠ é€‰é¡¹
            availableDates.forEach(date => {
                const option = document.createElement('option');
                option.value = date;
                option.textContent = formatDateDisplay(date);
                
                // æ ‡è®°ä»Šå¤©çš„æ—¥æœŸ
                if (date === AppState.todayDate) {
                    option.textContent += ' (ä»Šå¤©)';
                    option.classList.add('date-option-today');
                }
                
                // æ ‡è®°æœªæ¥æ—¥æœŸ
                if (date > AppState.todayDate) {
                    option.textContent += ' (æœªæ¥)';
                    option.classList.add('date-option-future');
                }
                
                dateSelect.appendChild(option);
            });
            
            // å°è¯•æ¢å¤ä¹‹å‰çš„é€‰æ‹©ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™é€‰æ‹©ç¬¬ä¸€ä¸ª
            const optionExists = Array.from(dateSelect.options).some(opt => opt.value === currentValue);
            if (optionExists) {
                dateSelect.value = currentValue;
            } else if (dateSelect.options.length > 0) {
                dateSelect.selectedIndex = 0;
            }
        }

        // æ–°å¢å‡½æ•°ï¼šé‡æ–°åŠ è½½å½“å‰æ—¥æœŸçš„å¥å­
        async function reloadCurrentDateSentences() {
            try {
                console.log('é‡æ–°åŠ è½½å½“å‰æ—¥æœŸå¥å­:', AppState.selectedDate);
                
                let sentences = null;
                
                // å°è¯•ä»ç¼“å­˜åŠ è½½
                const cacheKey = `excel_cache_${AppState.selectedDate}`;
                const cached = localStorage.getItem(cacheKey);
                
                if (cached) {
                    const parsed = JSON.parse(cached);
                    if (parsed && parsed.sentences) {
                        sentences = parsed.sentences;
                    }
                }
                
                // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œä»ExcelåŠ è½½
                if (!sentences && AppState.excelData) {
                    sentences = getSentencesByDate(AppState.selectedDate);
                }
                
                // æ›´æ–°å¥å­åˆ—è¡¨
                if (sentences && sentences.length > 0) {
                    AppState.sentences = sentences;
                    
                    // æ£€æŸ¥æœ¬åœ°å½•éŸ³çŠ¶æ€
                    await checkDateRecordings();
                    
                    renderSentenceList();
                    updateStats();
                    
                    showStatus('å¥å­æ•°æ®å·²é‡æ–°åŠ è½½', 'success');
                } else {
                    useFallbackSentences();
                    renderSentenceList();
                    updateStats();
                    
                    showStatus('ä½¿ç”¨ç¤ºä¾‹å¥å­', 'info');
                }
                
            } catch (error) {
                console.error('é‡æ–°åŠ è½½å¥å­å¤±è´¥:', error);
                showStatus('é‡æ–°åŠ è½½å¤±è´¥', 'error');
            }
        }


        // æ›´æ–°æ—¥æœŸä¿¡æ¯æ˜¾ç¤º
        function updateDateInfo() {
            const infoElement = document.querySelector('.date-info');
            if (infoElement) {
                infoElement.textContent = `å½“å‰: ${AppState.selectedDate} | å¥å­: ${AppState.sentences.length}`;
            }
        }

        // ä¿å­˜å½“å‰çŠ¶æ€
        function saveCurrentState() {
            if (AppState.sentences.length > 0) {
                const key = `sentences_${AppState.selectedDate}`;
                localStorage.setItem(key, JSON.stringify(AppState.sentences));
                console.log(`ä¿å­˜ ${AppState.selectedDate} çš„æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨`);
            }
        }

        // é‡ç½®å½“å‰å¥å­
        function resetCurrentSentence() {
            AppState.currentSentence = null;
            AppState.audioBlob = null;
            
            elements.currentSentenceId.textContent = '';
            elements.currentSentenceText.textContent = 'è¯·é€‰æ‹©æ—¥æœŸä¸­çš„ä¸€å¥å¼€å§‹æœ—è¯»å½•éŸ³';
            elements.playBtn.disabled = true;
            elements.uploadBtn.disabled = true;
            elements.recordBtn.disabled = false;
            elements.stopBtn.disabled = true;
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
        }

        // åŠ è½½æŒ‡å®šæ—¥æœŸçš„å¥å­æ•°æ®
        async function loadSentencesForSelectedDate() {
            console.log('åŠ è½½æ—¥æœŸæ•°æ®:', AppState.selectedDate);
            
            const savedKey = `sentences_${AppState.selectedDate}`;
            const saved = localStorage.getItem(savedKey);
            
            if (saved) {
                try {
                    AppState.sentences = JSON.parse(saved);
                    console.log(`ä»æœ¬åœ°å­˜å‚¨åŠ è½½ ${AppState.selectedDate} çš„å¥å­æ•°æ®ï¼Œå…±`, AppState.sentences.length, 'æ¡');
                } catch (e) {
                    console.warn('æœ¬åœ°å­˜å‚¨æ•°æ®æŸåï¼Œä½¿ç”¨é»˜è®¤å¥å­');
                    AppState.sentences = SAMPLE_SENTENCES.map(s => ({
                        ...s,
                        recorded: false,
                        hasUploaded: false
                    }));
                }
            } else {
                // æ€»æ˜¯ä»é»˜è®¤å¥å­å¤åˆ¶ç»“æ„ï¼Œæ¸…é™¤å½•åˆ¶çŠ¶æ€
                AppState.sentences = SAMPLE_SENTENCES.map(s => ({
                    ...s,
                    recorded: false,
                    hasUploaded: false,
                    lastRecorded: null,
                    uploadedAt: null
                }));
                console.log(`åˆå§‹åŒ– ${AppState.selectedDate} çš„å¥å­æ•°æ®ï¼Œå…±`, AppState.sentences.length, 'æ¡');
            }
            
            // åˆå§‹åŒ–hasUploadedå±æ€§
            AppState.sentences.forEach(sentence => {
                if (sentence.hasUploaded === undefined) {
                    sentence.hasUploaded = false;
                }
            });
            
            // æ£€æŸ¥æœ¬åœ°å½•éŸ³æ–‡ä»¶
            await checkDateRecordings();
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            saveSentencesForSelectedDate();
        }

        // ==================== ä¿®æ”¹æ£€æŸ¥æœ¬åœ°å½•éŸ³çŠ¶æ€çš„å‡½æ•° ====================
        async function checkDateRecordings() {
            console.log(`æ£€æŸ¥ ${AppState.selectedDate} çš„æœ¬åœ°å½•éŸ³å’Œä¸Šä¼ çŠ¶æ€`);
            
            for (const sentence of AppState.sentences) {
                // 1. æ£€æŸ¥æœ¬åœ°å½•éŸ³
                const audioKey = `audio_${AppState.selectedDate}_${sentence.id}`;
                const audioData = localStorage.getItem(audioKey);
                
                if (audioData) {
                    sentence.recorded = true;
                    sentence.lastRecorded = AppState.selectedDate;
                } else {
                    sentence.recorded = false;
                    sentence.lastRecorded = null;
                }
                
                // 2. ä»ç¼“å­˜è·å–ä¸Šä¼ çŠ¶æ€ï¼ˆä¼˜å…ˆï¼‰
                const cachedUploadStatus = StateCache.getUploadStatus(AppState.selectedDate, sentence.id);
                if (cachedUploadStatus !== null) {
                    sentence.hasUploaded = cachedUploadStatus;
                    console.log(`ä½¿ç”¨ç¼“ä¸Šä¼ å­˜çŠ¶æ€: ${sentence.id} = ${cachedUploadStatus}`);
                } else {
                    // ç¼“å­˜ä¸­æ²¡æœ‰ï¼Œåˆå§‹åŒ–ä¸ºfalse
                    sentence.hasUploaded = false;
                }
            }
            
            // 3. åœ¨åå°æŸ¥è¯¢æœåŠ¡å™¨çŠ¶æ€ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if (shouldCheckServerStatus()) {
                setTimeout(() => {
                    checkServerFilesInBackground();
                }, 1000);
            }
        }


        // åˆ¤æ–­æ˜¯å¦éœ€è¦æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
        function shouldCheckServerStatus() {
            // å¦‚æœæ˜¯ä»Šå¤©æˆ–æœ€è¿‘çš„æ—¥æœŸï¼Œéœ€è¦æ£€æŸ¥
            if (AppState.selectedDate === AppState.todayDate) {
                return true;
            }
            
            // å¦‚æœæ˜¯è¿‡å»çš„æ—¥æœŸï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜
            const lastCheckedKey = `last_checked_${AppState.selectedDate}`;
            const lastChecked = localStorage.getItem(lastCheckedKey);
            
            if (lastChecked) {
                const lastCheckTime = parseInt(lastChecked, 10);
                const now = Date.now();
                // å¦‚æœ24å°æ—¶å†…æ£€æŸ¥è¿‡ï¼Œè·³è¿‡
                if (now - lastCheckTime < 24 * 60 * 60 * 1000) {
                    console.log(`æ—¥æœŸ ${AppState.selectedDate} 24å°æ—¶å†…å·²æ£€æŸ¥è¿‡ï¼Œè·³è¿‡`);
                    return false;
                }
            }
            
            return true;
        }

        // ä¿å­˜å½“å‰é€‰æ‹©æ—¥æœŸçš„å¥å­æ•°æ®
        function saveSentencesForSelectedDate() {
            const key = `sentences_${AppState.selectedDate}`;
            localStorage.setItem(key, JSON.stringify(AppState.sentences));
            updateDateInfo(); // æ·»åŠ è¿™è¡Œ
        }

        // ä¿®å¤åçš„æ–‡ä»¶æ£€æŸ¥å‡½æ•°ï¼Œæ”¯æŒå¤šç§æ ¼å¼
        async function checkFileExistsOnServer(sentenceId) {    
            // æ”¯æŒçš„éŸ³é¢‘æ ¼å¼åˆ—è¡¨
            const supportedFormats = ['webm', 'mp4', 'wav', 'ogg', 'm4a'];
            const fileNameBase = `${AppState.selectedDate}_${sentenceId}`;
            
            console.log(`æ£€æŸ¥Giteeæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ŒåŸºæœ¬åç§°: ${fileNameBase}`);
            
            // æŒ‰é¡ºåºæ£€æŸ¥å„ç§æ ¼å¼
            for (const format of supportedFormats) {
                const fileName = `${fileNameBase}.${format}`;
                const filePath = `${GITEE_CONFIG.RECORDINGS_DIR}/${AppState.selectedDate}/${fileName}`;
                
                console.log(`å°è¯•æ£€æŸ¥æ ¼å¼: ${format}, è·¯å¾„: ${filePath}`);
                
                try {
                    const sha = await getGiteeFileSHA(filePath);
                    
                    if (sha) {
                        console.log(`âœ… æ–‡ä»¶å­˜åœ¨ï¼ˆæ ¼å¼: ${format}ï¼‰: ${filePath}`);
                        return true;
                    }
                } catch (error) {
                    console.log(`æ£€æŸ¥æ ¼å¼ ${format} å¤±è´¥:`, error.message);
                    continue; // ç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªæ ¼å¼
                }
            }
            
            // å¦‚æœæ‰€æœ‰æ ¼å¼éƒ½æ£€æŸ¥å®Œæ¯•éƒ½æ²¡æ‰¾åˆ°
            console.log(`âŒ æ‰€æœ‰æ ¼å¼æ£€æŸ¥å®Œæ¯•ï¼Œæ–‡ä»¶ ${fileNameBase} ä¸å­˜åœ¨`);
            return false;
        }async function checkFileExistsOnServer(sentenceId) {    
            // æ”¯æŒçš„éŸ³é¢‘æ ¼å¼åˆ—è¡¨
            const supportedFormats = ['webm', 'mp4', 'wav', 'ogg', 'm4a'];
            const fileNameBase = `${AppState.selectedDate}_${sentenceId}`;
            
            console.log(`æ£€æŸ¥Giteeæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ŒåŸºæœ¬åç§°: ${fileNameBase}`);
            
            // æŒ‰é¡ºåºæ£€æŸ¥å„ç§æ ¼å¼
            for (const format of supportedFormats) {
                const fileName = `${fileNameBase}.${format}`;
                const filePath = `${GITEE_CONFIG.RECORDINGS_DIR}/${AppState.selectedDate}/${fileName}`;
                
                console.log(`å°è¯•æ£€æŸ¥æ ¼å¼: ${format}, è·¯å¾„: ${filePath}`);
                
                try {
                    const sha = await getGiteeFileSHA(filePath);
                    
                    if (sha) {
                        console.log(`âœ… æ–‡ä»¶å­˜åœ¨ï¼ˆæ ¼å¼: ${format}ï¼‰: ${filePath}`);
                        return true;
                    }
                } catch (error) {
                    console.log(`æ£€æŸ¥æ ¼å¼ ${format} å¤±è´¥:`, error.message);
                    continue; // ç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªæ ¼å¼
                }
            }
            
            // å¦‚æœæ‰€æœ‰æ ¼å¼éƒ½æ£€æŸ¥å®Œæ¯•éƒ½æ²¡æ‰¾åˆ°
            console.log(`âŒ æ‰€æœ‰æ ¼å¼æ£€æŸ¥å®Œæ¯•ï¼Œæ–‡ä»¶ ${fileNameBase} ä¸å­˜åœ¨`);
            return false;
        }


        async function checkServerFilesInBackground() {
            console.log(`å¼€å§‹åœ¨åå°æ£€æŸ¥ ${AppState.selectedDate} çš„æœåŠ¡å™¨çŠ¶æ€...`);
            
            // è®°å½•æ£€æŸ¥æ—¶é—´
            const lastCheckedKey = `last_checked_${AppState.selectedDate}`;
            localStorage.setItem(lastCheckedKey, Date.now().toString());
            
            try {
                let updatedCount = 0;
                const uploadStatusMap = {};
                
                for (let i = 0; i < AppState.sentences.length; i++) {
                    const sentence = AppState.sentences[i];
                    
                    // è·³è¿‡å·²ç¡®å®šçŠ¶æ€çš„å¥å­ï¼ˆé™¤ééœ€è¦é‡æ–°éªŒè¯ï¼‰
                    if (sentence.hasUploaded === true) {
                        uploadStatusMap[sentence.id] = true;
                        continue;
                    }
                    
                    try {
                        const fileExists = await checkFileExistsOnServer(sentence.id);
                        const wasUploaded = sentence.hasUploaded;
                        
                        if (fileExists !== sentence.hasUploaded) {
                            sentence.hasUploaded = fileExists;
                            uploadStatusMap[sentence.id] = fileExists;
                            updatedCount++;
                            
                            console.log(`å¥å­ ${sentence.id} çŠ¶æ€å˜åŒ–: ${wasUploaded} -> ${fileExists}`);
                            
                            // ç«‹å³æ›´æ–°UI
                            updateSentenceItemInUI(sentence);
                        } else {
                            uploadStatusMap[sentence.id] = sentence.hasUploaded;
                        }
                        
                        // è®°å½•çŠ¶æ€ï¼ˆæ— è®ºæ˜¯å¦å˜åŒ–éƒ½è®°å½•ï¼‰
                        StateCache.setUploadStatus(AppState.selectedDate, sentence.id, sentence.hasUploaded);
                        
                    } catch (error) {
                        console.warn(`æ£€æŸ¥å¥å­ ${sentence.id} å¤±è´¥:`, error);
                    }
                }
                
                // æ‰¹é‡ç¼“å­˜æ‰€æœ‰å¥å­çš„çŠ¶æ€
                StateCache.batchSetUploadStatus(AppState.selectedDate, uploadStatusMap);
                
                // ä¿å­˜æ›´æ–°åçš„çŠ¶æ€
                saveSentencesForSelectedDate();
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                updateStats();
                
                console.log(`åå°æ£€æŸ¥å®Œæˆï¼Œæ›´æ–°äº† ${updatedCount} æ¡è®°å½•`);
                
            } catch (error) {
                console.error('åå°æ£€æŸ¥å‡ºé”™:', error);
                showStatus('æ£€æŸ¥æœåŠ¡å™¨æ–‡ä»¶å¤±è´¥', 'error');
            }
        }

        // æ›´æ–°å¥å­é¡¹UI
        function updateSentenceItemInUI(sentence) {
            const items = document.querySelectorAll('.sentence-item');
            
            for (const item of items) {
                const idElement = item.querySelector('.sentence-meta span:first-child');
                if (idElement && idElement.textContent.trim() === sentence.id) {
                    updateItemUI(item, sentence);
                    return;
                }
            }
            
            // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œé‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
            renderSentenceList();
            updateStats();
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°å•ä¸ªé¡¹ç›®çš„UI
        function updateItemUI(item, sentence) {
            const badge = item.querySelector('.status-badge');
            const textElement = item.querySelector('.sentence-text');
            
            if (!badge || !textElement) return;
            
            // ç¡®å®šçŠ¶æ€
            let statusClass, statusText;
            let prefix = '';
            
            if (sentence.hasUploaded) {
                statusClass = 'status-uploaded';
                statusText = 'âœ“ å·²ä¸Šä¼ ';
                prefix = 'ğŸŒ ';
            } else if (sentence.recorded) {
                statusClass = 'status-recorded';
                statusText = 'âœ“ å·²å½•åˆ¶';
                // å·²å½•åˆ¶ä½†æœªä¸Šä¼ çš„å¥å­ä¸åŠ å‰ç¼€
                prefix = '';
            } else {
                statusClass = 'status-pending';
                statusText = 'å¾…å½•åˆ¶';
                prefix = '';
            }
            
            // æ›´æ–°å¾½ç« 
            badge.className = `status-badge ${statusClass}`;
            badge.textContent = statusText;
            
            // æ›´æ–°æ–‡æœ¬ - åªå¯¹å·²ä¸Šä¼ çš„å¥å­æ·»åŠ å‰ç¼€
            if (prefix && !textElement.textContent.startsWith('ğŸŒ ')) {
                textElement.textContent = prefix + sentence.text;
            } else if (!prefix && textElement.textContent.startsWith('ğŸŒ ')) {
                textElement.textContent = sentence.text;
            }
            
            // å¦‚æœéœ€è¦ï¼ŒåŒæ—¶æ›´æ–°å½“å‰é€‰ä¸­çš„å¥å­çš„æ˜¾ç¤º
            if (AppState.currentSentence && AppState.currentSentence.id === sentence.id) {
                AppState.currentSentence.hasUploaded = sentence.hasUploaded;
                
                // æ›´æ–°ä¸Šä¼ æŒ‰é’®çŠ¶æ€
                if (sentence.hasUploaded) {
                    elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                } else {
                    elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨';
                }
            }
        }

        async function getGiteeFileSHA(filePath) {
            try {
                const response = await fetch(
            `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`,
                    {
                        headers: {
                            'Accept': 'application/json'
                        }
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºæ•°ç»„
                    if (Array.isArray(data) && data.length === 0) {
                        return null;
                    }
                    return data.sha;
                }
                return null;
            } catch (error) {
                console.log('Giteeæ–‡ä»¶ä¸å­˜åœ¨æˆ–ç½‘ç»œé”™è¯¯:', error);
                return null;
            }
        }

        function renderSentenceList() {
            console.log('æ¸²æŸ“å¥å­åˆ—è¡¨ï¼Œå…±', AppState.sentences.length, 'æ¡');
            
            elements.sentencesContainer.innerHTML = '';
            
            AppState.sentences.forEach((sentence, index) => {
                const item = document.createElement('div');
                item.className = `sentence-item ${sentence === AppState.currentSentence ? 'active' : ''}`;
                item.dataset.sentenceId = sentence.id;
                item.dataset.index = index + 1; // æ·»åŠ ç´¢å¼•
                
                // ä½¿ç”¨æœ€æ–°çš„çŠ¶æ€
                let statusClass = 'status-pending';
                let statusText = 'å¾…å½•åˆ¶';
                let prefix = '';
                
                // ä¼˜å…ˆä½¿ç”¨ç¼“å­˜çš„ä¸Šä¼ çŠ¶æ€
                if (sentence.hasUploaded) {
                    statusClass = 'status-uploaded';
                    statusText = 'âœ“ å·²ä¸Šä¼ ';
                    prefix = 'ğŸŒ ';
                } else if (sentence.recorded) {
                    statusClass = 'status-recorded';
                    statusText = 'âœ“ å·²å½•åˆ¶';
                }
                
                // æ·»åŠ åºå· - åœ¨IDå‰é¢åŠ ä¸Šåºå·
                // <span>${sentence.id}</span>
                // const displayId = `${prefix}${(index + 1).toString().padStart(2, '0')}.`;
                const displayId = `${(index + 1).toString().padStart(2, '0')}. `;
                
                item.innerHTML = `
                    <div class="sentence-text">${displayId}${sentence.text}</div>
                    <div class="sentence-meta">
                        <span></span>
                        <span class="status-badge ${statusClass}">
                            ${statusText}
                        </span>
                    </div>
                `;
                
                item.onclick = () => selectSentence(sentence);
                elements.sentencesContainer.appendChild(item);
            });
            
            updateDateInfo();
            console.log('å¥å­åˆ—è¡¨æ¸²æŸ“å®Œæˆ');
        }

        // ä¿®å¤åçš„ä¸‹è½½å‡½æ•°ï¼Œåªä½¿ç”¨Gitee
        async function downloadAudioFromGitee(sentenceId) {
            console.log('ä»Giteeä¸‹è½½éŸ³é¢‘:', sentenceId);
            
            // æ”¯æŒçš„éŸ³é¢‘æ ¼å¼åˆ—è¡¨
            const supportedFormats = ['webm', 'mp4', 'wav', 'ogg'];
            const fileNameBase = `${AppState.selectedDate}_${sentenceId}`;
            
            // æŒ‰é¡ºåºå°è¯•ä¸‹è½½å„ç§æ ¼å¼
            for (const format of supportedFormats) {
                const fileName = `${fileNameBase}.${format}`;
                const filePath = `${GITEE_CONFIG.RECORDINGS_DIR}/${AppState.selectedDate}/${fileName}`;
                
                console.log(`å°è¯•ä¸‹è½½æ ¼å¼: ${format}`);
                
                try {
                    const apiUrl = `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`;
                    
                    console.log('å°è¯•ä¸‹è½½:', apiUrl);
                    
                    const response = await fetch(apiUrl, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-store',
                        headers: {
                            'Accept': 'application/json'
                        },
                        signal: AbortSignal.timeout(5000)
                    });
                    
                    if (!response.ok) {
                        console.log(`æ ¼å¼ ${format} ä¸å­˜åœ¨ï¼ŒçŠ¶æ€ç : ${response.status}`);
                        continue; // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ ¼å¼
                    }
                    
                    const fileData = await response.json();
                    
                    // Giteeè¿”å›çš„æ•°æ®ç»“æ„
                    if (fileData.content && fileData.encoding === 'base64') {
                        // è§£ç base64
                        const binaryString = atob(fileData.content);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // æ ¹æ®æ‰©å±•åç¡®å®šMIMEç±»å‹
                        let mimeType;
                        switch(format) {
                            case 'wav': mimeType = 'audio/wav'; break;
                            case 'mp4': mimeType = 'audio/mp4'; break;
                            case 'ogg': mimeType = 'audio/ogg'; break;
                            case 'webm': 
                            default: mimeType = 'audio/webm'; break;
                        }
                        
                        const audioBlob = new Blob([bytes], { type: mimeType });
                        console.log(`âœ… ä»Giteeä¸‹è½½æˆåŠŸï¼Œæ ¼å¼: ${format}, å¤§å°: ${audioBlob.size} bytes`);
                        
                        return audioBlob;
                    }
                    
                } catch (error) {
                    console.log(`ä¸‹è½½æ ¼å¼ ${format} å¤±è´¥:`, error.message);
                    continue; // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ ¼å¼
                }
            }
            
            console.warn('âŒ æ— æ³•ä»Giteeä¸‹è½½éŸ³é¢‘ï¼šæ‰€æœ‰æ ¼å¼éƒ½å°è¯•å¤±è´¥');
            return null;
        }

        // éŸ³é¢‘ç¼“å­˜å‡½æ•°
        function cacheAudioToLocal(sentenceId, audioBlob) {
            try {
                const audioKey = `audio_${AppState.selectedDate}_${sentenceId}`;
                
                // æ£€æŸ¥Blobæ˜¯å¦æœ‰æ•ˆ
                if (!audioBlob || audioBlob.size === 0) {
                    console.warn('éŸ³é¢‘Blobæ— æ•ˆï¼Œè·³è¿‡ç¼“å­˜');
                    return;
                }
                
                // ç¡®ä¿æœ‰æ­£ç¡®çš„MIMEç±»å‹
                let mimeType = audioBlob.type;
                if (!mimeType || mimeType === '') {
                    mimeType = 'audio/webm'; // é»˜è®¤ç±»å‹
                    console.warn('éŸ³é¢‘ç¼ºå°‘MIMEç±»å‹ï¼Œä½¿ç”¨é»˜è®¤:', mimeType);
                }
                
                const reader = new FileReader();
                
                reader.onload = () => {
                    const result = reader.result;
                    if (typeof result === 'string' && result.startsWith('data:')) {
                        localStorage.setItem(audioKey, result);
                        console.log('éŸ³é¢‘å·²ç¼“å­˜åˆ°æœ¬åœ°å­˜å‚¨:', audioKey, 'å¤§å°:', result.length);
                    } else {
                        console.warn('éŸ³é¢‘ç¼“å­˜ç»“æœæ ¼å¼ä¸æ­£ç¡®');
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('éŸ³é¢‘ç¼“å­˜å¤±è´¥:', error);
                };
                
                reader.readAsDataURL(audioBlob);
            } catch (error) {
                console.warn('éŸ³é¢‘ç¼“å­˜è¿‡ç¨‹å¤±è´¥:', error);
            }
        }

        function selectSentence(sentence) {
            console.log('é€‰æ‹©å¥å­:', sentence?.id);
            
            if (!sentence) {
                console.error('å°è¯•é€‰æ‹©nullæˆ–undefinedçš„å¥å­');
                showStatus('è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªæœ‰æ•ˆçš„å¥å­', 'error');
                return;
            }
            
            // éªŒè¯å¥å­æ˜¯å¦å­˜åœ¨äºå½“å‰å¥å­åˆ—è¡¨ä¸­
            const sentenceExists = AppState.sentences.some(s => s.id === sentence.id);
            if (!sentenceExists) {
                console.error('å¥å­ä¸å­˜åœ¨äºå½“å‰åˆ—è¡¨ä¸­:', sentence.id);
                showStatus('é€‰æ‹©çš„å¥å­æ— æ•ˆï¼Œè¯·é‡æ–°é€‰æ‹©', 'error');
                return;
            }
            
            // å¦‚æœé€‰æ‹©çš„æ˜¯åŒä¸€ä¸ªå¥å­ï¼Œä¸è¦é‡å¤æ“ä½œ
            if (AppState.currentSentence && AppState.currentSentence.id === sentence.id) {
                console.log('é‡å¤é€‰æ‹©åŒä¸€ä¸ªå¥å­ï¼Œè·³è¿‡');
                return;
            }
            
            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            if (AppState.isPlaying) stopPlayback();
            if (AppState.timerInterval) clearInterval(AppState.timerInterval);
            if (AppState.playbackTimerInterval) clearInterval(AppState.playbackTimerInterval);
            
            AppState.recordingTime = 0;
            AppState.playbackTime = 0;
            AppState.audioCurrentTime = 0;
            AppState.audioDuration = 0;
            AppState.currentSentence = sentence;
            AppState.audioBlob = null;
            
            // æ›´æ–°UIæ˜¾ç¤º
            const idx = AppState.sentences.findIndex(s => s.id === sentence.id);
            if (idx >= 0) {
                elements.currentSentenceId.textContent = (idx + 1).toString().padStart(2, '0');
            } else {
                elements.currentSentenceId.textContent = '';
            }
            elements.currentSentenceText.textContent = sentence.text;
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateButtonStatesForSelectedSentence(sentence);
            
            // å‡†å¤‡éŸ³é¢‘
            console.log('å‡†å¤‡æ–°å¥å­çš„éŸ³é¢‘...');
            
            if (sentence.hasUploaded) {
                console.log('é€‰æ‹©çš„æ˜¯å·²ä¸Šä¼ çš„å¥å­ï¼Œä»æœåŠ¡å™¨ä¸‹è½½');
                autoPreparePlayback(sentence.id);
            } else {
                console.log('é€‰æ‹©çš„æ˜¯æœªä¸Šä¼ çš„å¥å­ï¼Œæ£€æŸ¥æœ¬åœ°å½•éŸ³');
                checkExistingRecording(sentence.id, false);
            }
            
            // æ›´æ–°åˆ—è¡¨æ¿€æ´»çŠ¶æ€
            setTimeout(() => {
                updateActiveSentenceInList(sentence.id);
            }, 50);
        }

        // æ·»åŠ æŒ‰é’®çŠ¶æ€æ›´æ–°å‡½æ•°
        function updateButtonStatesForSelectedSentence(sentence) {
            console.log('æ›´æ–°æŒ‰é’®çŠ¶æ€ï¼Œå¥å­:', sentence?.id);
            
            if (!sentence) {
                console.error('updateButtonStatesForSelectedSentence: å¥å­ä¸ºnull');
                disableAllFeatureButtons();
                return;
            }
            
            // å½•éŸ³æŒ‰é’®å§‹ç»ˆå¯ç”¨ï¼ˆå¼€å§‹æ–°çš„å½•éŸ³ï¼‰
            elements.recordBtn.disabled = false;
            elements.recordBtn.innerHTML = '<span>ğŸ¤ å¼€å§‹å½•éŸ³</span>';
            
            // åœæ­¢å½•éŸ³æŒ‰é’®ç¦ç”¨ï¼ˆå°šæœªå¼€å§‹å½•éŸ³ï¼‰
            elements.stopBtn.disabled = true;
            elements.stopBtn.innerHTML = '<span>â¹ï¸ åœæ­¢å½•éŸ³</span>';
            
            // æ’­æ”¾å’Œä¸Šä¼ æŒ‰é’®åˆå§‹çŠ¶æ€ä¸ºç¦ç”¨
            elements.playBtn.disabled = true;
            elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
            elements.playBtn.classList.remove('playing');
            
            elements.uploadBtn.disabled = true;
            
            // æ ¹æ®å¥å­çŠ¶æ€è®¾ç½®ä¸Šä¼ æŒ‰é’®æ–‡æœ¬
            if (sentence.hasUploaded) {
                elements.uploadBtn.innerHTML = '<span>ğŸ“¤ é‡æ–°ä¸Šä¼ </span>';
            } else {
                elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>';
            }
        }

        // æ›´æ–°åˆ—è¡¨æ¿€æ´»çŠ¶æ€
        function updateActiveSentenceInList(sentenceId) {
            const items = document.querySelectorAll('.sentence-item');
            items.forEach(item => {
                const idElement = item.querySelector('.sentence-meta span:first-child');
                if (idElement && !item.dataset.sentenceId) {
                    item.dataset.sentenceId = idElement.textContent.trim();
                }
                
                if (item.dataset.sentenceId === sentenceId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        async function autoPreparePlayback(sentenceId) {
            console.log('è‡ªåŠ¨å‡†å¤‡æ’­æ”¾å·²ä¸Šä¼ çš„å¥å­:', sentenceId);
            
            try {
                // ä»æœåŠ¡å™¨ä¸‹è½½éŸ³é¢‘ï¼ˆè‡ªåŠ¨å°è¯•å¤šç§æ ¼å¼ï¼‰
                const audioBlob = await downloadAudioFromGitee(sentenceId);
                
                if (audioBlob) {
                    console.log('ä¸‹è½½æˆåŠŸï¼Œå‡†å¤‡æ’­æ”¾æµ‹è¯•');
                    
                    // æµ‹è¯•éŸ³é¢‘æ˜¯å¦å¯ä»¥æ’­æ”¾
                    const canPlay = await testPlaybackSimple(audioBlob);
                    
                    if (canPlay) {
                        console.log('éŸ³é¢‘æµ‹è¯•é€šè¿‡ï¼Œå¯ä»¥æ’­æ”¾');
                        AppState.audioBlob = audioBlob;
                        
                        // ç¼“å­˜åˆ°æœ¬åœ°
                        cacheAudioToLocal(sentenceId, audioBlob);
                        
                        // æ›´æ–°UI
                        elements.playBtn.disabled = false;
                        elements.uploadBtn.disabled = false;
                        elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                        
                        // è‡ªåŠ¨æ’­æ”¾
                        setTimeout(() => {
                            playRecording();
                        }, 300);
                    } else {
                        console.log('éŸ³é¢‘æµ‹è¯•å¤±è´¥ï¼Œå°è¯•ä¿®å¤');
                        const fixedBlob = await fixAudioFormat(audioBlob);
                        if (fixedBlob) {
                            AppState.audioBlob = fixedBlob;
                            cacheAudioToLocal(sentenceId, fixedBlob);
                            elements.playBtn.disabled = false;
                            elements.uploadBtn.disabled = false;
                            
                            setTimeout(() => {
                                playRecording();
                            }, 300);
                        }
                    }
                } else {
                    console.log('æ— æ³•ä»æœåŠ¡å™¨ä¸‹è½½ï¼Œæ£€æŸ¥æœ¬åœ°æ˜¯å¦æœ‰æ—§ç‰ˆæœ¬');
                    checkExistingRecording(sentenceId, true);
                }
            } catch (error) {
                console.error('å‡†å¤‡æ’­æ”¾å¤±è´¥:', error);
                showStatus('ä»æœåŠ¡å™¨ä¸‹è½½å¤±è´¥ï¼Œå°è¯•æœ¬åœ°æ’­æ”¾', 'error');
                checkExistingRecording(sentenceId);
            }
        }

        // è·å–æœåŠ¡å™¨ä¸Šæ–‡ä»¶çš„å®é™…æ ¼å¼
        async function getServerFileFormat(sentenceId) {
            const supportedFormats = ['webm', 'mp4', 'wav', 'ogg'];
            const fileNameBase = `${AppState.selectedDate}_${sentenceId}`;
            
            for (const format of supportedFormats) {
                const fileName = `${fileNameBase}.${format}`;
                const filePath = `${GITEE_CONFIG.RECORDINGS_DIR}/${AppState.selectedDate}/${fileName}`;
                
                try {
                    const response = await fetch(
                        `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`,
                        {
                            method: 'HEAD',
                            mode: 'cors'
                        }
                    );
                    
                    if (response.ok) {
                        console.log(`æ–‡ä»¶æ ¼å¼æ£€æµ‹æˆåŠŸ: ${format}`);
                        return format;
                    }
                } catch (error) {
                    continue;
                }
            }
            
            return null;
        }

        // æ·»åŠ ç®€å•çš„æ’­æ”¾æµ‹è¯•å‡½æ•°
        async function testPlaybackSimple(audioBlob) {
            return new Promise((resolve) => {
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();
                
                audio.oncanplay = () => {
                    console.log('éŸ³é¢‘æµ‹è¯•ï¼šå¯ä»¥æ’­æ”¾');
                    URL.revokeObjectURL(audioUrl);
                    resolve(true);
                };
                
                audio.onerror = () => {
                    console.log('éŸ³é¢‘æµ‹è¯•ï¼šæ’­æ”¾å¤±è´¥');
                    URL.revokeObjectURL(audioUrl);
                    resolve(false);
                };
                
                // è®¾ç½®è¶…æ—¶
                setTimeout(() => {
                    console.log('éŸ³é¢‘æµ‹è¯•ï¼šè¶…æ—¶');
                    URL.revokeObjectURL(audioUrl);
                    resolve(false);
                }, 3000);
                
                audio.src = audioUrl;
                audio.load();
            });
        }

        // æ·»åŠ éŸ³é¢‘æ ¼å¼ä¿®å¤å‡½æ•°
        async function fixAudioFormat(audioBlob) {
            try {
                console.log('å°è¯•ä¿®å¤éŸ³é¢‘æ ¼å¼');
                
                // åˆ›å»ºç®€å•çš„WAVæ ¼å¼
                const reader = new FileReader();
                
                return new Promise((resolve) => {
                    reader.onload = function(e) {
                        const arrayBuffer = e.target.result;
                        
                        // åˆ›å»ºä¸€ä¸ªç®€å•çš„WAVæ–‡ä»¶
                        const sampleRate = 44100;
                        const numChannels = 1;
                        const bitDepth = 16;
                        
                        // åˆ›å»ºç©ºçš„WAVæ•°æ®ï¼ˆé™éŸ³ï¼‰
                        const duration = 2; // 2ç§’é™éŸ³
                        const numSamples = sampleRate * duration;
                        const dataSize = numSamples * numChannels * (bitDepth / 8);
                        const bufferSize = 44 + dataSize;
                        
                        const wavBuffer = new ArrayBuffer(bufferSize);
                        const view = new DataView(wavBuffer);
                        
                        // WAVå¤´éƒ¨
                        writeString(view, 0, 'RIFF');
                        view.setUint32(4, 36 + dataSize, true);
                        writeString(view, 8, 'WAVE');
                        writeString(view, 12, 'fmt ');
                        view.setUint32(16, 16, true);
                        view.setUint16(20, 1, true); // PCMæ ¼å¼
                        view.setUint16(22, numChannels, true);
                        view.setUint32(24, sampleRate, true);
                        view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
                        view.setUint16(32, numChannels * (bitDepth / 8), true);
                        view.setUint16(34, bitDepth, true);
                        writeString(view, 36, 'data');
                        view.setUint32(40, dataSize, true);
                        
                        // å¡«å……é™éŸ³æ•°æ®ï¼ˆ0å€¼ï¼‰
                        let offset = 44;
                        for (let i = 0; i < numSamples; i++) {
                            view.setInt16(offset, 0, true);
                            offset += 2;
                        }
                        
                        const fixedBlob = new Blob([wavBuffer], { type: 'audio/wav' });
                        console.log('ç”Ÿæˆä¿®å¤åçš„WAVæ–‡ä»¶ï¼Œå¤§å°:', fixedBlob.size);
                        resolve(fixedBlob);
                    };
                    
                    reader.onerror = () => {
                        console.log('ä¿®å¤å¤±è´¥ï¼Œè¿”å›null');
                        resolve(null);
                    };
                    
                    reader.readAsArrayBuffer(audioBlob);
                });
            } catch (error) {
                console.error('éŸ³é¢‘ä¿®å¤å¤±è´¥:', error);
                return null;
            }
        }

        // ä¿®æ”¹blobToBase64å‡½æ•°ï¼Œç¡®ä¿æ­£ç¡®å¤„ç†
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // ç¡®ä¿è¿”å›çš„æ˜¯æ­£ç¡®çš„base64æ•°æ®URI
                    if (reader.result) {
                        resolve(reader.result);
                    } else {
                        reject(new Error('è¯»å–Blobå¤±è´¥'));
                    }
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function checkExistingRecording(sentenceId, autoPlay = false) {
            console.log('æ£€æŸ¥æœ¬åœ°å½•éŸ³:', sentenceId, 'autoPlay:', autoPlay);
            
            const sentence = AppState.sentences.find(s => s.id === sentenceId);
            
            if (!sentence) {
                console.error('æ‰¾ä¸åˆ°å¥å­:', sentenceId);
                return;
            }
            
            if (sentence.hasUploaded) {
                console.log('å¥å­å·²ä¸Šä¼ ï¼Œè·³è¿‡æœ¬åœ°æ£€æŸ¥');
                // å³ä½¿å·²ä¸Šä¼ ï¼Œæ’­æ”¾æŒ‰é’®ä¹Ÿè¦ç­‰ä¸‹è½½å®Œæˆåæ‰å¯ç”¨
                elements.playBtn.disabled = true;
                elements.uploadBtn.disabled = false;
                elements.uploadBtn.innerHTML = '<span>ğŸ“¤ é‡æ–°ä¸Šä¼ </span>';
                return;
            }
            
            const audioKey = `audio_${AppState.selectedDate}_${sentenceId}`;
            const audioData = localStorage.getItem(audioKey);
            
            if (audioData) {
                console.log('æ‰¾åˆ°æœ¬åœ°å½•éŸ³ï¼ˆæœªä¸Šä¼ ï¼‰:', audioKey);
                
                try {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„base64éŸ³é¢‘æ•°æ®
                    if (!audioData.startsWith('data:audio/')) {
                        console.error('æœ¬åœ°éŸ³é¢‘æ•°æ®æ ¼å¼ä¸æ­£ç¡®:', audioData.substring(0, 50));
                        // æ¸…ç†æ— æ•ˆæ•°æ®
                        localStorage.removeItem(audioKey);
                        return;
                    }
                    
                    // åˆ›å»ºBlobå¯¹è±¡
                    AppState.audioBlob = dataURItoBlob(audioData);
                    
                    if (AppState.audioBlob && AppState.audioBlob.size > 0) {
                        console.log('æœ¬åœ°éŸ³é¢‘åŠ è½½æˆåŠŸï¼Œå¤§å°:', AppState.audioBlob.size, 'bytes');
                        
                        // å¯ç”¨æ’­æ”¾å’Œä¸Šä¼ æŒ‰é’®
                        elements.playBtn.disabled = false;
                        elements.uploadBtn.disabled = false;
                        elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>';
                        
                        if (autoPlay && !AppState.isRecording) {
                            setTimeout(() => {
                                playRecording();
                            }, 300);
                        }
                    } else {
                        console.error('éŸ³é¢‘Blobåˆ›å»ºå¤±è´¥æˆ–å¤§å°ä¸º0');
                        // ä¿æŒæŒ‰é’®ç¦ç”¨çŠ¶æ€
                        elements.playBtn.disabled = true;
                        elements.uploadBtn.disabled = true;
                    }
                } catch (error) {
                    console.error('åŠ è½½æœ¬åœ°å½•éŸ³å¤±è´¥:', error);
                    // æ¸…é™¤æŸåçš„æ•°æ®
                    localStorage.removeItem(audioKey);
                    elements.playBtn.disabled = true;
                    elements.uploadBtn.disabled = true;
                }
            } else {
                console.log('æ²¡æœ‰æ‰¾åˆ°æœ¬åœ°å½•éŸ³');
                // æ²¡æœ‰å½•éŸ³ï¼Œç¦ç”¨æ’­æ”¾æŒ‰é’®
                elements.playBtn.disabled = true;
                
                // å¦‚æœæœ‰å½“å‰å½•éŸ³ï¼Œå¯ç”¨ä¸Šä¼ æŒ‰é’®ï¼Œå¦åˆ™ç¦ç”¨
                if (AppState.audioBlob) {
                    elements.uploadBtn.disabled = false;
                } else {
                    elements.uploadBtn.disabled = true;
                }
            }
        }

        // æ·»åŠ dataURIè½¬Blobçš„è¾…åŠ©å‡½æ•°
        function dataURItoBlob(dataURI) {
            try {
                // åˆ†ç¦»MIMEç±»å‹å’Œbase64æ•°æ®
                const split = dataURI.split(',');
                const mime = split[0].match(/:(.*?);/)[1];
                const bstr = atob(split[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                
                while(n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                
                return new Blob([u8arr], { type: mime });
            } catch (error) {
                console.error('è½¬æ¢DataURIåˆ°Blobå¤±è´¥:', error);
                throw error;
            }
        }


        // ==================== å½•éŸ³åŠŸèƒ½ ====================
        async function startRecording() {
            try {
                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çš„å¥å­
                if (!AppState.currentSentence) {
                    showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¥å­ï¼', 'error');
                    return;
                }
                
                console.log('å¼€å§‹å½•éŸ³ï¼Œå¥å­:', AppState.currentSentence.id);
                
                // é‡ç½®ä¹‹å‰çš„çŠ¶æ€
                resetRecordingState();
                
                // åœæ­¢æ­£åœ¨æ’­æ”¾çš„å½•éŸ³
                if (AppState.isPlaying) {
                    console.log('æ£€æµ‹åˆ°æ­£åœ¨æ’­æ”¾å½•éŸ³ï¼Œå…ˆåœæ­¢æ’­æ”¾');
                    stopPlayback();
                }
                
                // è‹¹æœè®¾å¤‡ç‰¹æ®Šé…ç½®
                const audioConstraints = {
                    echoCancellation: true,
                    noiseSuppression: true,
                    channelCount: 1,
                    autoGainControl: true
                };
                
                // æ ¹æ®è®¾å¤‡è°ƒæ•´é‡‡æ ·ç‡
                if (navigator.userAgent.match(/iPad|iPhone|iPod/i)) {
                    audioConstraints.sampleRate = 48000;
                    console.log('iOSè®¾å¤‡ï¼Œè®¾ç½®é‡‡æ ·ç‡48000Hz');
                } else {
                    audioConstraints.sampleRate = 44100;
                }
                
                // è¯·æ±‚éº¦å…‹é£æƒé™
                console.log('è¯·æ±‚éº¦å…‹é£æƒé™...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: audioConstraints
                });
                
                console.log('éº¦å…‹é£æƒé™å·²è·å¾—ï¼Œåˆ›å»ºå½•éŸ³å™¨...');
                
                // é€‰æ‹©æœ€é€‚åˆçš„MIMEç±»å‹
                let mimeType = AppState.audioConfig.recordingMimeType;
                
                // éªŒè¯æ ¼å¼æ˜¯å¦æ”¯æŒ
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    console.warn(`é¦–é€‰æ ¼å¼ ${mimeType} ä¸æ”¯æŒï¼Œå°è¯•å…¶ä»–æ ¼å¼`);
                    
                    // å°è¯•å…¶ä»–æ ¼å¼
                    const formats = [
                        'audio/webm;codecs=opus',
                        'audio/webm',
                        'audio/mp4;codecs=mp4a.40.2',
                        'audio/wav',
                        'audio/ogg;codecs=opus'
                    ];
                    
                    for (const format of formats) {
                        if (MediaRecorder.isTypeSupported(format)) {
                            mimeType = format;
                            console.log(`ä½¿ç”¨å¤‡ç”¨æ ¼å¼: ${format}`);
                            break;
                        }
                    }
                }
                
                // åˆ›å»ºå½•éŸ³å™¨
                console.log(`ä½¿ç”¨å½•éŸ³æ ¼å¼: ${mimeType}`);
                AppState.recorder = new MediaRecorder(stream, { 
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000 // 128kbpsï¼Œä¿è¯è´¨é‡
                });
                
                // é‡ç½®æ•°æ®å—
                AppState.audioChunks = [];
                
                // æ”¶é›†éŸ³é¢‘æ•°æ®
                AppState.recorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        AppState.audioChunks.push(event.data);
                        console.log('æ”¶åˆ°éŸ³é¢‘æ•°æ®å—:', event.data.size, 'bytes');
                    } else {
                        console.warn('æ”¶åˆ°ç©ºçš„æ•°æ®å—');
                    }
                };
                
                // å½•éŸ³åœæ­¢æ—¶çš„å¤„ç†
                AppState.recorder.onstop = handleRecordingStop;
                
                // å½•éŸ³é”™è¯¯å¤„ç†
                AppState.recorder.onerror = (event) => {
                    console.error('å½•éŸ³å™¨å‘ç”Ÿé”™è¯¯:', event.error);
                    showStatus('å½•éŸ³è®¾å¤‡é”™è¯¯ï¼Œè¯·é‡è¯•', 'error');
                    resetRecordingState();
                };
                
                // å¼€å§‹å½•éŸ³ï¼ˆå¢åŠ æ—¶é—´é—´éš”ï¼Œå‡å°‘æ•°æ®å—æ•°é‡ï¼‰
                AppState.recorder.start(500); // æ”¹ä¸º500msï¼Œå‡å°‘æ•°æ®å—æ•°é‡
                
                AppState.isRecording = true;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.recordBtn.disabled = true;
                elements.stopBtn.disabled = false;
                elements.uploadBtn.disabled = true;
                elements.playBtn.disabled = true;
                
                // å¼€å§‹è®¡æ—¶
                startTimer();
                
                showStatus('æ­£åœ¨å½•éŸ³...', 'info');
                
            } catch (error) {
                console.error('å½•éŸ³é”™è¯¯:', error);
                resetRecordingState();
                
                // é”™è¯¯å¤„ç†
                if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    showStatus('æœªæ‰¾åˆ°éº¦å…‹é£è®¾å¤‡', 'error');
                } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    showStatus('éº¦å…‹é£è®¿é—®è¢«æ‹’ç»ï¼Œè¯·æ£€æŸ¥ç³»ç»Ÿè®¾ç½®', 'error');
                } else if (error.name === 'NotSupportedError') {
                    showStatus('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½', 'error');
                } else {
                    showStatus('å½•éŸ³å¤±è´¥ï¼š' + error.message, 'error');
                }
            }
        }


        // ä¸“é—¨å¤„ç†å½•éŸ³åœæ­¢çš„å‡½æ•°
        function handleRecordingStop() {
            console.log('å½•éŸ³åœæ­¢å›è°ƒæ‰§è¡Œï¼Œæ•°æ®å—æ•°é‡:', AppState.audioChunks.length);
            
            // åœæ­¢å½•éŸ³è®¡æ—¶å™¨
            stopTimer();
            
            if (AppState.audioChunks.length > 0) {
                // åˆ›å»ºéŸ³é¢‘Blob
                AppState.audioBlob = new Blob(AppState.audioChunks, { 
                    type: AppState.recorder.mimeType || 'audio/webm'
                });
                
                console.log('éŸ³é¢‘Blobåˆ›å»ºæˆåŠŸï¼Œå¤§å°:', AppState.audioBlob.size, 'bytes');
                
                // ä¿å­˜åˆ°æœ¬åœ°å¹¶æ›´æ–°UI
                saveRecordingLocally();
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.recordBtn.disabled = false;
                elements.stopBtn.disabled = true;
                elements.playBtn.disabled = false;
                
                // åœæ­¢éŸ³è½¨
                if (AppState.recorder.stream) {
                    AppState.recorder.stream.getTracks().forEach(track => track.stop());
                }
                
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥è‡ªåŠ¨ä¸Šä¼ 
                const shouldAutoUpload = shouldAutoUploadAfterRecording(AppState.currentSentence);
                console.log('è‡ªåŠ¨ä¸Šä¼ åˆ¤æ–­:', shouldAutoUpload);
                
                if (shouldAutoUpload) {
                    console.log('ç¬¬ä¸€æ¬¡å½•åˆ¶ï¼Œè‡ªåŠ¨ä¸Šä¼ åˆ°æœåŠ¡å™¨');
                    // showStatus('æ­£åœ¨è‡ªåŠ¨ä¸Šä¼ åˆ°æœåŠ¡å™¨...', 'info');
                    
                    // å»¶è¿Ÿä¸€ç‚¹å¼€å§‹ä¸Šä¼ ï¼Œç¡®ä¿æœ¬åœ°ä¿å­˜å®Œæˆ
                    setTimeout(() => {
                        // è¿™é‡Œä¿®æ”¹ï¼šä¼ é€’å›è°ƒå‡½æ•°ï¼Œä¸Šä¼ æˆåŠŸåæ£€æŸ¥åº†ç¥æ¡ä»¶
                        uploadToGitee(true); // trueè¡¨ç¤ºæ˜¯è‡ªåŠ¨ä¸Šä¼ 
                    }, 800);
                } else {
                    console.log('å·²æœ‰å½•éŸ³æˆ–å·²ä¸Šä¼ è¿‡ï¼Œç­‰å¾…æ‰‹åŠ¨ä¸Šä¼ ');
                    elements.uploadBtn.disabled = false;
                    
                    if (AppState.currentSentence.hasUploaded) {
                        elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                        showStatus('å½•éŸ³å®Œæˆï¼å¦‚éœ€æ›´æ–°æœåŠ¡å™¨ç‰ˆæœ¬è¯·ç‚¹å‡»"é‡æ–°ä¸Šä¼ "', 'success');
                    } else {
                        elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨';
                        showStatus('å½•éŸ³å®Œæˆï¼è¯·ç‚¹å‡»"ä¸Šä¼ åˆ°æœåŠ¡å™¨"ä¿å­˜åˆ°äº‘ç«¯', 'success');
                    }
                }
            } else {
                console.warn('æ²¡æœ‰å½•éŸ³æ•°æ®');
                showStatus('å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                elements.recordBtn.disabled = false;
                elements.stopBtn.disabled = true;
            }
            
            AppState.isRecording = false;
        }

        function resetRecordingState() {
            console.log('é‡ç½®å½•éŸ³çŠ¶æ€');
            
            if (AppState.recorder && AppState.recorder.state !== 'inactive') {
                try {
                    AppState.recorder.stop();
                } catch (e) {
                    console.warn('åœæ­¢å½•éŸ³å™¨æ—¶å‡ºé”™:', e);
                }
            }
            
            if (AppState.recorder && AppState.recorder.stream) {
                AppState.recorder.stream.getTracks().forEach(track => {
                    try {
                        track.stop();
                    } catch (e) {
                        console.warn('åœæ­¢éŸ³è½¨æ—¶å‡ºé”™:', e);
                    }
                });
            }
            
            // æ¸…ç†éŸ³é¢‘æ•°æ®
            AppState.audioChunks = [];
            AppState.audioBlob = null;
            AppState.recorder = null;
            AppState.isRecording = false;
            
            // é‡ç½®è®¡æ—¶å™¨
            if (AppState.timerInterval) {
                clearInterval(AppState.timerInterval);
                AppState.timerInterval = null;
            }
            
            AppState.recordingTime = 0;
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
            
            // é‡ç½®æŒ‰é’®çŠ¶æ€
            elements.recordBtn.disabled = false;
            elements.stopBtn.disabled = true;
            
            if (AppState.currentSentence) {
                elements.playBtn.disabled = false;
                elements.uploadBtn.disabled = false;
            }
        }

        function stopRecording() {
            if (AppState.recorder && AppState.isRecording) {
                console.log('åœæ­¢å½•éŸ³...');

                // ç›´æ¥åœæ­¢å½•éŸ³å™¨ï¼ŒhandleRecordingStopä¼šå¤„ç†åç»­é€»è¾‘
                AppState.recorder.stop();
                
                
                console.log('å½•éŸ³å™¨å·²åœæ­¢ï¼Œç­‰å¾…å›è°ƒæ‰§è¡Œ');
            }
        }

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥è‡ªåŠ¨ä¸Šä¼ å½•éŸ³
        function shouldAutoUploadAfterRecording(sentence) {
            if (!sentence) return false;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„éŸ³é¢‘æ•°æ®
            if (!AppState.audioBlob || AppState.audioBlob.size === 0) {
                console.log('shouldAutoUploadAfterRecording: éŸ³é¢‘æ•°æ®ä¸ºç©º');
                return false;
            }
            
            // æ£€æŸ¥å½•éŸ³æ—¶é•¿ï¼ˆè‡³å°‘3ç§’ï¼Œé¿å…è¯¯å½•ï¼‰
            if (AppState.recordingTime < 3.0) {
                console.log(`å½•éŸ³æ—¶é•¿å¤ªçŸ­: ${AppState.recordingTime}ç§’`);
                return false;
            }
            
            // æ£€æŸ¥éŸ³é¢‘æ–‡ä»¶å¤§å°ï¼ˆè‡³å°‘10KBï¼‰
            if (AppState.audioBlob.size < 10240) {
                console.log(`éŸ³é¢‘æ–‡ä»¶å¤ªå°: ${AppState.audioBlob.size}å­—èŠ‚`);
                return false;
            }
            
            // æ£€æŸ¥æœ¬åœ°æ˜¯å¦æœ‰ä¹‹å‰çš„å½•éŸ³
            const audioKey = `audio_${AppState.selectedDate}_${sentence.id}`;
            const hasLocalRecording = localStorage.getItem(audioKey);
            
            // æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å·²ä¸Šä¼ 
            const hasUploaded = sentence.hasUploaded || false;
            
            console.log(`è‡ªåŠ¨ä¸Šä¼ åˆ¤æ–­:`);
            console.log(`  - å¥å­ID: ${sentence.id}`);
            console.log(`  - å½•éŸ³æ—¶é•¿: ${AppState.recordingTime}ç§’`);
            console.log(`  - éŸ³é¢‘å¤§å°: ${AppState.audioBlob.size}å­—èŠ‚`);
            console.log(`  - æœ¬åœ°å½•éŸ³å­˜åœ¨: ${!!hasLocalRecording}`);
            console.log(`  - å·²ä¸Šä¼ åˆ°æœåŠ¡å™¨: ${hasUploaded}`);
            
            // åªæœ‰æ»¡è¶³æ‰€æœ‰æ¡ä»¶æ‰è‡ªåŠ¨ä¸Šä¼ 
            const shouldAutoUpload = 
                !hasLocalRecording && 
                !hasUploaded && 
                AppState.recordingTime >= 3.0 &&
                AppState.audioBlob.size >= 10240;
            
            console.log(`  - æ˜¯å¦è‡ªåŠ¨ä¸Šä¼ : ${shouldAutoUpload}`);
            
            return shouldAutoUpload;
        }

        function saveRecordingLocally() {
            if (AppState.currentSentence && AppState.audioBlob) {
                try {
                    // ç¡®ä¿éŸ³é¢‘Blobæœ‰æ•ˆ
                    if (!AppState.audioBlob || AppState.audioBlob.size === 0) {
                        console.error('éŸ³é¢‘æ•°æ®ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
                        showStatus('å½•éŸ³æ•°æ®ä¸ºç©ºï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                        return;
                    }
                    
                    cacheAudioToLocal(AppState.currentSentence.id, AppState.audioBlob);
                    
                    // æ›´æ–°å¥å­çŠ¶æ€
                    AppState.currentSentence.recorded = true;
                    AppState.currentSentence.lastRecorded = new Date().toISOString();
                    
                    console.log(`å½•éŸ³å·²ä¿å­˜ï¼Œå¥å­ ${AppState.currentSentence.id} çŠ¶æ€: recorded=true, hasUploaded=${AppState.currentSentence.hasUploaded}`);
                    
                    // ä¿å­˜å¹¶æ›´æ–°æ˜¾ç¤º
                    saveSentencesForSelectedDate();
                    updateSentenceItemInUI(AppState.currentSentence);
                    updateStats();
                    
                } catch (error) {
                    console.error('ä¿å­˜å½•éŸ³æ—¶å‘ç”Ÿé”™è¯¯:', error);
                    showStatus('ä¿å­˜å½•éŸ³å¤±è´¥: ' + error.message, 'error');
                }
            } else {
                console.error('æ— æ³•ä¿å­˜å½•éŸ³ï¼šç¼ºå°‘å½“å‰å¥å­æˆ–éŸ³é¢‘æ•°æ®');
                showStatus('ä¿å­˜å½•éŸ³å¤±è´¥ï¼šç¼ºå°‘æ•°æ®', 'error');
            }
        }

        // æ·»åŠ è°ƒè¯•å‡½æ•°ï¼Œæ£€æŸ¥æœ¬åœ°å­˜å‚¨ä¸­çš„éŸ³é¢‘æ•°æ®
        function debugLocalStorage() {
            console.log('=== æœ¬åœ°å­˜å‚¨è°ƒè¯•ä¿¡æ¯ ===');
            const audioKeys = [];
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('audio_')) {
                    audioKeys.push(key);
                }
            }
            
            console.log('æ‰¾åˆ°éŸ³é¢‘é”®:', audioKeys);
            
            audioKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`é”®: ${key}`);
                console.log(`ç±»å‹: ${typeof value}`);
                console.log(`é•¿åº¦: ${value ? value.length : 0}`);
                console.log(`å‰100å­—ç¬¦: ${value ? value.substring(0, 100) : 'null'}`);
                console.log('---');
            });
        }

        function playRecording() {
            if (AppState.isPlaying) return;
    
            if (!AppState.currentSentence) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¥å­', 'error');
                return;
            }
            
            console.log('=== æ’­æ”¾å…¼å®¹æ€§å¤„ç† ===');
            console.log('å½“å‰è®¾å¤‡:', navigator.userAgent);
            
            let audioToPlay = AppState.audioBlob;
            
            // å¦‚æœæ²¡æœ‰blobï¼Œä»æœ¬åœ°å­˜å‚¨åŠ è½½
            if (!audioToPlay || audioToPlay.size === 0) {
                const audioKey = `audio_${AppState.selectedDate}_${AppState.currentSentence.id}`;
                const audioData = localStorage.getItem(audioKey);
                
                if (!audioData) {
                    showStatus('æ²¡æœ‰æ‰¾åˆ°å½•éŸ³æ–‡ä»¶', 'error');
                    return;
                }
                
                try {
                    audioToPlay = dataURItoBlob(audioData);
                    AppState.audioBlob = audioToPlay;
                } catch (error) {
                    console.error('åŠ è½½éŸ³é¢‘å¤±è´¥:', error);
                    showStatus('éŸ³é¢‘æ–‡ä»¶æŸåï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                    localStorage.removeItem(audioKey);
                    return;
                }
            }
            
            // è‹¹æœè®¾å¤‡ç‰¹æ®Šå¤„ç†
            const isAppleDevice = navigator.userAgent.match(/iPad|iPhone|iPod|Macintosh/i);
            
            if (isAppleDevice) {
                console.log('è‹¹æœè®¾å¤‡æ’­æ”¾ä¼˜åŒ–');
                
                // æ£€æŸ¥éŸ³é¢‘æ ¼å¼æ˜¯å¦é€‚åˆè‹¹æœè®¾å¤‡
                const audio = new Audio();
                const blobType = audioToPlay.type || 'audio/webm';
                
                if (blobType.includes('webm') && !audio.canPlayType('audio/webm;codecs=opus')) {
                    console.log('è‹¹æœè®¾å¤‡å¯èƒ½ä¸æ”¯æŒWebMï¼Œå°è¯•æ ¼å¼å¤„ç†');
                    
                    // å°è¯•é‡æ–°åŒ…è£…ä¸ºMP4æ ¼å¼ï¼ˆç®€åŒ–ç‰ˆï¼‰
                    try {
                        audioToPlay = repackageForApple(audioToPlay);
                    } catch (e) {
                        console.warn('æ ¼å¼é‡åŒ…è£…å¤±è´¥:', e);
                    }
                }
            }
            
            // åˆ›å»ºéŸ³é¢‘URL
            const audioUrl = URL.createObjectURL(audioToPlay);
            const audio = new Audio(audioUrl);
            
            console.log('æ’­æ”¾éŸ³é¢‘ä¿¡æ¯:', {
                urlType: audioUrl.substring(0, 50),
                blobType: audioToPlay.type,
                size: audioToPlay.size
            });
            
            // è‹¹æœè®¾å¤‡ï¼šé¢„åŠ è½½å’Œé™éŸ³æ’­æ”¾ä»¥è§¦å‘æƒé™
            if (isAppleDevice) {
                audio.preload = 'auto';
                audio.muted = true; // å…ˆé™éŸ³ï¼Œé¿å…è‡ªåŠ¨æ’­æ”¾é™åˆ¶
                
                // è®¾ç½®éŸ³é‡æ¸å˜é¿å…çˆ†éŸ³
                audio.volume = 0;
                setTimeout(() => {
                    if (AppState.isPlaying) {
                        audio.volume = 1.0;
                        audio.muted = false;
                    }
                }, 100);
            }
            
            // æ·»åŠ éŸ³é¢‘æ ¼å¼æ£€æŸ¥
            audio.preload = 'metadata';
            
            AppState.audioCurrentTime = 0;
            AppState.audioDuration = 0;
            AppState.isPlaying = true;
            AppState.currentAudio = audio;
            elements.playBtn.innerHTML = '<span>â¸ï¸ æ­£åœ¨æ’­æ”¾...</span>';
            elements.playBtn.classList.add('playing');
            elements.playbackIndicator.style.display = 'block';
            document.querySelector('.recording-area').classList.add('playing');
            
            // è®¾ç½®è¶…æ—¶ï¼Œé˜²æ­¢éŸ³é¢‘åŠ è½½æ—¶é—´è¿‡é•¿
            const loadTimeout = setTimeout(() => {
                console.log('éŸ³é¢‘åŠ è½½è¶…æ—¶');
                if (!AppState.audioDuration) {
                    stopPlayback();
                    showStatus('éŸ³é¢‘åŠ è½½è¶…æ—¶ï¼Œå¯èƒ½æ ¼å¼ä¸æ”¯æŒ', 'error');
                    URL.revokeObjectURL(audioUrl);
                }
            }, 5000);
            
            audio.onloadedmetadata = () => {
                clearTimeout(loadTimeout);
                AppState.audioDuration = audio.duration;
                console.log('éŸ³é¢‘æ—¶é•¿:', AppState.audioDuration, 'ç§’');
            };
            
            audio.oncanplaythrough = () => {
                clearTimeout(loadTimeout);
                console.log('éŸ³é¢‘å¯ä»¥æµç•…æ’­æ”¾');
            };
            
            audio.onplay = () => {
                clearTimeout(loadTimeout);
                startPlaybackTimer();
            };
            
            audio.ontimeupdate = () => {
                AppState.audioCurrentTime = audio.currentTime;
                updatePlaybackTimer();
            };
            
            audio.onended = () => {
                console.log('éŸ³é¢‘æ’­æ”¾ç»“æŸ');
                stopPlayback();
                URL.revokeObjectURL(audioUrl);
            };
            
            audio.onerror = (error) => {
                clearTimeout(loadTimeout);
                console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error);
                console.error('éŸ³é¢‘é”™è¯¯è¯¦æƒ…:', audio.error);
                
                let errorMsg = 'æ’­æ”¾å¤±è´¥';
                if (audio.error) {
                    switch(audio.error.code) {
                        case audio.error.MEDIA_ERR_ABORTED:
                            errorMsg = 'æ’­æ”¾è¢«ä¸­æ­¢';
                            break;
                        case audio.error.MEDIA_ERR_NETWORK:
                            errorMsg = 'ç½‘ç»œé”™è¯¯';
                            break;
                        case audio.error.MEDIA_ERR_DECODE:
                            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒ';
                            break;
                        case audio.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒ';
                            break;
                    }
                }
                
                stopPlayback();
                showStatus(errorMsg, 'error');
                URL.revokeObjectURL(audioUrl);
            };
            
            // å°è¯•æ’­æ”¾
            audio.play().catch(error => {
                clearTimeout(loadTimeout);
                console.error('æ’­æ”¾å¤±è´¥:', error);
                
                // å°è¯•ä¸åŒçš„æ–¹å¼æ’­æ”¾
                if (error.name === 'NotSupportedError' || error.name === 'TypeError') {
                    console.log('å°è¯•ç›´æ¥æ’­æ”¾base64æ•°æ®');
                    const audioKey = `audio_${AppState.selectedDate}_${AppState.currentSentence.id}`;
                    const audioData = localStorage.getItem(audioKey);
                    if (audioData) {
                        audio.src = audioData;
                        audio.play().catch(secondError => {
                            console.error('ç¬¬äºŒæ¬¡å°è¯•æ’­æ”¾å¤±è´¥:', secondError);
                            stopPlayback();
                            showStatus('éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                        });
                    } else {
                        stopPlayback();
                        showStatus('æ’­æ”¾å¤±è´¥ï¼š' + error.message, 'error');
                    }
                } else {
                    stopPlayback();
                    showStatus('æ’­æ”¾å¤±è´¥ï¼š' + error.message, 'error');
                }
                
                URL.revokeObjectURL(audioUrl);
            });
        }

        // è‹¹æœè®¾å¤‡éŸ³é¢‘é‡æ–°åŒ…è£…å‡½æ•°
        function repackageForApple(originalBlob) {
            return new Promise((resolve) => {
                // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„ç¤ºä¾‹ï¼Œå®é™…å¯èƒ½éœ€è¦æœåŠ¡å™¨ç«¯è½¬æ¢
                // è¿™é‡Œåªæ˜¯é‡æ–°åŒ…è£…Blobï¼Œä¸æ”¹å˜ç¼–ç 
                
                // å¯¹äºè‹¹æœè®¾å¤‡ï¼Œå°è¯•ä½¿ç”¨æ›´å…¼å®¹çš„MIMEç±»å‹
                let newType = 'audio/mp4';
                const audio = new Audio();
                
                if (audio.canPlayType('audio/wav')) {
                    newType = 'audio/wav';
                } else if (audio.canPlayType('audio/mp4')) {
                    newType = 'audio/mp4';
                } else if (audio.canPlayType('audio/webm')) {
                    newType = 'audio/webm';
                }
                
                console.log('ä¸ºè‹¹æœè®¾å¤‡é‡æ–°åŒ…è£…éŸ³é¢‘:', originalBlob.type, '->', newType);
                
                // åˆ›å»ºæ–°çš„Blobï¼Œå°è¯•ä¸åŒçš„ç±»å‹
                const newBlob = new Blob([originalBlob], { type: newType });
                resolve(newBlob);
            });
        }


        // ==================== æ’­æ”¾è®¡æ—¶å™¨å‡½æ•° ====================
        function startPlaybackTimer() {
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
            }
            
            AppState.playbackTime = 0;
            
            AppState.playbackTimerInterval = setInterval(() => {
                AppState.playbackTime += 0.1;
                updatePlaybackTimer();
            }, 100);
        }

        function updatePlaybackTimer() {
            let displayTime = AppState.audioCurrentTime || AppState.playbackTime;
            
            if (AppState.audioDuration && displayTime > AppState.audioDuration) {
                displayTime = AppState.audioDuration;
            }
            
            const minutes = Math.floor(displayTime / 60).toString().padStart(2, '0');
            const seconds = Math.floor(displayTime % 60).toString().padStart(2, '0');
            
            elements.timer.textContent = `${minutes}:${seconds}`;
            
            if (AppState.audioDuration) {
                const progressPercent = (displayTime / AppState.audioDuration) * 100;
                elements.progressFill.style.width = `${progressPercent}%`;
            }
        }

        // åœæ­¢æ’­æ”¾å‡½æ•°
        function stopPlayback() {
            if (AppState.isPlaying) {
                console.log('åœæ­¢æ’­æ”¾å½•éŸ³');
                
                AppState.isPlaying = false;
                
                if (AppState.currentAudio) {
                    AppState.currentAudio.pause();
                    AppState.currentAudio.currentTime = 0;
                    
                    if (AppState.currentAudio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(AppState.currentAudio.src);
                    }
                    
                    AppState.currentAudio = null;
                }
                
                if (AppState.playbackTimerInterval) {
                    clearInterval(AppState.playbackTimerInterval);
                    AppState.playbackTimerInterval = null;
                }
                
                elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
                elements.playBtn.classList.remove('playing');
                elements.playbackIndicator.style.display = 'none';
                document.querySelector('.recording-area').classList.remove('playing');
                
                AppState.playbackTime = 0;
                AppState.audioCurrentTime = 0;
                
                if (!AppState.isRecording && !AppState.currentSentence) {
                    elements.timer.textContent = '00:00';
                    elements.progressFill.style.width = '0%';
                }
            }
        }

        async function deleteAllSentenceFiles(sentenceId) {
            try {
                console.log(`å¼€å§‹åˆ é™¤å¥å­ ${sentenceId} çš„æ‰€æœ‰æ ¼å¼æ–‡ä»¶`);
                
                const supportedFormats = ['webm', 'mp4', 'wav', 'ogg', 'm4a'];
                const fileNameBase = `${AppState.selectedDate}_${sentenceId}`;
                let deletedFiles = 0;
                
                // éå†æ‰€æœ‰æ”¯æŒçš„æ ¼å¼
                for (const format of supportedFormats) {
                    const fileName = `${fileNameBase}.${format}`;
                    const filePath = `${GITEE_CONFIG.RECORDINGS_DIR}/${AppState.selectedDate}/${fileName}`;
                    
                    try {
                        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                        const sha = await getGiteeFileSHA(filePath);
                        
                        if (sha) {
                            console.log(`æ‰¾åˆ°æ–‡ä»¶ ${fileName}ï¼Œå¼€å§‹åˆ é™¤`);
                            
                            // åˆ é™¤æ–‡ä»¶
                            const response = await fetch(
                                `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`,
                                {
                                    method: 'DELETE',
                                    mode: 'cors',
                                    headers: {
                                        'Content-Type': 'application/json;charset=UTF-8'
                                    },
                                    body: JSON.stringify({
                                        access_token: GITEE_CONFIG.TOKEN,
                                        sha: sha,
                                        message: `æ¸…ç†æ—§æ–‡ä»¶: ${fileName}`,
                                        committer: {
                                            name: 'Audio Recording App',
                                            email: 'noreply@gitee.com'
                                        }
                                    })
                                }
                            );
                            
                            if (response.ok) {
                                const result = await response.json();
                                console.log(`âœ… åˆ é™¤æˆåŠŸ: ${fileName}`);
                                deletedFiles++;
                            } else {
                                console.log(`âŒ åˆ é™¤å¤±è´¥ ${fileName}:`, response.status);
                            }
                        } else {
                            console.log(`æ–‡ä»¶ä¸å­˜åœ¨: ${fileName}`);
                        }
                    } catch (error) {
                        console.log(`åˆ é™¤æ–‡ä»¶ ${fileName} æ—¶å‡ºé”™:`, error.message);
                        // ç»§ç»­åˆ é™¤å…¶ä»–æ–‡ä»¶
                    }
                }
                
                console.log(`åˆ é™¤å®Œæˆï¼Œå…±åˆ é™¤ ${deletedFiles} ä¸ªæ–‡ä»¶`);
                return deletedFiles;
                
            } catch (error) {
                console.error('åˆ é™¤æ–‡ä»¶è¿‡ç¨‹å‡ºé”™:', error);
                throw error;
            }
        }

        // ä¿®æ”¹åçš„ä¸Šä¼ å‡½æ•°ï¼šä¸Šä¼ å‰åˆ é™¤æ‰€æœ‰æ ¼å¼çš„æ–‡ä»¶
        async function uploadToGitee(isAutoUpload = false) {
            if (!AppState.audioBlob) {
                showStatus('è¯·å…ˆå½•åˆ¶éŸ³é¢‘ï¼', 'error');
                return;
            }
            
            if (!AppState.currentSentence) {
                showStatus('è¯·é€‰æ‹©ä¸€ä¸ªå¥å­ï¼', 'error');
                return;
            }
            
            if (!GITEE_CONFIG.REPOSITORY || !GITEE_CONFIG.TOKEN) {
                showStatus('Giteeé…ç½®ä¸æ­£ç¡®', 'error');
                return;
            }
            
            try {
                elements.uploadBtn.innerHTML = '<span>â³ ä¸Šä¼ ä¸­...</span>';
                elements.uploadBtn.disabled = true;
                
                // 1. ä¸Šä¼ å‰å…ˆåˆ é™¤è¯¥å¥å­æ‰€æœ‰æ ¼å¼çš„æ—§æ–‡ä»¶
                console.log('å¼€å§‹æ¸…ç†æ—§æ–‡ä»¶...');
                const deletedCount = await deleteAllSentenceFiles(AppState.currentSentence.id);
                console.log(`æ¸…ç†äº† ${deletedCount} ä¸ªæ—§æ–‡ä»¶`);
                
                // 2. æ ¹æ®éŸ³é¢‘Blobçš„å®é™…MIMEç±»å‹ç¡®å®šæ–‡ä»¶æ‰©å±•å
                const mimeType = AppState.audioBlob.type || 'audio/webm';
                let extension = 'webm'; // é»˜è®¤
                
                if (mimeType.includes('mp4') || mimeType.includes('m4a')) {
                    extension = 'mp4';
                } else if (mimeType.includes('wav')) {
                    extension = 'wav';
                } else if (mimeType.includes('ogg')) {
                    extension = 'ogg';
                } else if (mimeType.includes('webm')) {
                    extension = 'webm';
                }
                
                // 3. ç»Ÿä¸€ä½¿ç”¨è¿™ç§å‘½åæ ¼å¼ï¼šæ—¥æœŸ_å¥å­ID.æ‰©å±•å
                const fileName = `${AppState.selectedDate}_${AppState.currentSentence.id}.${extension}`;
                const filePath = `${GITEE_CONFIG.RECORDINGS_DIR}/${AppState.selectedDate}/${fileName}`;
                
                console.log('ä¸Šä¼ æ–‡ä»¶ä¿¡æ¯:', {
                    fileName: fileName,
                    mimeType: mimeType,
                    extension: extension,
                    size: AppState.audioBlob.size
                });
                
                // 4. è½¬æ¢ä¸ºbase64
                const base64Data = await blobToBase64(AppState.audioBlob);
                const pureBase64 = base64Data.split(',')[1];
                
                // 5. ç”±äºå·²ç»åˆ é™¤äº†æ—§æ–‡ä»¶ï¼Œè¿™é‡Œæ€»æ˜¯åˆ›å»ºæ–°æ–‡ä»¶
                const requestData = {
                    access_token: GITEE_CONFIG.TOKEN,
                    content: pureBase64,
                    message: `å½•éŸ³ä¸Šä¼ : ${AppState.currentSentence.id} - ${AppState.selectedDate} (æ ¼å¼: ${extension})`,
                    committer: {
                        name: 'Audio Recording App',
                        email: 'noreply@gitee.com'
                    }
                };
                
                console.log('å‘é€ä¸Šä¼ è¯·æ±‚...');
                const response = await fetch(
                    `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}`,
                    {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Content-Type': 'application/json;charset=UTF-8'
                        },
                        body: JSON.stringify(requestData)
                    }
                );
                
                console.log('ä¸Šä¼ å“åº”çŠ¶æ€:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('ä¸Šä¼ å¤±è´¥å“åº”:', errorText);
                    throw new Error(`Gitee APIè¿”å›é”™è¯¯: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('ä¸Šä¼ æˆåŠŸå“åº”:', result);
                
                if (result.commit && result.commit.sha) {
                    console.log('ä¸Šä¼ åˆ°GiteeæˆåŠŸ');
                    showStatus(`âœ… ä¸Šä¼ æˆåŠŸï¼`, 'success');
                    
                    // 6. æ ‡è®°ä¸ºå·²ä¸Šä¼ 
                    AppState.currentSentence.hasUploaded = true;
                    AppState.currentSentence.uploadedAt = new Date().toISOString();
                    
                    // 7. ç«‹å³ç¼“å­˜ä¸Šä¼ çŠ¶æ€ï¼ˆé‡è¦ï¼ï¼‰
                    StateCache.setUploadStatus(AppState.selectedDate, AppState.currentSentence.id, true);
                    
                    // 8. æ›´æ–°æŒ‰é’®çŠ¶æ€
                    elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                    elements.uploadBtn.disabled = false;
                    
                    // 9. ä¿å­˜çŠ¶æ€å¹¶æ›´æ–°UI
                    saveSentencesForSelectedDate();
                    updateSentenceItemInUI(AppState.currentSentence);
                    updateStats();
                    
                    // 10. æ£€æŸ¥æ˜¯å¦éœ€è¦åº†ç¥ï¼ˆåªåœ¨è‡ªåŠ¨ä¸Šä¼ åæ£€æŸ¥ï¼‰
                    if (isAutoUpload) {
                        checkAndCelebrateCompletion();
                    }
                    
                } else {
                    throw new Error('Giteeè¿”å›æ•°æ®æ ¼å¼é”™è¯¯');
                }
                
            } catch (error) {
                console.error('ä¸Šä¼ åˆ°Giteeé”™è¯¯:', error);
                showStatus(`âŒ ä¸Šä¼ å¤±è´¥ï¼š${error.message}`, 'error');
                
                // ä¸Šä¼ å¤±è´¥ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
                elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>';
                elements.uploadBtn.disabled = false;
            }
        }


        // æ£€æŸ¥å¹¶è§¦å‘åº†ç¥
        function checkAndCelebrateCompletion() {
            const total = AppState.sentences.length;
            const uploaded = AppState.sentences.filter(s => s.hasUploaded).length;
            
            console.log(`æ£€æŸ¥åº†ç¥æ¡ä»¶: ${uploaded}/${total} å·²ä¸Šä¼ `);
            
            // åªæœ‰å½“å…¨éƒ¨ä¸Šä¼ å®Œæˆæ—¶æ‰åº†ç¥
            if (total > 0 && uploaded === total) {
                console.log('ğŸ‰ æ­å–œï¼æ‰€æœ‰å¥å­å·²ä¸Šä¼ å®Œæˆï¼');
                
                // æ£€æŸ¥æ˜¯å¦å·²ç»åº†ç¥è¿‡ï¼ˆé¿å…é‡å¤ï¼‰
                const celebrationKey = `celebrated_${AppState.selectedDate}`;
                const alreadyCelebrated = localStorage.getItem(celebrationKey);
                
                if (!alreadyCelebrated) {
                    // æ ‡è®°ä¸ºå·²åº†ç¥
                    localStorage.setItem(celebrationKey, 'true');
                    
                    // å»¶è¿Ÿä¸€ç‚¹æ˜¾ç¤ºï¼Œè®©ç”¨æˆ·å…ˆçœ‹åˆ°ä¸Šä¼ æˆåŠŸçš„æ¶ˆæ¯
                    setTimeout(() => {
                        showCelebration();
                    }, 1000);
                } else {
                    console.log('ä»Šå¤©å·²ç»åº†ç¥è¿‡äº†ï¼Œä¸å†é‡å¤æ˜¾ç¤º');
                }
            }
        }

        // çƒŸèŠ±æ•ˆæœ
        let fireworksInterval = null;
        let fireworksParticles = [];

        function startFireworks() {
            console.log('å¼€å§‹çƒŸèŠ±æ•ˆæœ');
            
            // åˆ›å»ºçƒŸèŠ±å®¹å™¨
            const fireworksContainer = document.createElement('div');
            fireworksContainer.id = 'fireworksContainer';
            fireworksContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 9998;
            `;
            document.body.appendChild(fireworksContainer);
            
            // å¯åŠ¨çƒŸèŠ±å‘å°„
            fireworksInterval = setInterval(() => {
                launchFirework(fireworksContainer);
            }, 800);
            
            // è‡ªåŠ¨åœæ­¢çƒŸèŠ±ï¼ˆ10ç§’åï¼‰
            setTimeout(() => {
                stopFireworks();
            }, 10000);
        }

        function stopFireworks() {
            if (fireworksInterval) {
                clearInterval(fireworksInterval);
                fireworksInterval = null;
            }
            
            const container = document.getElementById('fireworksContainer');
            if (container) {
                container.remove();
            }
            
            // æ¸…ç†æ‰€æœ‰ç²’å­
            fireworksParticles.forEach(particle => {
                if (particle.element && particle.element.parentNode) {
                    particle.element.remove();
                }
            });
            fireworksParticles = [];
        }

        function launchFirework(container) {
            // éšæœºä½ç½®å‘å°„
            const startX = Math.random() * window.innerWidth;
            const startY = window.innerHeight;
            const targetX = startX + (Math.random() - 0.5) * 200;
            const targetY = startY * 0.3 + Math.random() * 100;
            
            // åˆ›å»ºçƒŸèŠ±æ‹–å°¾
            const trail = document.createElement('div');
            trail.style.cssText = `
                position: absolute;
                width: 4px;
                height: 4px;
                background: linear-gradient(to top, #FFD700, #FF4500);
                border-radius: 50%;
                left: ${startX}px;
                top: ${startY}px;
                box-shadow: 0 0 10px #FFD700;
                z-index: 9999;
            `;
            container.appendChild(trail);
            
            // çƒŸèŠ±å‘å°„åŠ¨ç”»
            let posY = startY;
            const trailAnimation = setInterval(() => {
                posY -= 8;
                const posX = startX + (targetX - startX) * (1 - (posY - targetY) / (startY - targetY));
                
                trail.style.top = posY + 'px';
                trail.style.left = posX + 'px';
                
                // åˆ°è¾¾ç›®æ ‡ä½ç½®çˆ†ç‚¸
                if (posY <= targetY) {
                    clearInterval(trailAnimation);
                    trail.remove();
                    createExplosion(posX, posY, container);
                }
            }, 16);
        }

        function createExplosion(x, y, container) {
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
            const particleCount = 80 + Math.random() * 40;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const particle = document.createElement('div');
                particle.style.cssText = `
                    position: absolute;
                    width: 6px;
                    height: 6px;
                    background: ${color};
                    border-radius: 50%;
                    left: ${x}px;
                    top: ${y}px;
                    box-shadow: 0 0 8px ${color};
                    z-index: 9999;
                `;
                container.appendChild(particle);
                
                const particleObj = {
                    element: particle,
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 100 + Math.random() * 50
                };
                
                fireworksParticles.push(particleObj);
            }
            
            // ç²’å­åŠ¨ç”»
            if (!fireworksInterval) {
                const particleAnimation = setInterval(() => {
                    fireworksParticles.forEach((particle, index) => {
                        if (particle.life <= 0) {
                            if (particle.element && particle.element.parentNode) {
                                particle.element.remove();
                            }
                            fireworksParticles.splice(index, 1);
                            return;
                        }
                        
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vy += 0.1; // é‡åŠ›
                        particle.life -= 1;
                        
                        // æ·¡å‡ºæ•ˆæœ
                        particle.element.style.opacity = particle.life / 100;
                        particle.element.style.width = (particle.life / 100) * 6 + 'px';
                        particle.element.style.height = (particle.life / 100) * 6 + 'px';
                        
                        particle.element.style.left = particle.x + 'px';
                        particle.element.style.top = particle.y + 'px';
                    });
                    
                    if (fireworksParticles.length === 0) {
                        clearInterval(particleAnimation);
                    }
                }, 16);
            }
        }

        // æ·»åŠ åº†ç¥æ•ˆæœ
        function showCelebration() {
            console.log('ğŸ‰ æ‰€æœ‰å¥å­å·²ä¸Šä¼ å®Œæˆï¼æ˜¾ç¤ºåº†ç¥æ•ˆæœ');
            
            // åœæ­¢ä»»ä½•æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
            if (AppState.isPlaying) stopPlayback();
            if (AppState.isRecording) stopRecording();
            
            // 1. æ˜¾ç¤ºä½ çœŸæ£’æç¤º
            const celebrationMessage = document.createElement('div');
            celebrationMessage.id = 'celebrationMessage';
            celebrationMessage.innerHTML = `
                <div class="celebration-content">
                    <div class="stars">â­â­â­â­â­</div>
                    <h1 class="celebration-title">ğŸ‰ æ­å–œå®Œæˆï¼ ğŸ‰</h1>
                    <p class="celebration-subtitle">ä½ å¤ªå‰å®³äº†ï¼å®Œæˆäº†ä»Šå¤©æ‰€æœ‰çš„æœ—è¯»ä»»åŠ¡ï¼</p>
                    <div class="celebration-info">
                        <p>âœ… å·²å®Œæˆ ${AppState.sentences.length} ä¸ªå¥å­çš„å½•éŸ³å’Œä¸Šä¼ </p>
                        <p>ğŸ“… æ—¥æœŸï¼š${AppState.selectedDate}</p>
                        <p>â° å®Œæˆæ—¶é—´ï¼š${new Date().toLocaleTimeString()}</p>
                        <p>ğŸ† ç»§ç»­ä¿æŒè¿™ä¸ªå¥½ä¹ æƒ¯ï¼</p>
                    </div>
                    <button class="btn-celebration-close" onclick="closeCelebration()">å¤ªæ£’äº†ï¼ç»§ç»­åŠªåŠ›</button>
                </div>
            `;
            document.body.appendChild(celebrationMessage);
            
            // 2. å¼€å§‹çƒŸèŠ±æ•ˆæœ
            startFireworks();
            
            // 3. æ’­æ”¾åº†ç¥éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
            playCelebrationSound();
        }

        // å…³é—­åº†ç¥æ•ˆæœ
        function closeCelebration() {
            const message = document.getElementById('celebrationMessage');
            if (message) {
                message.remove();
            }
            
            // åœæ­¢çƒŸèŠ±
            stopFireworks();
        }

        // æ’­æ”¾åº†ç¥éŸ³æ•ˆï¼ˆå¯é€‰ï¼‰
        function playCelebrationSound() {
            try {
                // åˆ›å»ºä¸€ä¸ªç®€å•çš„åº†ç¥éŸ³æ•ˆ
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.2); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.4); // G5
                
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 1);
                
                console.log('æ’­æ”¾åº†ç¥éŸ³æ•ˆ');
            } catch (error) {
                console.log('æ— æ³•æ’­æ”¾éŸ³æ•ˆ:', error);
            }
        }


        // è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰¹å®šæ ¼å¼æ–‡ä»¶çš„SHA
        async function getGiteeFileSHA(filePath) {
            try {
                const response = await fetch(
                    `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`,
                    {
                        headers: {
                            'Accept': 'application/json'
                        }
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºæ•°ç»„ï¼ˆè¡¨ç¤ºç›®å½•å­˜åœ¨ä½†æ–‡ä»¶ä¸å­˜åœ¨ï¼‰
                    if (Array.isArray(data) && data.length === 0) {
                        console.log(`ç›®å½•å­˜åœ¨ä½†æ–‡ä»¶ä¸å­˜åœ¨: ${filePath}`);
                        return null;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰shaå­—æ®µ
                    if (data && data.sha) {
                        return data.sha;
                    }
                    
                    console.log(`æ–‡ä»¶æ²¡æœ‰shaå­—æ®µ: ${filePath}`);
                    return null;
                } else if (response.status === 404) {
                    // æ–‡ä»¶ä¸å­˜åœ¨
                    console.log(`æ–‡ä»¶ä¸å­˜åœ¨ (404): ${filePath}`);
                    return null;
                } else {
                    console.log(`è·å–æ–‡ä»¶SHAå¤±è´¥ (${response.status}): ${filePath}`);
                    return null;
                }
            } catch (error) {
                console.log(`è·å–æ–‡ä»¶SHAæ—¶å‡ºé”™ ${filePath}:`, error.message);
                return null;
            }
        }

        async function convertToSimpleWav(originalBlob) {
            return new Promise((resolve, reject) => {
                console.log('å¼€å§‹è½¬æ¢ä¸ºç®€å•WAVæ ¼å¼ï¼ŒåŸå§‹ç±»å‹:', originalBlob.type);
                
                // ç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®åˆ›å»ºWAVå¤´éƒ¨
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const originalData = new Uint8Array(e.target.result);
                        
                        // åˆ›å»ºç®€å•çš„WAVå¤´éƒ¨
                        const dataSize = originalData.length;
                        const bufferSize = 44 + dataSize;
                        const arrayBuffer = new ArrayBuffer(bufferSize);
                        const view = new DataView(arrayBuffer);
                        
                        // WAVå¤´éƒ¨
                        writeString(view, 0, 'RIFF');
                        view.setUint32(4, 36 + dataSize, true);
                        writeString(view, 8, 'WAVE');
                        writeString(view, 12, 'fmt ');
                        view.setUint32(16, 16, true); // PCMæ ¼å¼
                        view.setUint16(20, 1, true); // éŸ³é¢‘æ ¼å¼ï¼šPCM
                        view.setUint16(22, 1, true); // å£°é“æ•°ï¼šå•å£°é“
                        view.setUint32(24, 44100, true); // é‡‡æ ·ç‡
                        view.setUint32(28, 88200, true); // å­—èŠ‚ç‡ = é‡‡æ ·ç‡ * å£°é“æ•° * ä½æ·±åº¦/8
                        view.setUint16(32, 2, true); // å—å¯¹é½ = å£°é“æ•° * ä½æ·±åº¦/8
                        view.setUint16(34, 16, true); // ä½æ·±åº¦
                        writeString(view, 36, 'data');
                        view.setUint32(40, dataSize, true);
                        
                        // å¤åˆ¶åŸå§‹æ•°æ®
                        for (let i = 0; i < dataSize; i++) {
                            view.setUint8(44 + i, originalData[i]);
                        }
                        
                        const wavBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
                        console.log('ç®€å•WAVè½¬æ¢å®Œæˆï¼Œå¤§å°:', wavBlob.size, 'bytes');
                        resolve(wavBlob);
                        
                    } catch (error) {
                        console.error('WAVè½¬æ¢å‡ºé”™:', error);
                        reject(error);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(originalBlob);
            });
        }
        

        // ==================== éŸ³é¢‘è½¬æ¢å·¥å…·å‡½æ•° ====================
        async function convertToWav(audioBlob) {
            return new Promise((resolve, reject) => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    audioContext.decodeAudioData(e.target.result)
                        .then(buffer => {
                            const sampleRate = buffer.sampleRate;
                            const numberOfChannels = buffer.numberOfChannels;
                            const wavData = encodeWAV(buffer, sampleRate, numberOfChannels);
                            const wavBlob = new Blob([wavData], { type: 'audio/wav' });
                            
                            audioContext.close();
                            resolve(wavBlob);
                        })
                        .catch(error => {
                            audioContext.close();
                            const fakeWavBlob = createSimpleWav(audioBlob);
                            resolve(fakeWavBlob);
                        });
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(audioBlob);
            });
        }

        function encodeWAV(buffer, sampleRate, numChannels) {
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = buffer.length * blockAlign;
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);
            
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            floatTo16BitPCM(view, 44, buffer, numChannels);
            
            return arrayBuffer;
        }

        function createSimpleWav(originalBlob) {
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const originalData = new Uint8Array(e.target.result);
                    const dataSize = originalData.length;
                    const bufferSize = 44 + dataSize;
                    const arrayBuffer = new ArrayBuffer(bufferSize);
                    const view = new DataView(arrayBuffer);
                    
                    writeString(view, 0, 'RIFF');
                    view.setUint32(4, 36 + dataSize, true);
                    writeString(view, 8, 'WAVE');
                    writeString(view, 12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, 1, true);
                    view.setUint16(22, 1, true);
                    view.setUint32(24, 44100, true);
                    view.setUint32(28, 88200, true);
                    view.setUint16(32, 2, true);
                    view.setUint16(34, 16, true);
                    writeString(view, 36, 'data');
                    view.setUint32(40, dataSize, true);
                    
                    for (let i = 0; i < dataSize; i++) {
                        view.setUint8(44 + i, originalData[i]);
                    }
                    
                    const wavBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
                    resolve(wavBlob);
                };
                reader.readAsArrayBuffer(originalBlob);
            });
        }

        function floatTo16BitPCM(output, offset, buffer, numChannels) {
            for (let channel = 0; channel < numChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                for (let i = 0; i < channelData.length; i++, offset += 2) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    output.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                }
            }
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // è®¾å¤‡å…¼å®¹æ€§æ£€æµ‹
        function checkAudioCompatibility() {
            const supportedFormats = [
                'audio/mp4;codecs=mp4a.40.2',
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/wav',
                'audio/ogg;codecs=opus'
            ];
            
            console.log('è®¾å¤‡éŸ³é¢‘æ ¼å¼æ”¯æŒæƒ…å†µ:');
            supportedFormats.forEach(format => {
                console.log(`${format}: ${MediaRecorder.isTypeSupported(format) ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
            });
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // ç•Œé¢æ›´æ–°
        function startTimer() {
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
                AppState.playbackTimerInterval = null;
            }
            
            AppState.recordingTime = 0;
            updateTimer();
            
            AppState.timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            AppState.recordingTime++;
            const minutes = Math.floor(AppState.recordingTime / 60).toString().padStart(2, '0');
            const seconds = (AppState.recordingTime % 60).toString().padStart(2, '0');
            
            elements.timer.textContent = `${minutes}:${seconds}`;
            
            const maxRecordingTime = 300;
            const progressPercent = Math.min((AppState.recordingTime / maxRecordingTime) * 100, 100);
            elements.progressFill.style.width = `${progressPercent}%`;
        }

        function stopTimer() {
            if (AppState.timerInterval) {
                clearInterval(AppState.timerInterval);
                AppState.timerInterval = null;
            }
        }

        function updateWaveform() {
            elements.waveform.innerHTML = '';
            const barCount = 20 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < barCount; i++) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.left = `${(i / barCount) * 100}%`;
                bar.style.height = `${30 + Math.random() * 70}%`;
                bar.style.animation = `waveform ${0.5 + Math.random() * 1.5}s infinite`;
                elements.waveform.appendChild(bar);
            }
        }

        function updateStats() {
            const total = AppState.sentences.length;
            const recorded = AppState.sentences.filter(s => s.recorded).length;
            const uploaded = AppState.sentences.filter(s => s.hasUploaded).length;
            
            elements.totalSentences.textContent = total;
            elements.uploadedSentences.textContent = uploaded;
            
            // ä¿®æ”¹è¿™ä¸€è¡Œï¼šå°†"å·²å®Œæˆ"æ”¹ä¸º"å·²ä¸Šä¼ "ï¼Œå¹¶ä½¿ç”¨uploadedå˜é‡
            elements.progressText.textContent = `${uploaded}/${total} å·²ä¸Šä¼ `;
            
            // å»ºè®®ä¿æŒè¿›åº¦æ¡ä½¿ç”¨å·²å®Œæˆçš„æ¯”ä¾‹
            const progressPercent = total > 0 ? (recorded / total) * 100 : 0;
            elements.progressFill.style.width = `${progressPercent}%`;
        }

        // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
        function showLoading(show) {
            elements.loadingIndicator.style.display = show ? 'flex' : 'none';
        }

        // çŠ¶æ€æç¤º
        function showStatus(message, type = 'info') {
            const element = elements.statusMessage;
            
            element.textContent = message;
            element.className = 'status-message';
            
            if (type === 'success') {
                element.classList.add('status-success');
            } else if (type === 'error') {
                element.classList.add('status-error');
            } else if (type === 'info') {
                element.classList.add('status-info');
            }
            
            element.style.display = 'block';
            
            setTimeout(() => {
                element.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    element.style.display = 'none';
                    element.style.animation = '';
                }, 300);
            }, 3000);
        }

        // ==================== äº‹ä»¶ç›‘å¬å™¨ ====================
        function setupEventListeners() {
            elements.recordBtn.addEventListener('click', () => {
                // å¢åŠ æ›´è¯¦ç»†çš„çŠ¶æ€æ£€æŸ¥
                if (!AppState.currentSentence) {
                    console.error('recordBtnç‚¹å‡»æ—¶æ²¡æœ‰é€‰ä¸­å¥å­:', {
                        currentSentence: AppState.currentSentence,
                        sentencesCount: AppState.sentences.length
                    });
                    showStatus('è¯·å…ˆä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªå¥å­', 'error');
                    
                    // å¦‚æœæœ‰å¥å­åˆ—è¡¨ï¼Œè‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ª
                    if (AppState.sentences.length > 0) {
                        console.log('è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªå¥å­');
                        selectSentence(AppState.sentences[0]);
                        // ç»™ç”¨æˆ·ä¸€ä¸ªæç¤º
                        setTimeout(() => {
                            showStatus('å·²è‡ªåŠ¨é€‰æ‹©ç¬¬ä¸€ä¸ªå¥å­ï¼Œå¯ä»¥å¼€å§‹å½•éŸ³äº†', 'info');
                        }, 100);
                    }
                    return;
                }
                
                // æ£€æŸ¥å½•éŸ³çŠ¶æ€
                if (AppState.isRecording) {
                    console.log('å·²ç»åœ¨å½•éŸ³ä¸­ï¼Œå¿½ç•¥ç‚¹å‡»');
                    return;
                }
                
                startRecording();
            });
            
            elements.stopBtn.addEventListener('click', () => {
                if (!AppState.currentSentence) {
                    console.warn('stopBtnç‚¹å‡»æ—¶æ²¡æœ‰é€‰ä¸­å¥å­');
                    return;
                }
                stopRecording();
            });
            
            elements.uploadBtn.addEventListener('click', () => {
                if (!AppState.currentSentence) {
                    console.error('uploadBtnç‚¹å‡»æ—¶æ²¡æœ‰é€‰ä¸­å¥å­');
                    showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¥å­', 'error');
                    return;
                }
                // æ‰‹åŠ¨ä¸Šä¼ æ—¶ä¼ é€’falseï¼Œä¸è§¦å‘åº†ç¥æ£€æŸ¥
                uploadToGitee(false);
            });
            
            elements.playBtn.addEventListener('click', () => {
                if (!AppState.currentSentence) {
                    console.error('playBtnç‚¹å‡»æ—¶æ²¡æœ‰é€‰ä¸­å¥å­');
                    showStatus('è¯·å…ˆä»å·¦ä¾§é€‰æ‹©ä¸€ä¸ªå¥å­', 'error');
                    return;
                }
                playRecording();
            });
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.target.matches('input, textarea, select')) {
                    e.preventDefault();
                    
                    if (AppState.isPlaying) stopPlayback();
                    
                    if (AppState.isRecording) {
                        stopRecording();
                    } else if (!elements.recordBtn.disabled) {
                        startRecording();
                    }
                }
                
                if (e.code === 'Escape') {
                    if (AppState.isPlaying) stopPlayback();
                    else if (AppState.isRecording) stopRecording();
                }
                
                if (e.code.startsWith('Digit') && e.code.length === 6) {
                    const num = parseInt(e.code[5]);
                    if (num >= 1 && num <= AppState.sentences.length) {
                        selectSentence(AppState.sentences[num - 1]);
                    }
                }
                
                // æ—¥æœŸå¯¼èˆªå¿«æ·é”®
                if (e.code === 'ArrowLeft' && e.altKey) {
                    e.preventDefault();
                    navigateDate(-1);
                } else if (e.code === 'ArrowRight' && e.altKey) {
                    e.preventDefault();
                    navigateDate(1);
                }
            });
            
            // åˆå§‹åŒ–æ³¢å½¢æ˜¾ç¤º
            updateWaveform();
        }

        // ä¿®æ”¹æ—¥æœŸå¯¼èˆªé€»è¾‘ï¼Œé€‚åº”æ–°çš„æ—¥æœŸé€‰æ‹©å™¨
        function navigateDate(offset) {
            const dateSelect = document.getElementById('datePicker');
            if (!dateSelect) return;
            
            const currentIndex = dateSelect.selectedIndex;
            const newIndex = currentIndex + offset;
            
            if (newIndex >= 0 && newIndex < dateSelect.options.length) {
                dateSelect.selectedIndex = newIndex;
                dateSelect.dispatchEvent(new Event('change'));
            }
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥å­æœ—è¯»å½•éŸ³ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        /* å·¦ä¾§å¥å­åˆ—è¡¨ */
        .sentence-list {
            flex: 1;
            border-right: 1px solid #eaeaea;
            overflow-y: auto;
            max-height: 600px;
        }

        .sentence-list-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sentence-item {
            padding: 15px 20px;
            border-bottom: 1px solid #eaeaea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sentence-item:hover {
            background: #f8f9fa;
        }

        .sentence-item.active {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-left: 4px solid #667eea;
        }

        .sentence-text {
            font-size: 16px;
            color: #333;
            margin-bottom: 8px;
        }

        .sentence-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #666;
        }

        .status-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .status-recorded {
            background: #d4edda;
            color: #155724;
        }

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-uploaded {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* å³ä¾§å½•éŸ³åŒºåŸŸ */
        .recording-area {
            flex: 2;
            padding: 30px;
        }

        .current-sentence {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }

        .current-sentence .sentence-id {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .current-sentence-text {
            font-size: 20px;
            line-height: 1.6;
            color: #333;
        }

        /* å½•éŸ³æ§åˆ¶åŒº */
        .recording-controls {
            text-align: center;
            margin: 30px 0;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .btn-record {
            background: #dc3545;
            color: white;
        }

        .btn-record:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn-stop {
            background: #6c757d;
            color: white;
        }

        .btn-stop:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-upload {
            background: #28a745;
            color: white;
        }

        .btn-upload:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-play {
            background: #17a2b8;
            color: white;
        }

        .btn-play:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .timer {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .waveform {
            height: 100px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            position:relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: #667eea;
            border-radius: 3px 3px 0 0;
        }

        /* æ’­æ”¾æŒ‡ç¤ºå™¨ */
        .playback-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2196F3;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(33, 150, 243, 0.3);
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease;
            display: none;
        }

        .status-success {
            background: #4CAF50;
            color: white;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        .status-info {
            background: #2196F3;
            color: white;
        }

        /* è¿›åº¦æ¡ */
        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eaeaea;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* æ—¥æœŸé€‰æ‹©å™¨æ ·å¼ */
        .date-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 40px;
            padding: 15px 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-radius: 10px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .date-selector label {
            font-weight: bold;
            color: #333;
            font-size: 16px;
        }

        .date-selector input[type="date"] {
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 6px;
            font-size: 14px;
            color: #333;
            background: white;
            cursor: pointer;
            flex: 1;
            max-width: 200px;
        }

        .date-quick-buttons {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .date-quick-buttons .btn {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
        }

        .date-quick-buttons .btn-today {
            background: #667eea;
            color: white;
        }

        .date-quick-buttons .btn-yesterday {
            background: #6c757d;
            color: white;
        }

        /* åŠ¨ç”» */
        @keyframes slideIn {
            from { top: -50px; opacity: 0; }
            to { top: 20px; opacity: 1; }
        }

        @keyframes slideOut {
            from { top: 20px; opacity: 1; }
            to { top: -50px; opacity: 0; }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
            100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
        }

        @keyframes recordingPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes waveform {
            0% { height: 20%; }
            50% { height: 100%; }
            100% { height: 20%; }
        }

        .playing .current-sentence {
            animation: pulse 1.5s infinite;
        }

        .btn-play.playing {
            background: #ff9800;
            animation: recordingPulse 1.5s infinite;
        }

        .upload-icon {
            margin-left: 5px;
        }

        /* åŠ è½½æŒ‡ç¤ºå™¨ */
        .loading-indicator {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sentence-list {
                max-height: 300px;
            }
            
            .control-buttons {
                flex-wrap: wrap;
            }
            
            .date-selector {
                flex-direction: column;
                align-items: stretch;
                margin: 20px;
            }
            
            .date-selector input[type="date"] {
                max-width: none;
            }
            
            .date-quick-buttons {
                margin-left: 0;
                justify-content: center;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
    <div class="loading-indicator" id="loadingIndicator">
        <div class="loading-spinner"></div>
    </div>

    <div class="container">
        <!-- å¤´éƒ¨ -->
        <div class="header">
            <h1>ğŸ“ æœ—è¯»å½•éŸ³ç³»ç»Ÿ</h1>
        </div>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <!-- å·¦ä¾§å¥å­åˆ—è¡¨ -->
            <div class="sentence-list">
                <div class="sentence-list-header">
                    <h3>ğŸ“‹ å¥å­åˆ—è¡¨</h3>
                    <span id="progressText">0/0 å·²å®Œæˆ</span>
                </div>
                <div id="sentencesContainer">
                    <!-- å¥å­é¡¹å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- å³ä¾§å½•éŸ³åŒº -->
            <div class="recording-area">
                <!-- å½“å‰å¥å­å±•ç¤º -->
                <div class="current-sentence">
                    <div class="sentence-id" id="currentSentenceId">S001</div>
                    <div class="current-sentence-text" id="currentSentenceText">
                        è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€å¥å¼€å§‹æœ—è¯»å½•éŸ³
                    </div>
                </div>

                <!-- å½•éŸ³æ§åˆ¶ -->
                <div class="recording-controls">
                    <div class="timer" id="timer">00:00</div>
                    <div class="waveform" id="waveform"></div>
                    
                    <div class="control-buttons">
                        <button class="btn btn-record" id="recordBtn">
                            <span>ğŸ¤ å¼€å§‹å½•éŸ³</span>
                        </button>
                        <button class="btn btn-stop" id="stopBtn" disabled>
                            <span>â¹ï¸ åœæ­¢å½•éŸ³</span>
                        </button>
                        <button class="btn btn-upload" id="uploadBtn" disabled>
                            <span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>
                        </button>
                        <button class="btn btn-play" id="playBtn" disabled>
                            <span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>
                        </button>
                    </div>

                    <!-- è¿›åº¦æ¡ -->
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-number" id="totalSentences">0</div>
                        <div class="stat-label">æ€»å¥å­æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="completedSentences">0</div>
                        <div class="stat-label">å·²å®Œæˆ</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="uploadedSentences">0</div>
                        <div class="stat-label">å·²ä¸Šä¼ </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="playback-indicator" id="playbackIndicator">ğŸ”Š æ­£åœ¨æ’­æ”¾...</div>
    <div class="status-message" id="statusMessage"></div>

    <script>
        // ==================== é…ç½®æ–‡ä»¶ ====================
        // æ³¨é‡Šæ‰GitHubé…ç½®ï¼Œå› ä¸ºä¸»è¦ä½¿ç”¨Gitee
        const GITHUB_CONFIG = {
            // ä¿ç•™ä½†ä¸ä½¿ç”¨
            REPOSITORY: 'wanzishare/ReadAloud',
            TOKEN: ''
        };

        // ä¸»è¦ä½¿ç”¨Giteeé…ç½®
        const GITEE_CONFIG = {
            // ä½ çš„Giteeä»“åº“ï¼Œæ ¼å¼ï¼šç”¨æˆ·å/ä»“åº“å
            REPOSITORY: 'bufan1990/read-aloud',
            
            // ä½ çš„Gitee Personal Access Tokenï¼ˆéœ€è¦repoæƒé™ï¼‰
            TOKEN: 'f62b136877bc9f4a2491f1ef30286857',
            
            // Gitee APIåŸºç¡€URL
            API_BASE: 'https://gitee.com/api/v5',
            
            // Gitee RAWæ–‡ä»¶åŸºç¡€URLï¼ˆç”¨äºç›´æ¥ä¸‹è½½æ–‡ä»¶ï¼‰
            RAW_BASE: 'https://gitee.com'
        };

        // ç¤ºä¾‹å¥å­æ•°æ®
        const SAMPLE_SENTENCES = [
            { id: 'S001', text: 'ç”Ÿæ´»å°±åƒä¸€ç›’å·§å…‹åŠ›ï¼Œä½ æ°¸è¿œä¸çŸ¥é“ä¸‹ä¸€é¢—æ˜¯ä»€ä¹ˆå‘³é“ã€‚', recorded: false, hasUploaded: false },
            { id: 'S002', text: 'æˆåŠŸä¸æ˜¯ç»ˆç‚¹ï¼Œå¤±è´¥ä¹Ÿå¹¶éæœ«æ—¥ï¼Œé‡è¦çš„æ˜¯ç»§ç»­å‰è¿›çš„å‹‡æ°”ã€‚', recorded: false, hasUploaded: false },
            { id: 'S003', text: 'å­¦ä¹ å¦‚é€†æ°´è¡ŒèˆŸï¼Œä¸è¿›åˆ™é€€ã€‚', recorded: false, hasUploaded: false },
            { id: 'S004', text: 'æ—¶é—´æ˜¯æœ€å¥½çš„è€å¸ˆï¼Œä½†é—æ†¾çš„æ˜¯ï¼Œå®ƒä¼šæ€æ­»æ‰€æœ‰å­¦ç”Ÿã€‚', recorded: false, hasUploaded: false },
            { id: 'S005', text: 'æ¢¦æƒ³ä¸ä¼šé€ƒè·‘ï¼Œé€ƒè·‘çš„æ°¸è¿œæ˜¯è‡ªå·±ã€‚', recorded: false, hasUploaded: false },
            { id: 'S006', text: 'çœŸæ­£çš„å‘ç°ä¹‹æ—…ä¸åœ¨äºå¯»æ‰¾æ–°é£æ™¯ï¼Œè€Œåœ¨äºæ‹¥æœ‰æ–°çœ¼å…‰ã€‚', recorded: false, hasUploaded: false },
            { id: 'S007', text: 'å¿è€ä¹‹æ ‘ç»“å‡ºé»„é‡‘ä¹‹æœã€‚', recorded: false, hasUploaded: false },
            { id: 'S008', text: 'äººç”Ÿæ²¡æœ‰å½©æ’ï¼Œæ¯ä¸€å¤©éƒ½æ˜¯ç°åœºç›´æ’­ã€‚', recorded: false, hasUploaded: false },
            { id: 'S009', text: 'æœºä¼šæ€»æ˜¯ç•™ç»™æœ‰å‡†å¤‡çš„äººã€‚', recorded: false, hasUploaded: false },
            { id: 'S010', text: 'åƒé‡Œä¹‹è¡Œï¼Œå§‹äºè¶³ä¸‹ã€‚', recorded: false, hasUploaded: false }
        ];

        // ==================== åº”ç”¨çŠ¶æ€ ====================
        const AppState = {
            sentences: [],
            currentSentence: null,
            audioBlob: null,
            audioChunks: [],
            isRecording: false,
            recorder: null,
            timerInterval: null,
            recordingTime: 0,
            todayDate: (() => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            selectedDate: (() => {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            })(),
            config: GITEE_CONFIG, // ä½¿ç”¨Giteeé…ç½®
            isPlaying: false,
            currentAudio: null,            
            playbackTimerInterval: null,
            playbackTime: 0,
            audioCurrentTime: 0,
            audioDuration: 0,
            isDownloading: false,
            lastDownloadTime: null
        };

        // ==================== DOMå…ƒç´  ====================
        const elements = {
            sentencesContainer: document.getElementById('sentencesContainer'),
            currentSentenceId: document.getElementById('currentSentenceId'),
            currentSentenceText: document.getElementById('currentSentenceText'),
            recordBtn: document.getElementById('recordBtn'),
            stopBtn: document.getElementById('stopBtn'),
            uploadBtn: document.getElementById('uploadBtn'),
            playBtn: document.getElementById('playBtn'),
            timer: document.getElementById('timer'),
            waveform: document.getElementById('waveform'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            totalSentences: document.getElementById('totalSentences'),
            completedSentences: document.getElementById('completedSentences'),
            uploadedSentences: document.getElementById('uploadedSentences'),
            playbackIndicator: document.getElementById('playbackIndicator'),
            statusMessage: document.getElementById('statusMessage'),
            loadingIndicator: document.getElementById('loadingIndicator')
        };

        // æ·»åŠ ä¸€ä¸ªæ—¥æœŸéªŒè¯å’Œä¿®å¤å‡½æ•°
        function validateAndFixDates() {
            console.log('å½“å‰æ—¥æœŸçŠ¶æ€:', {
                todayDate: AppState.todayDate,
                selectedDate: AppState.selectedDate,
                localToday: (() => {
                    const now = new Date();
                    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
                })()
            });
            
            // å¦‚æœselectedDateæ¯”ä»Šå¤©æ™šï¼Œè°ƒæ•´ä¸ºä»Šå¤©
            if (AppState.selectedDate > AppState.todayDate) {
                console.log('è­¦å‘Šï¼šé€‰æ‹©çš„æ—¥æœŸåœ¨æœªæ¥ï¼Œè°ƒæ•´ä¸ºä»Šå¤©');
                AppState.selectedDate = AppState.todayDate;
            }
            
            // å¦‚æœselectedDateæ¯”30å¤©å‰è¿˜æ—©ï¼Œè°ƒæ•´ä¸º30å¤©å‰
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            const minDateStr = `${thirtyDaysAgo.getFullYear()}-${String(thirtyDaysAgo.getMonth() + 1).padStart(2, '0')}-${String(thirtyDaysAgo.getDate()).padStart(2, '0')}`;
            
            if (AppState.selectedDate < minDateStr) {
                console.log('è­¦å‘Šï¼šé€‰æ‹©çš„æ—¥æœŸè¶…è¿‡30å¤©é™åˆ¶ï¼Œè°ƒæ•´ä¸º30å¤©å‰');
                AppState.selectedDate = minDateStr;
            }
        }

        // ==================== åˆå§‹åŒ–åº”ç”¨ ====================
        function initApp() {
            console.log('åˆå§‹åŒ–åº”ç”¨...');
            
            // æ£€æŸ¥éŸ³é¢‘å…¼å®¹æ€§
            checkAudioCompatibility();
            
            // æ£€æŸ¥Giteeé…ç½®
            if (!AppState.config.REPOSITORY || !AppState.config.TOKEN) {
                showStatus('è¯·å…ˆé…ç½®Giteeä¿¡æ¯ï¼', 'error');
                return;
            }
            // 1. éªŒè¯å’Œä¿®å¤æ—¥æœŸ
            validateAndFixDates();

            // 1. æ·»åŠ æ—¥æœŸé€‰æ‹©å™¨
            createDateSelector();
            
            // 2. åŠ è½½å½“å‰é€‰æ‹©æ—¥æœŸçš„å¥å­æ•°æ®
            loadSentencesForSelectedDate();
            
            // 3. ç«‹å³æ¸²æŸ“å¥å­åˆ—è¡¨
            renderSentenceList();
            
            // 4. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            updateStats();
            
            // 5. è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            showStatus('ç³»ç»Ÿå·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹å½•éŸ³', 'info');
            
            // 6. åœ¨é¡µé¢å®Œå…¨åŠ è½½åï¼Œå¼‚æ­¥æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
            setTimeout(() => {
                checkServerFilesInBackground();
            }, 100);
        }

        // æ·»åŠ è°ƒè¯•å‡½æ•°æ¥æ£€æŸ¥æ—¥æœŸ
        function debugDateInfo() {
            console.log('=== æ—¥æœŸä¿¡æ¯è°ƒè¯• ===');
            
            // å½“å‰æ—¶é—´
            const now = new Date();
            console.log('å½“å‰æ—¶é—´å¯¹è±¡:', now);
            console.log('UTCæ—¶é—´:', now.toISOString());
            console.log('æœ¬åœ°æ—¶é—´:', now.toString());
            
            // å„ç§æ ¼å¼
            console.log('ISOåˆ†å‰²:', now.toISOString().split('T')[0]);
            console.log('æœ¬åœ°æ ¼å¼åŒ–:', 
                now.getFullYear() + '-' + 
                String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                String(now.getDate()).padStart(2, '0')
            );
            
            // æ£€æŸ¥æ—¥æœŸè¾“å…¥
            const dateInput = document.getElementById('datePicker');
            if (dateInput) {
                console.log('æ—¥æœŸè¾“å…¥æ¡†:', {
                    value: dateInput.value,
                    min: dateInput.min,
                    max: dateInput.max,
                    step: dateInput.step
                });
            }
            
            // æ£€æŸ¥AppState
            console.log('AppStateæ—¥æœŸ:', {
                todayDate: AppState.todayDate,
                selectedDate: AppState.selectedDate
            });
        }

        // åˆ›å»ºæ—¥æœŸé€‰æ‹©å™¨
        function createDateSelector() {
            // åˆ›å»ºæ—¥æœŸé€‰æ‹©å™¨å®¹å™¨
            const dateSelector = document.createElement('div');
            dateSelector.className = 'date-selector';
            
            // æ—¥æœŸé€‰æ‹©å™¨æ ‡ç­¾
            const label = document.createElement('label');
            label.textContent = 'ğŸ“… é€‰æ‹©æ—¥æœŸ:';
            label.htmlFor = 'datePicker';
            
            // æ—¥æœŸè¾“å…¥æ¡†
            const dateInput = document.createElement('input');
            dateInput.type = 'date';
            dateInput.id = 'datePicker';
            dateInput.value = AppState.selectedDate;
            
            // ä¿®å¤æ—¥æœŸèŒƒå›´è®¡ç®—
            const getLocalDateString = (date) => {
                // ä½¿ç”¨æœ¬åœ°æ—¶é—´è€Œä¸æ˜¯UTCæ—¶é—´
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            // è®¡ç®—æ—¥æœŸèŒƒå›´
            const today = new Date();
            const maxDate = getLocalDateString(today); // ä»Šå¤©
            const minDate = new Date(today);
            minDate.setDate(today.getDate() - 30); // 30å¤©å‰
            const minDateStr = getLocalDateString(minDate);
            
            console.log('æ—¥æœŸèŒƒå›´:', {
                min: minDateStr,
                max: maxDate,
                today: maxDate,
                currentSelected: AppState.selectedDate
            });
            
            dateInput.max = maxDate;
            dateInput.min = minDateStr;
            
            // æ—¥æœŸå˜åŒ–äº‹ä»¶
            dateInput.addEventListener('change', async (e) => {
                const newDate = e.target.value;
                if (newDate === AppState.selectedDate) return;
                
                console.log('åˆ‡æ¢åˆ°æ—¥æœŸ:', newDate);
                showLoading(true);
                
                // åœæ­¢æ­£åœ¨è¿›è¡Œçš„æ“ä½œ
                if (AppState.isRecording) stopRecording();
                if (AppState.isPlaying) stopPlayback();
                
                // ä¿å­˜å½“å‰æ—¥æœŸçš„çŠ¶æ€
                saveCurrentState();
                
                // æ›´æ–°æ—¥æœŸ
                AppState.selectedDate = newDate;
                
                // åŠ è½½æ–°æ—¥æœŸçš„æ•°æ®
                await loadSentencesForSelectedDate();
                renderSentenceList();
                updateStats();
                
                // é‡ç½®å½“å‰å¥å­
                resetCurrentSentence();
                
                // æ£€æŸ¥æœåŠ¡å™¨æ–‡ä»¶
                checkServerFilesInBackground();
                
                showLoading(false);
                showStatus(`å·²åˆ‡æ¢åˆ° ${AppState.selectedDate} çš„æ•°æ®`, 'info');
            });
            
            // æ·»åŠ å¿«æ·æŒ‰é’®å®¹å™¨
            const quickButtons = document.createElement('div');
            quickButtons.className = 'date-quick-buttons';
            
            // ä»Šå¤©æŒ‰é’®
            const todayBtn = document.createElement('button');
            todayBtn.textContent = 'ä»Šå¤©';
            todayBtn.className = 'btn btn-today';
            todayBtn.onclick = () => {
                const todayStr = getLocalDateString(new Date());
                dateInput.value = todayStr;
                dateInput.dispatchEvent(new Event('change'));
            };
            
            // æ˜¨å¤©æŒ‰é’®
            const yesterdayBtn = document.createElement('button');
            yesterdayBtn.textContent = 'æ˜¨å¤©';
            yesterdayBtn.className = 'btn btn-yesterday';
            yesterdayBtn.onclick = () => {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = getLocalDateString(yesterday);
                dateInput.value = yesterdayStr;
                dateInput.dispatchEvent(new Event('change'));
            };
            
            quickButtons.appendChild(todayBtn);
            quickButtons.appendChild(yesterdayBtn);
            
            dateSelector.appendChild(label);
            dateSelector.appendChild(dateInput);
            dateSelector.appendChild(quickButtons);
            
            // æ’å…¥åˆ°æ ‡é¢˜ä¸‹é¢
            const header = document.querySelector('.header');
            header.parentNode.insertBefore(dateSelector, header.nextSibling);
            
            return dateInput;
        }

        // ä¿å­˜å½“å‰çŠ¶æ€
        function saveCurrentState() {
            if (AppState.sentences.length > 0) {
                const key = `sentences_${AppState.selectedDate}`;
                localStorage.setItem(key, JSON.stringify(AppState.sentences));
                console.log(`ä¿å­˜ ${AppState.selectedDate} çš„æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨`);
            }
        }

        // é‡ç½®å½“å‰å¥å­
        function resetCurrentSentence() {
            AppState.currentSentence = null;
            AppState.audioBlob = null;
            
            elements.currentSentenceId.textContent = '';
            elements.currentSentenceText.textContent = 'è¯·é€‰æ‹©æ—¥æœŸä¸­çš„ä¸€å¥å¼€å§‹æœ—è¯»å½•éŸ³';
            elements.playBtn.disabled = true;
            elements.uploadBtn.disabled = true;
            elements.recordBtn.disabled = false;
            elements.stopBtn.disabled = true;
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
        }

        // åŠ è½½æŒ‡å®šæ—¥æœŸçš„å¥å­æ•°æ®
        async function loadSentencesForSelectedDate() {
            console.log('åŠ è½½æ—¥æœŸæ•°æ®:', AppState.selectedDate);
            
            const savedKey = `sentences_${AppState.selectedDate}`;
            const saved = localStorage.getItem(savedKey);
            
            if (saved) {
                try {
                    AppState.sentences = JSON.parse(saved);
                    console.log(`ä»æœ¬åœ°å­˜å‚¨åŠ è½½ ${AppState.selectedDate} çš„å¥å­æ•°æ®ï¼Œå…±`, AppState.sentences.length, 'æ¡');
                } catch (e) {
                    console.warn('æœ¬åœ°å­˜å‚¨æ•°æ®æŸåï¼Œä½¿ç”¨é»˜è®¤å¥å­');
                    AppState.sentences = SAMPLE_SENTENCES.map(s => ({
                        ...s,
                        recorded: false,
                        hasUploaded: false
                    }));
                }
            } else {
                // æ€»æ˜¯ä»é»˜è®¤å¥å­å¤åˆ¶ç»“æ„ï¼Œæ¸…é™¤å½•åˆ¶çŠ¶æ€
                AppState.sentences = SAMPLE_SENTENCES.map(s => ({
                    ...s,
                    recorded: false,
                    hasUploaded: false,
                    lastRecorded: null,
                    uploadedAt: null
                }));
                console.log(`åˆå§‹åŒ– ${AppState.selectedDate} çš„å¥å­æ•°æ®ï¼Œå…±`, AppState.sentences.length, 'æ¡');
            }
            
            // åˆå§‹åŒ–hasUploadedå±æ€§
            AppState.sentences.forEach(sentence => {
                if (sentence.hasUploaded === undefined) {
                    sentence.hasUploaded = false;
                }
            });
            
            // æ£€æŸ¥æœ¬åœ°å½•éŸ³æ–‡ä»¶
            await checkDateRecordings();
            
            // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
            saveSentencesForSelectedDate();
        }

        // æ£€æŸ¥ä»Šå¤©æ˜¯å¦æœ‰å·²å½•åˆ¶çš„éŸ³é¢‘æ–‡ä»¶
        async function checkDateRecordings() {
            console.log(`æ£€æŸ¥ ${AppState.selectedDate} çš„æœ¬åœ°å½•éŸ³æ–‡ä»¶`);
            
            for (const sentence of AppState.sentences) {
                const audioKey = `audio_${AppState.selectedDate}_${sentence.id}`;
                const audioData = localStorage.getItem(audioKey);
                
                if (audioData) {
                    sentence.recorded = true;
                    sentence.lastRecorded = AppState.selectedDate;
                } else {
                    sentence.recorded = false;
                    sentence.lastRecorded = null;
                }
            }
        }

        // ä¿å­˜å½“å‰é€‰æ‹©æ—¥æœŸçš„å¥å­æ•°æ®
        function saveSentencesForSelectedDate() {
            const key = `sentences_${AppState.selectedDate}`;
            localStorage.setItem(key, JSON.stringify(AppState.sentences));
        }

        // ä¿®å¤åçš„æ–‡ä»¶æ£€æŸ¥å‡½æ•°
        async function checkFileExistsOnServer(sentenceId) {    
            const fileName = `${AppState.selectedDate}_${sentenceId}.wav`;
            const filePath = `recordings/${AppState.selectedDate}/${fileName}`;
            
            console.log(`æ£€æŸ¥Giteeæ–‡ä»¶æ˜¯å¦å­˜åœ¨: ${filePath}`);
            
            try {
                const response = await fetch(
                    `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`,{
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Accept': 'application/json'
                        },
                        signal: AbortSignal.timeout(5000)
                    }
                );
                
                console.log(`Gitee APIå“åº”çŠ¶æ€: ${response.status}`);
                
                if (response.status === 200) {
                    const responseData = await response.json();
                    
                    // å¦‚æœè¿”å›çš„æ˜¯ç©ºæ•°ç»„ []ï¼Œè¡¨ç¤ºæ–‡ä»¶ä¸å­˜åœ¨
                    if (Array.isArray(responseData) && responseData.length === 0) {
                        console.log(`âŒ æ–‡ä»¶ä¸å­˜åœ¨ï¼ˆè¿”å›ç©ºæ•°ç»„ï¼‰: ${filePath}`);
                        return false;
                    }
                    
                    // å¦‚æœè¿”å›çš„æ˜¯å¯¹è±¡ä¸”æœ‰shaå­—æ®µï¼Œè¡¨ç¤ºæ–‡ä»¶å­˜åœ¨
                    if (responseData && typeof responseData === 'object' && responseData.sha) {
                        console.log(`âœ… æ–‡ä»¶å­˜åœ¨: ${filePath}`);
                        return true;
                    }
                    
                    // å…¶ä»–æƒ…å†µè§†ä¸ºæ–‡ä»¶ä¸å­˜åœ¨
                    console.log(`âŒ æ— æ³•åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå“åº”æ ¼å¼: ${typeof responseData}`);
                    return false;
                    
                } else if (response.status === 404) {
                    console.log(`âŒ æ–‡ä»¶ä¸å­˜åœ¨ï¼ˆ404ï¼‰: ${filePath}`);
                    return false;
                } else {
                    console.warn(`âš ï¸ æ£€æŸ¥æ–‡ä»¶ ${filePath} è¿”å›çŠ¶æ€ç : ${response.status}`);
                    return false;
                }
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log(`â° æ£€æŸ¥æ–‡ä»¶ ${filePath} è¶…æ—¶`);
                } else {
                    console.log(`âŒ æ£€æŸ¥æ–‡ä»¶ ${filePath} å¤±è´¥:`, error.message);
                }
                return false;
            }
        }

        async function checkServerFilesInBackground() {
            console.log(`å¼€å§‹åœ¨åå°æ£€æŸ¥ ${AppState.selectedDate} çš„æœåŠ¡å™¨çŠ¶æ€...`);
            
            try {
                let updatedCount = 0;
                
                for (let i = 0; i < AppState.sentences.length; i++) {
                    const sentence = AppState.sentences[i];
                    
                    try {
                        const fileExists = await checkFileExistsOnServer(sentence.id);
                        const wasUploaded = sentence.hasUploaded;
                        
                        if (fileExists !== sentence.hasUploaded) {
                            sentence.hasUploaded = fileExists;
                            updatedCount++;
                            
                            console.log(`å¥å­ ${sentence.id} çŠ¶æ€å˜åŒ–: ${wasUploaded} -> ${fileExists}`);
                            
                            // æ›´æ–°UI
                            updateSentenceItemInUI(sentence);
                        }
                        
                    } catch (error) {
                        console.warn(`æ£€æŸ¥å¥å­ ${sentence.id} å¤±è´¥:`, error);
                    }
                }
                
                // ä¿å­˜æ›´æ–°åçš„çŠ¶æ€
                saveSentencesForSelectedDate();
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                updateStats();
                
                console.log(`åå°æ£€æŸ¥å®Œæˆï¼Œæ›´æ–°äº† ${updatedCount} æ¡è®°å½•`);
                
                if (updatedCount > 0) {
                    showStatus(`å‘ç° ${updatedCount} ä¸ªå·²ä¸Šä¼ æ–‡ä»¶`, 'success');
                }
                
            } catch (error) {
                console.error('åå°æ£€æŸ¥å‡ºé”™:', error);
                showStatus('æ£€æŸ¥æœåŠ¡å™¨æ–‡ä»¶å¤±è´¥', 'error');
            }
        }

        // æ›´æ–°å¥å­é¡¹UI
        function updateSentenceItemInUI(sentence) {
            const items = document.querySelectorAll('.sentence-item');
            
            for (const item of items) {
                const idElement = item.querySelector('.sentence-meta span:first-child');
                if (idElement && idElement.textContent.trim() === sentence.id) {
                    updateItemUI(item, sentence);
                    return;
                }
            }
            
            // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œé‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨
            renderSentenceList();
            updateStats();
        }

        // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°å•ä¸ªé¡¹ç›®çš„UI
        function updateItemUI(item, sentence) {
            const badge = item.querySelector('.status-badge');
            const textElement = item.querySelector('.sentence-text');
            
            if (!badge || !textElement) return;
            
            // ç¡®å®šçŠ¶æ€
            let statusClass, statusText;
            let prefix = '';
            
            if (sentence.hasUploaded) {
                statusClass = 'status-uploaded';
                statusText = 'âœ“ å·²ä¸Šä¼ ';
                prefix = 'ğŸŒ ';
            } else if (sentence.recorded) {
                statusClass = 'status-recorded';
                statusText = 'âœ“ å·²å½•åˆ¶';
                // å·²å½•åˆ¶ä½†æœªä¸Šä¼ çš„å¥å­ä¸åŠ å‰ç¼€
                prefix = '';
            } else {
                statusClass = 'status-pending';
                statusText = 'å¾…å½•åˆ¶';
                prefix = '';
            }
            
            // æ›´æ–°å¾½ç« 
            badge.className = `status-badge ${statusClass}`;
            badge.textContent = statusText;
            
            // æ›´æ–°æ–‡æœ¬ - åªå¯¹å·²ä¸Šä¼ çš„å¥å­æ·»åŠ å‰ç¼€
            if (prefix && !textElement.textContent.startsWith('ğŸŒ ')) {
                textElement.textContent = prefix + sentence.text;
            } else if (!prefix && textElement.textContent.startsWith('ğŸŒ ')) {
                textElement.textContent = sentence.text;
            }
            
            // å¦‚æœéœ€è¦ï¼ŒåŒæ—¶æ›´æ–°å½“å‰é€‰ä¸­çš„å¥å­çš„æ˜¾ç¤º
            if (AppState.currentSentence && AppState.currentSentence.id === sentence.id) {
                AppState.currentSentence.hasUploaded = sentence.hasUploaded;
                
                // æ›´æ–°ä¸Šä¼ æŒ‰é’®çŠ¶æ€
                if (sentence.hasUploaded) {
                    elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                } else {
                    elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨';
                }
            }
        }

        async function getGiteeFileSHA(filePath) {
            try {
                const response = await fetch(
            `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`,
                    {
                        headers: {
                            'Accept': 'application/json'
                        }
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºæ•°ç»„
                    if (Array.isArray(data) && data.length === 0) {
                        return null;
                    }
                    return data.sha;
                }
                return null;
            } catch (error) {
                console.log('Giteeæ–‡ä»¶ä¸å­˜åœ¨æˆ–ç½‘ç»œé”™è¯¯:', error);
                return null;
            }
        }

        function renderSentenceList() {
            console.log('æ¸²æŸ“å¥å­åˆ—è¡¨ï¼Œå…±', AppState.sentences.length, 'æ¡');
            
            elements.sentencesContainer.innerHTML = '';
            
            AppState.sentences.forEach((sentence) => {
                const item = document.createElement('div');
                item.className = `sentence-item ${sentence === AppState.currentSentence ? 'active' : ''}`;
                item.dataset.sentenceId = sentence.id;
                
                // ä½¿ç”¨æœ€æ–°çš„çŠ¶æ€
                let statusClass = 'status-pending';
                let statusText = 'å¾…å½•åˆ¶';
                let prefix = '';
                
                if (sentence.hasUploaded) {
                    statusClass = 'status-uploaded';
                    statusText = 'âœ“ å·²ä¸Šä¼ ';
                    prefix = 'ğŸŒ ';
                } else if (sentence.recorded) {
                    statusClass = 'status-recorded';
                    statusText = 'âœ“ å·²å½•åˆ¶';
                }
                
                item.innerHTML = `
                    <div class="sentence-text">${prefix}${sentence.text}</div>
                    <div class="sentence-meta">
                        <span>${sentence.id}</span>
                        <span class="status-badge ${statusClass}">
                            ${statusText}
                        </span>
                    </div>
                `;
                
                item.onclick = () => selectSentence(sentence);
                elements.sentencesContainer.appendChild(item);
            });
            
            console.log('å¥å­åˆ—è¡¨æ¸²æŸ“å®Œæˆ');
        }

        // ä¿®å¤åçš„ä¸‹è½½å‡½æ•°ï¼Œåªä½¿ç”¨Gitee
        async function downloadAudioFromGitee(sentenceId) {
            console.log('ä»Giteeä¸‹è½½éŸ³é¢‘:', sentenceId);
            
            const fileName = `${AppState.selectedDate}_${sentenceId}.wav`;
            const filePath = `recordings/${AppState.selectedDate}/${fileName}`;
            
            try {
                // ç›´æ¥ä½¿ç”¨Gitee APIä¸‹è½½ï¼Œé¿å…è·¨åŸŸé—®é¢˜
                const apiUrl = `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}?access_token=${GITEE_CONFIG.TOKEN}`;
                
                console.log('ä½¿ç”¨Gitee APIä¸‹è½½:', apiUrl);
                
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-store',
                    headers: {
                        'Accept': 'application/json'
                    },
                    signal: AbortSignal.timeout(10000)
                });
                
                if (!response.ok) {
                    console.error('ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç :', response.status);
                    return null;
                }
                
                const fileData = await response.json();
                
                // Giteeè¿”å›çš„æ•°æ®ç»“æ„
                if (fileData.content && fileData.encoding === 'base64') {
                    // è§£ç base64
                    const binaryString = atob(fileData.content);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    // å°è¯•ç¡®å®šæ­£ç¡®çš„MIMEç±»å‹
                    let mimeType = 'audio/wav';
                    
                    // æ£€æŸ¥æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯ï¼Œç¡®å®šå®é™…æ ¼å¼
                    if (bytes.length > 4) {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºWAVæ–‡ä»¶ï¼ˆRIFFå¤´éƒ¨ï¼‰
                        if (bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46) {
                            mimeType = 'audio/wav';
                        } 
                        // æ£€æŸ¥æ˜¯å¦ä¸ºWebMæ–‡ä»¶
                        else if (bytes[0] === 0x1A && bytes[1] === 0x45 && bytes[2] === 0xDF && bytes[3] === 0xA3) {
                            mimeType = 'audio/webm';
                        }
                        // æ£€æŸ¥æ˜¯å¦ä¸ºOggæ–‡ä»¶
                        else if (bytes[0] === 0x4F && bytes[1] === 0x67 && bytes[2] === 0x67 && bytes[3] === 0x53) {
                            mimeType = 'audio/ogg';
                        }
                    }
                    
                    console.log('æ£€æµ‹åˆ°çš„éŸ³é¢‘æ ¼å¼:', mimeType);
                    const audioBlob = new Blob([bytes], { type: mimeType });
                    console.log('âœ… ä»Giteeä¸‹è½½æˆåŠŸï¼Œå¤§å°:', audioBlob.size, 'bytes');
                    
                    return audioBlob;
                }
                
                console.warn('âŒ æ— æ³•ä»Giteeä¸‹è½½éŸ³é¢‘ï¼šæ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                return null;
                
            } catch (error) {
                console.error('âŒ ä»Giteeä¸‹è½½éŸ³é¢‘å¤±è´¥:', error);
                return null;
            }
        }

        // éŸ³é¢‘ç¼“å­˜å‡½æ•°
        function cacheAudioToLocal(sentenceId, audioBlob) {
            try {
                const audioKey = `audio_${AppState.selectedDate}_${sentenceId}`;
                
                // æ£€æŸ¥Blobæ˜¯å¦æœ‰æ•ˆ
                if (!audioBlob || audioBlob.size === 0) {
                    console.warn('éŸ³é¢‘Blobæ— æ•ˆï¼Œè·³è¿‡ç¼“å­˜');
                    return;
                }
                
                // ç¡®ä¿æœ‰æ­£ç¡®çš„MIMEç±»å‹
                let mimeType = audioBlob.type;
                if (!mimeType || mimeType === '') {
                    mimeType = 'audio/webm'; // é»˜è®¤ç±»å‹
                    console.warn('éŸ³é¢‘ç¼ºå°‘MIMEç±»å‹ï¼Œä½¿ç”¨é»˜è®¤:', mimeType);
                }
                
                const reader = new FileReader();
                
                reader.onload = () => {
                    const result = reader.result;
                    if (typeof result === 'string' && result.startsWith('data:')) {
                        localStorage.setItem(audioKey, result);
                        console.log('éŸ³é¢‘å·²ç¼“å­˜åˆ°æœ¬åœ°å­˜å‚¨:', audioKey, 'å¤§å°:', result.length);
                    } else {
                        console.warn('éŸ³é¢‘ç¼“å­˜ç»“æœæ ¼å¼ä¸æ­£ç¡®');
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('éŸ³é¢‘ç¼“å­˜å¤±è´¥:', error);
                };
                
                reader.readAsDataURL(audioBlob);
            } catch (error) {
                console.warn('éŸ³é¢‘ç¼“å­˜è¿‡ç¨‹å¤±è´¥:', error);
            }
        }

        function selectSentence(sentence) {
            console.log('é€‰æ‹©å¥å­:', sentence.id);
            
            if (!sentence) return;
            
            // å¦‚æœé€‰æ‹©çš„æ˜¯åŒä¸€ä¸ªå¥å­ï¼Œä¸è¦é‡å¤æ“ä½œ
            if (AppState.currentSentence && AppState.currentSentence.id === sentence.id) {
                console.log('é‡å¤é€‰æ‹©åŒä¸€ä¸ªå¥å­ï¼Œè·³è¿‡');
                return;
            }
            
            // é‡ç½®æ‰€æœ‰çŠ¶æ€
            if (AppState.isPlaying) stopPlayback();
            if (AppState.timerInterval) clearInterval(AppState.timerInterval);
            if (AppState.playbackTimerInterval) clearInterval(AppState.playbackTimerInterval);
            
            AppState.recordingTime = 0;
            AppState.playbackTime = 0;
            AppState.audioCurrentTime = 0;
            AppState.audioDuration = 0;
            AppState.currentSentence = sentence;
            AppState.audioBlob = null;
            
            // æ›´æ–°UIæ˜¾ç¤º
            elements.currentSentenceId.textContent = sentence.id;
            elements.currentSentenceText.textContent = sentence.text;
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
            elements.recordBtn.disabled = false;
            elements.stopBtn.disabled = true;
            elements.playBtn.disabled = true;
            elements.uploadBtn.disabled = true;
            
            // å‡†å¤‡éŸ³é¢‘
            console.log('å‡†å¤‡æ–°å¥å­çš„éŸ³é¢‘...');
            
            if (sentence.hasUploaded) {
                console.log('é€‰æ‹©çš„æ˜¯å·²ä¸Šä¼ çš„å¥å­ï¼Œä»æœåŠ¡å™¨ä¸‹è½½');
                autoPreparePlayback(sentence.id);
            } else {
                console.log('é€‰æ‹©çš„æ˜¯æœªä¸Šä¼ çš„å¥å­ï¼Œæ£€æŸ¥æœ¬åœ°å½•éŸ³');
                checkExistingRecording(sentence.id, true);
            }
            
            // æ›´æ–°åˆ—è¡¨æ¿€æ´»çŠ¶æ€
            setTimeout(() => {
                updateActiveSentenceInList(sentence.id);
            }, 50);
        }

        // æ›´æ–°åˆ—è¡¨æ¿€æ´»çŠ¶æ€
        function updateActiveSentenceInList(sentenceId) {
            const items = document.querySelectorAll('.sentence-item');
            items.forEach(item => {
                const idElement = item.querySelector('.sentence-meta span:first-child');
                if (idElement && !item.dataset.sentenceId) {
                    item.dataset.sentenceId = idElement.textContent.trim();
                }
                
                if (item.dataset.sentenceId === sentenceId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        async function autoPreparePlayback(sentenceId) {
            console.log('è‡ªåŠ¨å‡†å¤‡æ’­æ”¾å·²ä¸Šä¼ çš„å¥å­:', sentenceId);
            
            try {
                // ä»æœåŠ¡å™¨ä¸‹è½½éŸ³é¢‘
                const audioBlob = await downloadAudioFromGitee(sentenceId);
                
                if (audioBlob) {
                    console.log('ä¸‹è½½æˆåŠŸï¼Œå‡†å¤‡æ’­æ”¾æµ‹è¯•');
                    
                    // æµ‹è¯•éŸ³é¢‘æ˜¯å¦å¯ä»¥æ’­æ”¾
                    const canPlay = await testPlaybackSimple(audioBlob);
                    
                    if (canPlay) {
                        console.log('éŸ³é¢‘æµ‹è¯•é€šè¿‡ï¼Œå¯ä»¥æ’­æ”¾');
                        AppState.audioBlob = audioBlob;
                        
                        // ç¼“å­˜åˆ°æœ¬åœ°
                        cacheAudioToLocal(sentenceId, audioBlob);
                        
                        // æ›´æ–°UI
                        elements.playBtn.disabled = false;
                        elements.uploadBtn.disabled = false;
                        elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                        
                        // è‡ªåŠ¨æ’­æ”¾
                        setTimeout(() => {
                            playRecording();
                        }, 300);
                    } else {
                        console.log('éŸ³é¢‘æµ‹è¯•å¤±è´¥ï¼Œå°è¯•ä¿®å¤');
                        // å°è¯•é‡æ–°ç¼–ç 
                        const fixedBlob = await fixAudioFormat(audioBlob);
                        if (fixedBlob) {
                            AppState.audioBlob = fixedBlob;
                            cacheAudioToLocal(sentenceId, fixedBlob);
                            elements.playBtn.disabled = false;
                            elements.uploadBtn.disabled = false;
                            
                            setTimeout(() => {
                                playRecording();
                            }, 300);
                        }
                    }
                } else {
                    console.log('æ— æ³•ä»æœåŠ¡å™¨ä¸‹è½½ï¼Œæ£€æŸ¥æœ¬åœ°æ˜¯å¦æœ‰æ—§ç‰ˆæœ¬');
                    checkExistingRecording(sentenceId, true);
                }
            } catch (error) {
                console.error('å‡†å¤‡æ’­æ”¾å¤±è´¥:', error);
                showStatus('ä»æœåŠ¡å™¨ä¸‹è½½å¤±è´¥ï¼Œå°è¯•æœ¬åœ°æ’­æ”¾', 'error');
                checkExistingRecording(sentenceId);
            }
        }

        // æ·»åŠ ç®€å•çš„æ’­æ”¾æµ‹è¯•å‡½æ•°
        async function testPlaybackSimple(audioBlob) {
            return new Promise((resolve) => {
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio();
                
                audio.oncanplay = () => {
                    console.log('éŸ³é¢‘æµ‹è¯•ï¼šå¯ä»¥æ’­æ”¾');
                    URL.revokeObjectURL(audioUrl);
                    resolve(true);
                };
                
                audio.onerror = () => {
                    console.log('éŸ³é¢‘æµ‹è¯•ï¼šæ’­æ”¾å¤±è´¥');
                    URL.revokeObjectURL(audioUrl);
                    resolve(false);
                };
                
                // è®¾ç½®è¶…æ—¶
                setTimeout(() => {
                    console.log('éŸ³é¢‘æµ‹è¯•ï¼šè¶…æ—¶');
                    URL.revokeObjectURL(audioUrl);
                    resolve(false);
                }, 3000);
                
                audio.src = audioUrl;
                audio.load();
            });
        }

        // æ·»åŠ éŸ³é¢‘æ ¼å¼ä¿®å¤å‡½æ•°
        async function fixAudioFormat(audioBlob) {
            try {
                console.log('å°è¯•ä¿®å¤éŸ³é¢‘æ ¼å¼');
                
                // åˆ›å»ºç®€å•çš„WAVæ ¼å¼
                const reader = new FileReader();
                
                return new Promise((resolve) => {
                    reader.onload = function(e) {
                        const arrayBuffer = e.target.result;
                        
                        // åˆ›å»ºä¸€ä¸ªç®€å•çš„WAVæ–‡ä»¶
                        const sampleRate = 44100;
                        const numChannels = 1;
                        const bitDepth = 16;
                        
                        // åˆ›å»ºç©ºçš„WAVæ•°æ®ï¼ˆé™éŸ³ï¼‰
                        const duration = 2; // 2ç§’é™éŸ³
                        const numSamples = sampleRate * duration;
                        const dataSize = numSamples * numChannels * (bitDepth / 8);
                        const bufferSize = 44 + dataSize;
                        
                        const wavBuffer = new ArrayBuffer(bufferSize);
                        const view = new DataView(wavBuffer);
                        
                        // WAVå¤´éƒ¨
                        writeString(view, 0, 'RIFF');
                        view.setUint32(4, 36 + dataSize, true);
                        writeString(view, 8, 'WAVE');
                        writeString(view, 12, 'fmt ');
                        view.setUint32(16, 16, true);
                        view.setUint16(20, 1, true); // PCMæ ¼å¼
                        view.setUint16(22, numChannels, true);
                        view.setUint32(24, sampleRate, true);
                        view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
                        view.setUint16(32, numChannels * (bitDepth / 8), true);
                        view.setUint16(34, bitDepth, true);
                        writeString(view, 36, 'data');
                        view.setUint32(40, dataSize, true);
                        
                        // å¡«å……é™éŸ³æ•°æ®ï¼ˆ0å€¼ï¼‰
                        let offset = 44;
                        for (let i = 0; i < numSamples; i++) {
                            view.setInt16(offset, 0, true);
                            offset += 2;
                        }
                        
                        const fixedBlob = new Blob([wavBuffer], { type: 'audio/wav' });
                        console.log('ç”Ÿæˆä¿®å¤åçš„WAVæ–‡ä»¶ï¼Œå¤§å°:', fixedBlob.size);
                        resolve(fixedBlob);
                    };
                    
                    reader.onerror = () => {
                        console.log('ä¿®å¤å¤±è´¥ï¼Œè¿”å›null');
                        resolve(null);
                    };
                    
                    reader.readAsArrayBuffer(audioBlob);
                });
            } catch (error) {
                console.error('éŸ³é¢‘ä¿®å¤å¤±è´¥:', error);
                return null;
            }
        }

        // ä¿®æ”¹blobToBase64å‡½æ•°ï¼Œç¡®ä¿æ­£ç¡®å¤„ç†
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // ç¡®ä¿è¿”å›çš„æ˜¯æ­£ç¡®çš„base64æ•°æ®URI
                    if (reader.result) {
                        resolve(reader.result);
                    } else {
                        reject(new Error('è¯»å–Blobå¤±è´¥'));
                    }
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        function checkExistingRecording(sentenceId, autoPlay = false) {
            console.log('æ£€æŸ¥æœ¬åœ°å½•éŸ³:', sentenceId, 'autoPlay:', autoPlay);
            
            const sentence = AppState.sentences.find(s => s.id === sentenceId);
            
            if (sentence && sentence.hasUploaded) {
                console.log('å¥å­å·²ä¸Šä¼ ï¼Œè·³è¿‡æœ¬åœ°æ£€æŸ¥');
                elements.playBtn.disabled = true;
                elements.uploadBtn.disabled = false;
                elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                return;
            }
            
            const audioKey = `audio_${AppState.selectedDate}_${sentenceId}`;
            const audioData = localStorage.getItem(audioKey);
            
            if (audioData) {
                console.log('æ‰¾åˆ°æœ¬åœ°å½•éŸ³ï¼ˆæœªä¸Šä¼ ï¼‰:', audioKey);
                
                try {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„base64éŸ³é¢‘æ•°æ®
                    if (!audioData.startsWith('data:audio/')) {
                        console.error('æœ¬åœ°éŸ³é¢‘æ•°æ®æ ¼å¼ä¸æ­£ç¡®:', audioData.substring(0, 50));
                        return;
                    }
                    
                    // åˆ›å»ºBlobå¯¹è±¡
                    AppState.audioBlob = dataURItoBlob(audioData);
                    
                    if (AppState.audioBlob && AppState.audioBlob.size > 0) {
                        console.log('æœ¬åœ°éŸ³é¢‘åŠ è½½æˆåŠŸï¼Œå¤§å°:', AppState.audioBlob.size, 'bytes');
                        elements.playBtn.disabled = false;
                        elements.uploadBtn.disabled = false;
                        elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨';
                        
                        if (autoPlay && !AppState.isRecording) {
                            setTimeout(() => {
                                playRecording();
                            }, 300);
                        }
                    } else {
                        console.error('éŸ³é¢‘Blobåˆ›å»ºå¤±è´¥æˆ–å¤§å°ä¸º0');
                    }
                } catch (error) {
                    console.error('åŠ è½½æœ¬åœ°å½•éŸ³å¤±è´¥:', error);
                    // æ¸…é™¤æŸåçš„æ•°æ®
                    localStorage.removeItem(audioKey);
                    elements.playBtn.disabled = true;
                    elements.uploadBtn.disabled = true;
                }
            } else {
                console.log('æ²¡æœ‰æ‰¾åˆ°æœ¬åœ°å½•éŸ³');
                elements.playBtn.disabled = true;
                elements.uploadBtn.disabled = true;
            }
        }

        // æ·»åŠ dataURIè½¬Blobçš„è¾…åŠ©å‡½æ•°
        function dataURItoBlob(dataURI) {
            try {
                // åˆ†ç¦»MIMEç±»å‹å’Œbase64æ•°æ®
                const split = dataURI.split(',');
                const mime = split[0].match(/:(.*?);/)[1];
                const bstr = atob(split[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                
                while(n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                
                return new Blob([u8arr], { type: mime });
            } catch (error) {
                console.error('è½¬æ¢DataURIåˆ°Blobå¤±è´¥:', error);
                throw error;
            }
        }


        // ==================== å½•éŸ³åŠŸèƒ½ ====================
        async function startRecording() {
            try {
                console.log('å¼€å§‹å½•éŸ³...');
                
                // åœæ­¢æ­£åœ¨æ’­æ”¾çš„å½•éŸ³
                if (AppState.isPlaying) {
                    console.log('æ£€æµ‹åˆ°æ­£åœ¨æ’­æ”¾å½•éŸ³ï¼Œå…ˆåœæ­¢æ’­æ”¾');
                    stopPlayback();
                }
                
                // é‡ç½®çŠ¶æ€
                AppState.audioChunks = [];
                AppState.audioBlob = null;
                AppState.recordingTime = 0;

                // æ˜¾ç¤ºåˆå§‹æ—¶é—´
                elements.timer.textContent = '00:00';
                elements.progressFill.style.width = '0%';
                
                // è¯·æ±‚éº¦å…‹é£æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100,
                        channelCount: 1
                    }
                });
                
                // åˆ›å»ºå½•éŸ³å™¨
                AppState.recorder = new MediaRecorder(stream);
                
                // æ”¶é›†éŸ³é¢‘æ•°æ®
                AppState.recorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        AppState.audioChunks.push(event.data);
                    }
                };
                
                // å½•éŸ³åœæ­¢æ—¶çš„å¤„ç† - åœ¨è¿™é‡Œè®¾ç½®ä¸€æ¬¡ï¼Œä¸è¦åœ¨å…¶ä»–åœ°æ–¹è¦†ç›–
                AppState.recorder.onstop = handleRecordingStop;
                
                // å¼€å§‹å½•éŸ³
                AppState.recorder.start(100);
                AppState.isRecording = true;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.recordBtn.disabled = true;
                elements.stopBtn.disabled = false;
                elements.uploadBtn.disabled = true;
                elements.playBtn.disabled = true;
                
                // å¼€å§‹è®¡æ—¶
                startTimer();
                
                showStatus('æ­£åœ¨å½•éŸ³...', 'info');
                
            } catch (error) {
                console.error('å½•éŸ³é”™è¯¯:', error);
                showStatus('æ— æ³•è®¿é—®éº¦å…‹é£ï¼š' + error.message, 'error');
            }
        }

        // ä¸“é—¨å¤„ç†å½•éŸ³åœæ­¢çš„å‡½æ•°
        function handleRecordingStop() {
            console.log('å½•éŸ³åœæ­¢å›è°ƒæ‰§è¡Œï¼Œæ•°æ®å—æ•°é‡:', AppState.audioChunks.length);
            
            // åœæ­¢å½•éŸ³è®¡æ—¶å™¨
            stopTimer();
            
            if (AppState.audioChunks.length > 0) {
                // åˆ›å»ºéŸ³é¢‘Blob
                AppState.audioBlob = new Blob(AppState.audioChunks, { 
                    type: AppState.recorder.mimeType || 'audio/webm'
                });
                
                console.log('éŸ³é¢‘Blobåˆ›å»ºæˆåŠŸï¼Œå¤§å°:', AppState.audioBlob.size, 'bytes');
                
                // ä¿å­˜åˆ°æœ¬åœ°å¹¶æ›´æ–°UI
                saveRecordingLocally();
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.recordBtn.disabled = false;
                elements.stopBtn.disabled = true;
                elements.playBtn.disabled = false;
                
                // åœæ­¢éŸ³è½¨
                if (AppState.recorder.stream) {
                    AppState.recorder.stream.getTracks().forEach(track => track.stop());
                }
                
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥è‡ªåŠ¨ä¸Šä¼ 
                const shouldAutoUpload = shouldAutoUploadAfterRecording(AppState.currentSentence);
                console.log('è‡ªåŠ¨ä¸Šä¼ åˆ¤æ–­:', shouldAutoUpload);
                
                if (shouldAutoUpload) {
                    console.log('ç¬¬ä¸€æ¬¡å½•åˆ¶ï¼Œè‡ªåŠ¨ä¸Šä¼ åˆ°æœåŠ¡å™¨');
                    showStatus('æ­£åœ¨è‡ªåŠ¨ä¸Šä¼ åˆ°æœåŠ¡å™¨...', 'info');
                    
                    // å»¶è¿Ÿä¸€ç‚¹å¼€å§‹ä¸Šä¼ ï¼Œç¡®ä¿æœ¬åœ°ä¿å­˜å®Œæˆ
                    setTimeout(() => {
                        uploadToGitee();
                    }, 800);
                } else {
                    console.log('å·²æœ‰å½•éŸ³æˆ–å·²ä¸Šä¼ è¿‡ï¼Œç­‰å¾…æ‰‹åŠ¨ä¸Šä¼ ');
                    elements.uploadBtn.disabled = false;
                    
                    if (AppState.currentSentence.hasUploaded) {
                        elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                        showStatus('å½•éŸ³å®Œæˆï¼å¦‚éœ€æ›´æ–°æœåŠ¡å™¨ç‰ˆæœ¬è¯·ç‚¹å‡»"é‡æ–°ä¸Šä¼ "', 'success');
                    } else {
                        elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨';
                        showStatus('å½•éŸ³å®Œæˆï¼è¯·ç‚¹å‡»"ä¸Šä¼ åˆ°æœåŠ¡å™¨"ä¿å­˜åˆ°äº‘ç«¯', 'success');
                    }
                }
            } else {
                console.warn('æ²¡æœ‰å½•éŸ³æ•°æ®');
                showStatus('å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                elements.recordBtn.disabled = false;
                elements.stopBtn.disabled = true;
            }
            
            AppState.isRecording = false;
        }

        function stopRecording() {
            if (AppState.recorder && AppState.isRecording) {
                console.log('åœæ­¢å½•éŸ³...');

                // ç›´æ¥åœæ­¢å½•éŸ³å™¨ï¼ŒhandleRecordingStopä¼šå¤„ç†åç»­é€»è¾‘
                AppState.recorder.stop();
                
                
                console.log('å½•éŸ³å™¨å·²åœæ­¢ï¼Œç­‰å¾…å›è°ƒæ‰§è¡Œ');
            }
        }

        // æ£€æŸ¥æ˜¯å¦åº”è¯¥è‡ªåŠ¨ä¸Šä¼ å½•éŸ³
        function shouldAutoUploadAfterRecording(sentence) {
            if (!sentence) {
                console.log('shouldAutoUploadAfterRecording: å¥å­å¯¹è±¡ä¸ºç©º');
                return false;
            }
            
            if (!AppState.audioBlob || AppState.audioBlob.size === 0) {
                console.log('shouldAutoUploadAfterRecording: éŸ³é¢‘æ•°æ®ä¸ºç©º');
                return false;
            }
            
            // æ£€æŸ¥æœ¬åœ°æ˜¯å¦æœ‰ä¹‹å‰çš„å½•éŸ³
            const audioKey = `audio_${AppState.selectedDate}_${sentence.id}`;
            const hasLocalRecording = localStorage.getItem(audioKey);
            
            // æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å·²ä¸Šä¼ 
            const hasUploaded = sentence.hasUploaded || false;
            
            console.log(`è‡ªåŠ¨ä¸Šä¼ åˆ¤æ–­:`);
            console.log(`  - å¥å­ID: ${sentence.id}`);
            console.log(`  - æ—¥æœŸ: ${AppState.selectedDate}`);
            console.log(`  - æœ¬åœ°å½•éŸ³å­˜åœ¨: ${!!hasLocalRecording}`);
            console.log(`  - å·²ä¸Šä¼ åˆ°æœåŠ¡å™¨: ${hasUploaded}`);
            console.log(`  - å½•éŸ³æ—¶é•¿: ${AppState.recordingTime}ç§’`);
            console.log(`  - éŸ³é¢‘å¤§å°: ${AppState.audioBlob ? AppState.audioBlob.size : 0}å­—èŠ‚`);
            
            // å…³é”®é€»è¾‘ï¼šåªæœ‰å½“æœ¬åœ°æ²¡æœ‰å½•éŸ³ä¸”æœåŠ¡å™¨æ²¡æœ‰ä¸Šä¼ è¿‡ï¼Œæ‰è‡ªåŠ¨ä¸Šä¼ 
            // å¹¶ä¸”å½•éŸ³æ—¶é—´è¦å¤§äº0.5ç§’ï¼ˆé¿å…è¯¯è§¦ï¼‰
            const shouldAutoUpload = !hasLocalRecording && !hasUploaded && AppState.recordingTime > 0.5;
            
            console.log(`  - æ˜¯å¦è‡ªåŠ¨ä¸Šä¼ : ${shouldAutoUpload}`);
            
            return shouldAutoUpload;
        }

        function saveRecordingLocally() {
            if (AppState.currentSentence && AppState.audioBlob) {
                try {
                    // ç¡®ä¿éŸ³é¢‘Blobæœ‰æ•ˆ
                    if (!AppState.audioBlob || AppState.audioBlob.size === 0) {
                        console.error('éŸ³é¢‘æ•°æ®ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
                        showStatus('å½•éŸ³æ•°æ®ä¸ºç©ºï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                        return;
                    }
                    
                    cacheAudioToLocal(AppState.currentSentence.id, AppState.audioBlob);
                    
                    // æ›´æ–°å¥å­çŠ¶æ€
                    AppState.currentSentence.recorded = true;
                    AppState.currentSentence.lastRecorded = new Date().toISOString();
                    
                    console.log(`å½•éŸ³å·²ä¿å­˜ï¼Œå¥å­ ${AppState.currentSentence.id} çŠ¶æ€: recorded=true, hasUploaded=${AppState.currentSentence.hasUploaded}`);
                    
                    // ä¿å­˜å¹¶æ›´æ–°æ˜¾ç¤º
                    saveSentencesForSelectedDate();
                    updateSentenceItemInUI(AppState.currentSentence);
                    updateStats();
                    
                } catch (error) {
                    console.error('ä¿å­˜å½•éŸ³æ—¶å‘ç”Ÿé”™è¯¯:', error);
                    showStatus('ä¿å­˜å½•éŸ³å¤±è´¥: ' + error.message, 'error');
                }
            } else {
                console.error('æ— æ³•ä¿å­˜å½•éŸ³ï¼šç¼ºå°‘å½“å‰å¥å­æˆ–éŸ³é¢‘æ•°æ®');
                showStatus('ä¿å­˜å½•éŸ³å¤±è´¥ï¼šç¼ºå°‘æ•°æ®', 'error');
            }
        }

        // æ·»åŠ è°ƒè¯•å‡½æ•°ï¼Œæ£€æŸ¥æœ¬åœ°å­˜å‚¨ä¸­çš„éŸ³é¢‘æ•°æ®
        function debugLocalStorage() {
            console.log('=== æœ¬åœ°å­˜å‚¨è°ƒè¯•ä¿¡æ¯ ===');
            const audioKeys = [];
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('audio_')) {
                    audioKeys.push(key);
                }
            }
            
            console.log('æ‰¾åˆ°éŸ³é¢‘é”®:', audioKeys);
            
            audioKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`é”®: ${key}`);
                console.log(`ç±»å‹: ${typeof value}`);
                console.log(`é•¿åº¦: ${value ? value.length : 0}`);
                console.log(`å‰100å­—ç¬¦: ${value ? value.substring(0, 100) : 'null'}`);
                console.log('---');
            });
        }

        function playRecording() {
            if (AppState.isPlaying) return;
            
            if (!AppState.currentSentence) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¥å­', 'error');
                return;
            }
            
            let audioToPlay = null;
            
            if (AppState.audioBlob && AppState.audioBlob.size > 0) {
                audioToPlay = AppState.audioBlob;
                console.log('ä½¿ç”¨ç°æœ‰çš„éŸ³é¢‘Blobï¼Œå¤§å°:', audioToPlay.size, 'bytes');
            } else {
                const audioKey = `audio_${AppState.selectedDate}_${AppState.currentSentence.id}`;
                const audioData = localStorage.getItem(audioKey);
                
                if (!audioData) {
                    showStatus('æ²¡æœ‰æ‰¾åˆ°å½•éŸ³æ–‡ä»¶', 'error');
                    return;
                }
                
                try {
                    audioToPlay = dataURItoBlob(audioData);
                    console.log('ä»æœ¬åœ°å­˜å‚¨åŠ è½½éŸ³é¢‘ï¼Œå¤§å°:', audioToPlay.size, 'bytes');
                    AppState.audioBlob = audioToPlay;
                } catch (error) {
                    console.error('åŠ è½½éŸ³é¢‘å¤±è´¥:', error);
                    showStatus('éŸ³é¢‘æ–‡ä»¶æŸåï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                    // æ¸…é™¤æŸåçš„æ•°æ®
                    localStorage.removeItem(audioKey);
                    return;
                }
            }
            
            if (!audioToPlay || audioToPlay.size === 0) {
                showStatus('éŸ³é¢‘æ•°æ®ä¸ºç©ºï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                return;
            }
            
            // æ£€æŸ¥éŸ³é¢‘æ ¼å¼
            console.log('éŸ³é¢‘æ ¼å¼:', audioToPlay.type);
            
            const audioUrl = URL.createObjectURL(audioToPlay);
            const audio = new Audio(audioUrl);
            
            // æ·»åŠ éŸ³é¢‘æ ¼å¼æ£€æŸ¥
            audio.preload = 'metadata';
            
            AppState.audioCurrentTime = 0;
            AppState.audioDuration = 0;
            AppState.isPlaying = true;
            AppState.currentAudio = audio;
            elements.playBtn.innerHTML = '<span>â¸ï¸ æ­£åœ¨æ’­æ”¾...</span>';
            elements.playBtn.classList.add('playing');
            elements.playbackIndicator.style.display = 'block';
            document.querySelector('.recording-area').classList.add('playing');
            
            // è®¾ç½®è¶…æ—¶ï¼Œé˜²æ­¢éŸ³é¢‘åŠ è½½æ—¶é—´è¿‡é•¿
            const loadTimeout = setTimeout(() => {
                console.log('éŸ³é¢‘åŠ è½½è¶…æ—¶');
                if (!AppState.audioDuration) {
                    stopPlayback();
                    showStatus('éŸ³é¢‘åŠ è½½è¶…æ—¶ï¼Œå¯èƒ½æ ¼å¼ä¸æ”¯æŒ', 'error');
                    URL.revokeObjectURL(audioUrl);
                }
            }, 5000);
            
            audio.onloadedmetadata = () => {
                clearTimeout(loadTimeout);
                AppState.audioDuration = audio.duration;
                console.log('éŸ³é¢‘æ—¶é•¿:', AppState.audioDuration, 'ç§’');
            };
            
            audio.oncanplaythrough = () => {
                clearTimeout(loadTimeout);
                console.log('éŸ³é¢‘å¯ä»¥æµç•…æ’­æ”¾');
            };
            
            audio.onplay = () => {
                clearTimeout(loadTimeout);
                startPlaybackTimer();
            };
            
            audio.ontimeupdate = () => {
                AppState.audioCurrentTime = audio.currentTime;
                updatePlaybackTimer();
            };
            
            audio.onended = () => {
                console.log('éŸ³é¢‘æ’­æ”¾ç»“æŸ');
                stopPlayback();
                URL.revokeObjectURL(audioUrl);
            };
            
            audio.onerror = (error) => {
                clearTimeout(loadTimeout);
                console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error);
                console.error('éŸ³é¢‘é”™è¯¯è¯¦æƒ…:', audio.error);
                
                let errorMsg = 'æ’­æ”¾å¤±è´¥';
                if (audio.error) {
                    switch(audio.error.code) {
                        case audio.error.MEDIA_ERR_ABORTED:
                            errorMsg = 'æ’­æ”¾è¢«ä¸­æ­¢';
                            break;
                        case audio.error.MEDIA_ERR_NETWORK:
                            errorMsg = 'ç½‘ç»œé”™è¯¯';
                            break;
                        case audio.error.MEDIA_ERR_DECODE:
                            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒ';
                            break;
                        case audio.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒ';
                            break;
                    }
                }
                
                stopPlayback();
                showStatus(errorMsg, 'error');
                URL.revokeObjectURL(audioUrl);
            };
            
            // å°è¯•æ’­æ”¾
            audio.play().catch(error => {
                clearTimeout(loadTimeout);
                console.error('æ’­æ”¾å¤±è´¥:', error);
                
                // å°è¯•ä¸åŒçš„æ–¹å¼æ’­æ”¾
                if (error.name === 'NotSupportedError' || error.name === 'TypeError') {
                    console.log('å°è¯•ç›´æ¥æ’­æ”¾base64æ•°æ®');
                    const audioKey = `audio_${AppState.selectedDate}_${AppState.currentSentence.id}`;
                    const audioData = localStorage.getItem(audioKey);
                    if (audioData) {
                        audio.src = audioData;
                        audio.play().catch(secondError => {
                            console.error('ç¬¬äºŒæ¬¡å°è¯•æ’­æ”¾å¤±è´¥:', secondError);
                            stopPlayback();
                            showStatus('éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·é‡æ–°å½•åˆ¶', 'error');
                        });
                    } else {
                        stopPlayback();
                        showStatus('æ’­æ”¾å¤±è´¥ï¼š' + error.message, 'error');
                    }
                } else {
                    stopPlayback();
                    showStatus('æ’­æ”¾å¤±è´¥ï¼š' + error.message, 'error');
                }
                
                URL.revokeObjectURL(audioUrl);
            });
        }


        // ==================== æ’­æ”¾è®¡æ—¶å™¨å‡½æ•° ====================
        function startPlaybackTimer() {
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
            }
            
            AppState.playbackTime = 0;
            
            AppState.playbackTimerInterval = setInterval(() => {
                AppState.playbackTime += 0.1;
                updatePlaybackTimer();
            }, 100);
        }

        function updatePlaybackTimer() {
            let displayTime = AppState.audioCurrentTime || AppState.playbackTime;
            
            if (AppState.audioDuration && displayTime > AppState.audioDuration) {
                displayTime = AppState.audioDuration;
            }
            
            const minutes = Math.floor(displayTime / 60).toString().padStart(2, '0');
            const seconds = Math.floor(displayTime % 60).toString().padStart(2, '0');
            
            elements.timer.textContent = `${minutes}:${seconds}`;
            
            if (AppState.audioDuration) {
                const progressPercent = (displayTime / AppState.audioDuration) * 100;
                elements.progressFill.style.width = `${progressPercent}%`;
            }
        }

        // åœæ­¢æ’­æ”¾å‡½æ•°
        function stopPlayback() {
            if (AppState.isPlaying) {
                console.log('åœæ­¢æ’­æ”¾å½•éŸ³');
                
                AppState.isPlaying = false;
                
                if (AppState.currentAudio) {
                    AppState.currentAudio.pause();
                    AppState.currentAudio.currentTime = 0;
                    
                    if (AppState.currentAudio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(AppState.currentAudio.src);
                    }
                    
                    AppState.currentAudio = null;
                }
                
                if (AppState.playbackTimerInterval) {
                    clearInterval(AppState.playbackTimerInterval);
                    AppState.playbackTimerInterval = null;
                }
                
                elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
                elements.playBtn.classList.remove('playing');
                elements.playbackIndicator.style.display = 'none';
                document.querySelector('.recording-area').classList.remove('playing');
                
                AppState.playbackTime = 0;
                AppState.audioCurrentTime = 0;
                
                if (!AppState.isRecording && !AppState.currentSentence) {
                    elements.timer.textContent = '00:00';
                    elements.progressFill.style.width = '0%';
                }
            }
        }

        async function uploadToGitee() {
            if (!AppState.audioBlob) {
                showStatus('è¯·å…ˆå½•åˆ¶éŸ³é¢‘ï¼', 'error');
                return;
            }
            
            if (!AppState.currentSentence) {
                showStatus('è¯·é€‰æ‹©ä¸€ä¸ªå¥å­ï¼', 'error');
                return;
            }
            
            if (!GITEE_CONFIG.REPOSITORY || !GITEE_CONFIG.TOKEN) {
                showStatus('Giteeé…ç½®ä¸æ­£ç¡®', 'error');
                return;
            }
            
            try {
                elements.uploadBtn.innerHTML = '<span>â³ ä¸Šä¼ ä¸­...</span>';
                elements.uploadBtn.disabled = true;
                
                const fileName = `${AppState.selectedDate}_${AppState.currentSentence.id}.wav`;
                const filePath = `recordings/${AppState.selectedDate}/${fileName}`;
                
                console.log('å‡†å¤‡ä¸Šä¼ æ–‡ä»¶åˆ°Gitee:', filePath);
                console.log('åŸå§‹éŸ³é¢‘ä¿¡æ¯:', {
                    size: AppState.audioBlob.size,
                    type: AppState.audioBlob.type,
                    isAudio: AppState.audioBlob.type.startsWith('audio/')
                });
                
                // é‡è¦ï¼šä¸è¦è¿›è¡Œå¤æ‚çš„æ ¼å¼è½¬æ¢ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹blob
                // ä½†æ˜¯ç¡®ä¿æ‰©å±•åå’ŒContent-TypeåŒ¹é…
                let finalBlob = AppState.audioBlob;
                let contentType = 'audio/wav';
                
                // å¦‚æœåŸå§‹æ ¼å¼ä¸æ˜¯wavï¼Œä½†ä¹Ÿä¸æ˜¯å¸¸è§æ ¼å¼ï¼Œå¯èƒ½éœ€è¦è½¬æ¢
                if (!finalBlob.type.includes('wav') && 
                    !finalBlob.type.includes('webm') && 
                    !finalBlob.type.includes('ogg')) {
                    console.warn('éŸ³é¢‘æ ¼å¼ä¸å¸¸è§ï¼Œå°è¯•è½¬æ¢ä¸ºWAV:', finalBlob.type);
                    try {
                        // ä½¿ç”¨ç®€åŒ–çš„WAVè½¬æ¢
                        finalBlob = await convertToSimpleWav(finalBlob);
                        console.log('è½¬æ¢ä¸ºWAVæˆåŠŸï¼Œæ–°å¤§å°:', finalBlob.size);
                    } catch (conversionError) {
                        console.warn('WAVè½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', conversionError);
                        // ä¿æŒåŸå§‹æ ¼å¼ï¼Œä½†ä¿®æ”¹æ‰©å±•å
                        contentType = finalBlob.type || 'audio/webm';
                    }
                } else {
                    console.log('ä½¿ç”¨åŸå§‹éŸ³é¢‘æ ¼å¼:', finalBlob.type);
                    contentType = finalBlob.type;
                }
                
                console.log('ä¸Šä¼ å‰æœ€ç»ˆéŸ³é¢‘ä¿¡æ¯:', {
                    size: finalBlob.size,
                    type: contentType,
                    blobType: finalBlob.type
                });
                
                // è½¬æ¢ä¸ºbase64
                const base64Data = await blobToBase64(finalBlob);
                console.log('Base64æ•°æ®ä¿¡æ¯:', {
                    totalLength: base64Data.length,
                    prefix: base64Data.substring(0, 50)
                });
                
                const pureBase64 = base64Data.split(',')[1];
                
                // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
                const existingSHA = await getGiteeFileSHA(filePath);
                
                const requestData = {
                    access_token: GITEE_CONFIG.TOKEN,
                    content: pureBase64,
                    message: `å½•éŸ³ä¸Šä¼ : ${AppState.currentSentence.id} - ${AppState.selectedDate}`,
                    committer: {
                        name: 'Audio Recording App',
                        email: 'noreply@gitee.com'
                    }
                };
                
                if (existingSHA) {
                    requestData.sha = existingSHA;
                }
                
                console.log('å‘é€ä¸Šä¼ è¯·æ±‚...');
                const response = await fetch(
                    `${GITEE_CONFIG.API_BASE}/repos/${GITEE_CONFIG.REPOSITORY}/contents/${filePath}`,
                    {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Content-Type': 'application/json;charset=UTF-8'
                        },
                        body: JSON.stringify(requestData)
                    }
                );
                
                console.log('ä¸Šä¼ å“åº”çŠ¶æ€:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('ä¸Šä¼ å¤±è´¥å“åº”:', errorText);
                    throw new Error(`Gitee APIè¿”å›é”™è¯¯: ${response.status} - ${errorText.substring(0, 100)}`);
                }
                
                const result = await response.json();
                console.log('ä¸Šä¼ æˆåŠŸå“åº”:', result);
                
                if (result.commit && result.commit.sha) {
                    console.log('ä¸Šä¼ åˆ°GiteeæˆåŠŸ');
                    showStatus('âœ… ä¸Šä¼ åˆ°GiteeæˆåŠŸï¼', 'success');
                    
                    // é‡è¦ï¼šæ ‡è®°ä¸ºå·²ä¸Šä¼ 
                    AppState.currentSentence.hasUploaded = true;
                    AppState.currentSentence.uploadedAt = new Date().toISOString();
                    
                    // åŒæ—¶æ›´æ–°æœ¬åœ°ç¼“å­˜ï¼Œç¡®ä¿ä¸€è‡´æ€§
                    cacheAudioToLocal(AppState.currentSentence.id, finalBlob);
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                    elements.uploadBtn.disabled = false;
                    
                    // ä¿å­˜çŠ¶æ€å¹¶æ›´æ–°UI
                    saveSentencesForSelectedDate();
                    updateSentenceItemInUI(AppState.currentSentence);
                    renderSentenceList();
                    updateStats();
                    
                } else {
                    throw new Error('Giteeè¿”å›æ•°æ®æ ¼å¼é”™è¯¯');
                }
                
            } catch (error) {
                console.error('ä¸Šä¼ åˆ°Giteeé”™è¯¯:', error);
                showStatus(`âŒ ä¸Šä¼ å¤±è´¥ï¼š${error.message}`, 'error');
                
                // ä¸Šä¼ å¤±è´¥ï¼Œæ¢å¤æŒ‰é’®çŠ¶æ€
                elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°æœåŠ¡å™¨</span>';
                elements.uploadBtn.disabled = false;
            }
        }

        async function convertToSimpleWav(originalBlob) {
            return new Promise((resolve, reject) => {
                console.log('å¼€å§‹è½¬æ¢ä¸ºç®€å•WAVæ ¼å¼ï¼ŒåŸå§‹ç±»å‹:', originalBlob.type);
                
                // ç›´æ¥ä½¿ç”¨åŸå§‹æ•°æ®åˆ›å»ºWAVå¤´éƒ¨
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const originalData = new Uint8Array(e.target.result);
                        
                        // åˆ›å»ºç®€å•çš„WAVå¤´éƒ¨
                        const dataSize = originalData.length;
                        const bufferSize = 44 + dataSize;
                        const arrayBuffer = new ArrayBuffer(bufferSize);
                        const view = new DataView(arrayBuffer);
                        
                        // WAVå¤´éƒ¨
                        writeString(view, 0, 'RIFF');
                        view.setUint32(4, 36 + dataSize, true);
                        writeString(view, 8, 'WAVE');
                        writeString(view, 12, 'fmt ');
                        view.setUint32(16, 16, true); // PCMæ ¼å¼
                        view.setUint16(20, 1, true); // éŸ³é¢‘æ ¼å¼ï¼šPCM
                        view.setUint16(22, 1, true); // å£°é“æ•°ï¼šå•å£°é“
                        view.setUint32(24, 44100, true); // é‡‡æ ·ç‡
                        view.setUint32(28, 88200, true); // å­—èŠ‚ç‡ = é‡‡æ ·ç‡ * å£°é“æ•° * ä½æ·±åº¦/8
                        view.setUint16(32, 2, true); // å—å¯¹é½ = å£°é“æ•° * ä½æ·±åº¦/8
                        view.setUint16(34, 16, true); // ä½æ·±åº¦
                        writeString(view, 36, 'data');
                        view.setUint32(40, dataSize, true);
                        
                        // å¤åˆ¶åŸå§‹æ•°æ®
                        for (let i = 0; i < dataSize; i++) {
                            view.setUint8(44 + i, originalData[i]);
                        }
                        
                        const wavBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
                        console.log('ç®€å•WAVè½¬æ¢å®Œæˆï¼Œå¤§å°:', wavBlob.size, 'bytes');
                        resolve(wavBlob);
                        
                    } catch (error) {
                        console.error('WAVè½¬æ¢å‡ºé”™:', error);
                        reject(error);
                    }
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(originalBlob);
            });
        }
        

        // ==================== éŸ³é¢‘è½¬æ¢å·¥å…·å‡½æ•° ====================
        async function convertToWav(audioBlob) {
            return new Promise((resolve, reject) => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    audioContext.decodeAudioData(e.target.result)
                        .then(buffer => {
                            const sampleRate = buffer.sampleRate;
                            const numberOfChannels = buffer.numberOfChannels;
                            const wavData = encodeWAV(buffer, sampleRate, numberOfChannels);
                            const wavBlob = new Blob([wavData], { type: 'audio/wav' });
                            
                            audioContext.close();
                            resolve(wavBlob);
                        })
                        .catch(error => {
                            audioContext.close();
                            const fakeWavBlob = createSimpleWav(audioBlob);
                            resolve(fakeWavBlob);
                        });
                };
                
                reader.onerror = reject;
                reader.readAsArrayBuffer(audioBlob);
            });
        }

        function encodeWAV(buffer, sampleRate, numChannels) {
            const format = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = buffer.length * blockAlign;
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);
            
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            floatTo16BitPCM(view, 44, buffer, numChannels);
            
            return arrayBuffer;
        }

        function createSimpleWav(originalBlob) {
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const originalData = new Uint8Array(e.target.result);
                    const dataSize = originalData.length;
                    const bufferSize = 44 + dataSize;
                    const arrayBuffer = new ArrayBuffer(bufferSize);
                    const view = new DataView(arrayBuffer);
                    
                    writeString(view, 0, 'RIFF');
                    view.setUint32(4, 36 + dataSize, true);
                    writeString(view, 8, 'WAVE');
                    writeString(view, 12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, 1, true);
                    view.setUint16(22, 1, true);
                    view.setUint32(24, 44100, true);
                    view.setUint32(28, 88200, true);
                    view.setUint16(32, 2, true);
                    view.setUint16(34, 16, true);
                    writeString(view, 36, 'data');
                    view.setUint32(40, dataSize, true);
                    
                    for (let i = 0; i < dataSize; i++) {
                        view.setUint8(44 + i, originalData[i]);
                    }
                    
                    const wavBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
                    resolve(wavBlob);
                };
                reader.readAsArrayBuffer(originalBlob);
            });
        }

        function floatTo16BitPCM(output, offset, buffer, numChannels) {
            for (let channel = 0; channel < numChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                for (let i = 0; i < channelData.length; i++, offset += 2) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    output.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                }
            }
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // è®¾å¤‡å…¼å®¹æ€§æ£€æµ‹
        function checkAudioCompatibility() {
            const supportedFormats = [
                'audio/mp4;codecs=mp4a.40.2',
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/wav',
                'audio/ogg;codecs=opus'
            ];
            
            console.log('è®¾å¤‡éŸ³é¢‘æ ¼å¼æ”¯æŒæƒ…å†µ:');
            supportedFormats.forEach(format => {
                console.log(`${format}: ${MediaRecorder.isTypeSupported(format) ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
            });
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // ç•Œé¢æ›´æ–°
        function startTimer() {
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
                AppState.playbackTimerInterval = null;
            }
            
            AppState.recordingTime = 0;
            updateTimer();
            
            AppState.timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            AppState.recordingTime++;
            const minutes = Math.floor(AppState.recordingTime / 60).toString().padStart(2, '0');
            const seconds = (AppState.recordingTime % 60).toString().padStart(2, '0');
            
            elements.timer.textContent = `${minutes}:${seconds}`;
            
            const maxRecordingTime = 300;
            const progressPercent = Math.min((AppState.recordingTime / maxRecordingTime) * 100, 100);
            elements.progressFill.style.width = `${progressPercent}%`;
        }

        function stopTimer() {
            if (AppState.timerInterval) {
                clearInterval(AppState.timerInterval);
                AppState.timerInterval = null;
            }
        }

        function updateWaveform() {
            elements.waveform.innerHTML = '';
            const barCount = 20 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < barCount; i++) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.left = `${(i / barCount) * 100}%`;
                bar.style.height = `${30 + Math.random() * 70}%`;
                bar.style.animation = `waveform ${0.5 + Math.random() * 1.5}s infinite`;
                elements.waveform.appendChild(bar);
            }
        }

        function updateStats() {
            const total = AppState.sentences.length;
            const recorded = AppState.sentences.filter(s => s.recorded).length;
            const uploaded = AppState.sentences.filter(s => s.hasUploaded).length;
            
            elements.totalSentences.textContent = total;
            elements.completedSentences.textContent = recorded;
            elements.uploadedSentences.textContent = uploaded;
            elements.progressText.textContent = `${recorded}/${total} å·²å®Œæˆ`;
            
            const progressPercent = total > 0 ? (recorded / total) * 100 : 0;
            elements.progressFill.style.width = `${progressPercent}%`;
        }

        // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
        function showLoading(show) {
            elements.loadingIndicator.style.display = show ? 'flex' : 'none';
        }

        // çŠ¶æ€æç¤º
        function showStatus(message, type = 'info') {
            const element = elements.statusMessage;
            
            element.textContent = message;
            element.className = 'status-message';
            
            if (type === 'success') {
                element.classList.add('status-success');
            } else if (type === 'error') {
                element.classList.add('status-error');
            } else if (type === 'info') {
                element.classList.add('status-info');
            }
            
            element.style.display = 'block';
            
            setTimeout(() => {
                element.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    element.style.display = 'none';
                    element.style.animation = '';
                }, 300);
            }, 3000);
        }

        // ==================== äº‹ä»¶ç›‘å¬å™¨ ====================
        function setupEventListeners() {
            elements.recordBtn.addEventListener('click', startRecording);
            elements.stopBtn.addEventListener('click', stopRecording);
            elements.uploadBtn.addEventListener('click', uploadToGitee);
            elements.playBtn.addEventListener('click', playRecording);
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    
                    if (AppState.isPlaying) stopPlayback();
                    
                    if (AppState.isRecording) {
                        stopRecording();
                    } else if (!elements.recordBtn.disabled) {
                        startRecording();
                    }
                }
                
                if (e.code === 'Escape') {
                    if (AppState.isPlaying) stopPlayback();
                    else if (AppState.isRecording) stopRecording();
                }
                
                if (e.code.startsWith('Digit') && e.code.length === 6) {
                    const num = parseInt(e.code[5]);
                    if (num >= 1 && num <= AppState.sentences.length) {
                        selectSentence(AppState.sentences[num - 1]);
                    }
                }
            });
            
            // åˆå§‹åŒ–æ³¢å½¢æ˜¾ç¤º
            updateWaveform();
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>

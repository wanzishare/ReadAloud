<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¥å­æœ—è¯»å½•éŸ³ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            min-height: 600px;
        }

        /* å·¦ä¾§å¥å­åˆ—è¡¨ */
        .sentence-list {
            flex: 1;
            border-right: 1px solid #eaeaea;
            overflow-y: auto;
            max-height: 600px;
        }

        .sentence-list-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #eaeaea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sentence-item {
            padding: 15px 20px;
            border-bottom: 1px solid #eaeaea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .sentence-item:hover {
            background: #f8f9fa;
        }

        .sentence-item.active {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-left: 4px solid #667eea;
        }

        .sentence-text {
            font-size: 16px;
            color: #333;
            margin-bottom: 8px;
        }

        .sentence-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            color: #666;
        }

        .status-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .status-recorded {
            background: #d4edda;
            color: #155724;
        }

        .status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .status-uploaded {
            background: #d1ecf1;
            color: #0c5460;
        }

        /* å³ä¾§å½•éŸ³åŒºåŸŸ */
        .recording-area {
            flex: 2;
            padding: 30px;
        }

        .current-sentence {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }

        .current-sentence .sentence-id {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .current-sentence-text {
            font-size: 20px;
            line-height: 1.6;
            color: #333;
        }

        /* å½•éŸ³æ§åˆ¶åŒº */
        .recording-controls {
            text-align: center;
            margin: 30px 0;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .btn-record {
            background: #dc3545;
            color: white;
        }

        .btn-record:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn-stop {
            background: #6c757d;
            color: white;
        }

        .btn-stop:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-upload {
            background: #28a745;
            color: white;
        }

        .btn-upload:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-play {
            background: #17a2b8;
            color: white;
        }

        .btn-play:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .timer {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .waveform {
            height: 100px;
            background: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: #667eea;
            border-radius: 3px 3px 0 0;
        }

        /* GitHubé…ç½®æ˜¾ç¤º */
        .github-config {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
            position: relative;
        }

        .config-display {
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            margin-bottom: 15px;
        }

        .config-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .config-info:last-child {
            border-bottom: none;
        }

        .config-label {
            font-weight: 600;
            color: #555;
        }

        .config-value {
            color: #2196F3;
            font-family: monospace;
            font-size: 14px;
        }

        .masked-token {
            color: #666;
            font-family: monospace;
            font-size: 14px;
            letter-spacing: 2px;
        }

        /* æ’­æ”¾æŒ‡ç¤ºå™¨ */
        .playback-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2196F3;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(33, 150, 243, 0.3);
            z-index: 1000;
            display: none;
            animation: slideIn 0.3s ease;
        }

        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease;
            display: none;
        }

        .status-success {
            background: #4CAF50;
            color: white;
        }

        .status-error {
            background: #f44336;
            color: white;
        }

        .status-info {
            background: #2196F3;
            color: white;
        }

        /* è¿›åº¦æ¡ */
        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eaeaea;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* åŠ¨ç”» */
        @keyframes slideIn {
            from { top: -50px; opacity: 0; }
            to { top: 20px; opacity: 1; }
        }

        @keyframes slideOut {
            from { top: 20px; opacity: 1; }
            to { top: -50px; opacity: 0; }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
            100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
        }

        @keyframes recordingPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes waveform {
            0% { height: 20%; }
            50% { height: 100%; }
            100% { height: 20%; }
        }

        .playing .current-sentence {
            animation: pulse 1.5s infinite;
        }

        .btn-play.playing {
            background: #ff9800;
            animation: recordingPulse 1.5s infinite;
        }

        .upload-icon {
            margin-left: 5px;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sentence-list {
                max-height: 300px;
            }
            
            .control-buttons {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å¤´éƒ¨ -->
        <div class="header">
            <h1>ğŸ“ å¥å­æœ—è¯»å½•éŸ³ç³»ç»Ÿ</h1>
            <p>æœ—è¯»å¥å­å¹¶è‡ªåŠ¨ä¸Šä¼ åˆ°GitHub | ç¬¬ä¸€æ¬¡å½•åˆ¶è‡ªåŠ¨ä¸Šä¼ ï¼Œç¬¬äºŒæ¬¡éœ€æ‰‹åŠ¨é‡æ–°ä¸Šä¼ </p>
        </div>

        <!-- ä¸»å†…å®¹åŒº -->
        <div class="main-content">
            <!-- å·¦ä¾§å¥å­åˆ—è¡¨ -->
            <div class="sentence-list">
                <div class="sentence-list-header">
                    <h3>ğŸ“‹ å¥å­åˆ—è¡¨</h3>
                    <span id="progressText">0/0 å·²å®Œæˆ</span>
                </div>
                <div id="sentencesContainer">
                    <!-- å¥å­é¡¹å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <!-- å³ä¾§å½•éŸ³åŒº -->
            <div class="recording-area">
                <!-- å½“å‰å¥å­å±•ç¤º -->
                <div class="current-sentence">
                    <div class="sentence-id" id="currentSentenceId">S001</div>
                    <div class="current-sentence-text" id="currentSentenceText">
                        è¯·ä»å·¦ä¾§é€‰æ‹©ä¸€å¥å¼€å§‹æœ—è¯»å½•éŸ³
                    </div>
                </div>

                <!-- å½•éŸ³æ§åˆ¶ -->
                <div class="recording-controls">
                    <div class="timer" id="timer">00:00</div>
                    <div class="waveform" id="waveform"></div>
                    
                    <div class="control-buttons">
                        <button class="btn btn-record" id="recordBtn">
                            <span>ğŸ¤ å¼€å§‹å½•éŸ³</span>
                        </button>
                        <button class="btn btn-stop" id="stopBtn" disabled>
                            <span>â¹ï¸ åœæ­¢å½•éŸ³</span>
                        </button>
                        <button class="btn btn-upload" id="uploadBtn" disabled>
                            <span>ğŸ“¤ ä¸Šä¼ åˆ°GitHub</span>
                        </button>
                        <button class="btn btn-play" id="playBtn" disabled>
                            <span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>
                        </button>
                    </div>

                    <!-- è¿›åº¦æ¡ -->
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- GitHubé…ç½®æ˜¾ç¤º -->
                <div class="github-config">
                    <h3>âš™ï¸ GitHubé…ç½®çŠ¶æ€</h3>
                    <div class="config-display">
                        <div class="config-info">
                            <span class="config-label">ä»“åº“:</span>
                            <span class="config-value" id="repoDisplay"></span>
                        </div>
                        <div class="config-info">
                            <span class="config-label">TokençŠ¶æ€:</span>
                            <span class="masked-token" id="tokenStatus">â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—â—</span>
                        </div>
                    </div>
                    <div class="config-info" id="configMessage">
                        <em>é…ç½®å·²åŠ è½½ï¼Œå¯ä»¥ç›´æ¥å¼€å§‹å½•éŸ³</em>
                    </div>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-number" id="totalSentences">0</div>
                        <div class="stat-label">æ€»å¥å­æ•°</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="completedSentences">0</div>
                        <div class="stat-label">å·²å®Œæˆ</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-number" id="uploadedSentences">0</div>
                        <div class="stat-label">å·²ä¸Šä¼ </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
    <div class="playback-indicator" id="playbackIndicator">ğŸ”Š æ­£åœ¨æ’­æ”¾...</div>
    <div class="status-message" id="statusMessage"></div>

    <script>
        token1 = "ghp_"
        token2 = "JgAogZu6YKI1R3q5o"
        token3 = "gZ3PxKm7yNdZ51ZHW5t"
        // ==================== é…ç½®æ–‡ä»¶ ====================
        // åœ¨è¿™é‡Œé…ç½®ä½ çš„GitHubä¿¡æ¯
        const GITHUB_CONFIG = {
            // ä½ çš„GitHubä»“åº“ï¼Œæ ¼å¼ï¼šç”¨æˆ·å/ä»“åº“å
            REPOSITORY: 'wanzishare/ReadAloud',
            
            // ä½ çš„GitHub Personal Access Tokenï¼ˆéœ€è¦repoæƒé™ï¼‰
            TOKEN: token1 + token2 + token3
        };
        
        // ç¤ºä¾‹å¥å­æ•°æ®
        const SAMPLE_SENTENCES = [
            { id: 'S001', text: 'ç”Ÿæ´»å°±åƒä¸€ç›’å·§å…‹åŠ›ï¼Œä½ æ°¸è¿œä¸çŸ¥é“ä¸‹ä¸€é¢—æ˜¯ä»€ä¹ˆå‘³é“ã€‚', recorded: false, hasUploaded: false },
            { id: 'S002', text: 'æˆåŠŸä¸æ˜¯ç»ˆç‚¹ï¼Œå¤±è´¥ä¹Ÿå¹¶éæœ«æ—¥ï¼Œé‡è¦çš„æ˜¯ç»§ç»­å‰è¿›çš„å‹‡æ°”ã€‚', recorded: false, hasUploaded: false },
            { id: 'S003', text: 'å­¦ä¹ å¦‚é€†æ°´è¡ŒèˆŸï¼Œä¸è¿›åˆ™é€€ã€‚', recorded: false, hasUploaded: false },
            { id: 'S004', text: 'æ—¶é—´æ˜¯æœ€å¥½çš„è€å¸ˆï¼Œä½†é—æ†¾çš„æ˜¯ï¼Œå®ƒä¼šæ€æ­»æ‰€æœ‰å­¦ç”Ÿã€‚', recorded: false, hasUploaded: false },
            { id: 'S005', text: 'æ¢¦æƒ³ä¸ä¼šé€ƒè·‘ï¼Œé€ƒè·‘çš„æ°¸è¿œæ˜¯è‡ªå·±ã€‚', recorded: false, hasUploaded: false },
            { id: 'S006', text: 'çœŸæ­£çš„å‘ç°ä¹‹æ—…ä¸åœ¨äºå¯»æ‰¾æ–°é£æ™¯ï¼Œè€Œåœ¨äºæ‹¥æœ‰æ–°çœ¼å…‰ã€‚', recorded: false, hasUploaded: false },
            { id: 'S007', text: 'å¿è€ä¹‹æ ‘ç»“å‡ºé»„é‡‘ä¹‹æœã€‚', recorded: false, hasUploaded: false },
            { id: 'S008', text: 'äººç”Ÿæ²¡æœ‰å½©æ’ï¼Œæ¯ä¸€å¤©éƒ½æ˜¯ç°åœºç›´æ’­ã€‚', recorded: false, hasUploaded: false },
            { id: 'S009', text: 'æœºä¼šæ€»æ˜¯ç•™ç»™æœ‰å‡†å¤‡çš„äººã€‚', recorded: false, hasUploaded: false },
            { id: 'S010', text: 'åƒé‡Œä¹‹è¡Œï¼Œå§‹äºè¶³ä¸‹ã€‚', recorded: false, hasUploaded: false }
        ];

        // ==================== åº”ç”¨çŠ¶æ€ ====================
        const AppState = {
            sentences: [],
            currentSentence: null,
            audioBlob: null,
            audioChunks: [],
            isRecording: false,
            recorder: null,
            timerInterval: null,
            recordingTime: 0,
            todayDate: new Date().toISOString().split('T')[0],
            config: GITHUB_CONFIG,
            isPlaying: false,
            currentAudio: null,            
            // æ–°å¢çš„æ’­æ”¾è®¡æ—¶å™¨å±æ€§
            playbackTimerInterval: null,
            playbackTime: 0,
            audioCurrentTime: 0,
            audioDuration: 0
        };

        // ==================== DOMå…ƒç´  ====================
        const elements = {
            sentencesContainer: document.getElementById('sentencesContainer'),
            currentSentenceId: document.getElementById('currentSentenceId'),
            currentSentenceText: document.getElementById('currentSentenceText'),
            recordBtn: document.getElementById('recordBtn'),
            stopBtn: document.getElementById('stopBtn'),
            uploadBtn: document.getElementById('uploadBtn'),
            playBtn: document.getElementById('playBtn'),
            timer: document.getElementById('timer'),
            waveform: document.getElementById('waveform'),
            progressFill: document.getElementById('progressFill'),
            progressText: document.getElementById('progressText'),
            totalSentences: document.getElementById('totalSentences'),
            completedSentences: document.getElementById('completedSentences'),
            uploadedSentences: document.getElementById('uploadedSentences'),
            repoDisplay: document.getElementById('repoDisplay'),
            tokenStatus: document.getElementById('tokenStatus'),
            configMessage: document.getElementById('configMessage'),
            playbackIndicator: document.getElementById('playbackIndicator'),
            statusMessage: document.getElementById('statusMessage')
        };

        // ==================== åˆå§‹åŒ–åº”ç”¨ ====================
        function initApp() {
            console.log('åˆå§‹åŒ–åº”ç”¨...');

            // æ£€æŸ¥éŸ³é¢‘å…¼å®¹æ€§
            checkAudioCompatibility();
            
            // æ£€æŸ¥GitHubé…ç½®
            if (!AppState.config.REPOSITORY || !AppState.config.TOKEN) {
                showStatus('è¯·å…ˆé…ç½®GitHubä¿¡æ¯ï¼ä¿®æ”¹ä»£ç ä¸­çš„GITHUB_CONFIGå˜é‡ã€‚', 'error');
                return;
            }
            
            // æ˜¾ç¤ºé…ç½®ä¿¡æ¯
            elements.repoDisplay.textContent = AppState.config.REPOSITORY;
            
            // æ˜¾ç¤ºTokençŠ¶æ€
            const token = AppState.config.TOKEN;
            if (token.length > 8) {
                const masked = 'â—'.repeat(12) + token.slice(-8);
                elements.tokenStatus.textContent = masked;
            }
            
            // åŠ è½½å¥å­æ•°æ®
            loadSentences();
            
            // æ¸²æŸ“å¥å­åˆ—è¡¨
            renderSentenceList();
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            updateStats();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ªå¥å­
            if (AppState.sentences.length > 0) {
                selectSentence(AppState.sentences[0]);
            }
            
            showStatus('ç³»ç»Ÿå·²å°±ç»ªï¼Œå¯ä»¥å¼€å§‹å½•éŸ³', 'success');
        }

        // ==================== å¥å­ç®¡ç† ====================
        function loadSentences() {
            const savedKey = `sentences_${AppState.todayDate}`;
            const saved = localStorage.getItem(savedKey);
            
            if (saved) {
                try {
                    AppState.sentences = JSON.parse(saved);
                    console.log('ä»æœ¬åœ°å­˜å‚¨åŠ è½½å¥å­æ•°æ®');
                } catch (e) {
                    console.warn('æœ¬åœ°å­˜å‚¨æ•°æ®æŸåï¼Œä½¿ç”¨é»˜è®¤å¥å­');
                    AppState.sentences = [...SAMPLE_SENTENCES];
                }
            } else {
                AppState.sentences = [...SAMPLE_SENTENCES];
                console.log('ä½¿ç”¨é»˜è®¤å¥å­æ•°æ®');
            }
            
            // ç¡®ä¿æ¯ä¸ªå¥å­éƒ½æœ‰ hasUploaded å±æ€§
            AppState.sentences.forEach(sentence => {
                if (sentence.hasUploaded === undefined) {
                    sentence.hasUploaded = false;
                }
            });
        }

        function saveSentences() {
            const key = `sentences_${AppState.todayDate}`;
            localStorage.setItem(key, JSON.stringify(AppState.sentences));
        }

        function renderSentenceList() {
            elements.sentencesContainer.innerHTML = '';
            
            AppState.sentences.forEach((sentence, index) => {
                const item = document.createElement('div');
                item.className = `sentence-item ${sentence === AppState.currentSentence ? 'active' : ''}`;
                
                // ç¡®å®šçŠ¶æ€å¾½ç« 
                let statusClass = 'status-pending';
                let statusText = 'å¾…å½•åˆ¶';
                
                if (sentence.recorded) {
                    if (sentence.hasUploaded) {
                        statusClass = 'status-uploaded';
                        statusText = 'âœ“ å·²ä¸Šä¼ ';
                    } else {
                        statusClass = 'status-recorded';
                        statusText = 'âœ“ å·²å½•åˆ¶';
                    }
                }
                
                item.innerHTML = `
                    <div class="sentence-text">${sentence.hasUploaded ? 'ğŸŒ ' : ''}${sentence.text}</div>
                    <div class="sentence-meta">
                        <span>${sentence.id}</span>
                        <span class="status-badge ${statusClass}">
                            ${statusText}
                        </span>
                    </div>
                `;
                
                item.onclick = () => selectSentence(sentence);
                elements.sentencesContainer.appendChild(item);
            });
        }

        function selectSentence(sentence) {
            console.log('é€‰æ‹©å¥å­:', sentence.id);
            
            if (!sentence) {
                console.error('æ— æ³•é€‰æ‹©å¥å­ï¼Œå¥å­å¯¹è±¡ä¸ºç©º');
                return;
            }
            
            AppState.currentSentence = sentence;
            AppState.audioBlob = null;
            
            // åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„æ’­æ”¾
            if (AppState.isPlaying) {
                stopPlayback();
            }
            
            // åœæ­¢ä»»ä½•è®¡æ—¶å™¨
            if (AppState.timerInterval) {
                clearInterval(AppState.timerInterval);
                AppState.timerInterval = null;
            }
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
                AppState.playbackTimerInterval = null;
            }
            
            // æ›´æ–°æ˜¾ç¤º
            elements.currentSentenceId.textContent = sentence.id;
            elements.currentSentenceText.textContent = sentence.text;
            
            // é‡ç½®è®¡æ—¶å™¨æ˜¾ç¤º
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
            
            // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ˜¾ç¤ºæ¿€æ´»çŠ¶æ€
            renderSentenceList();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å·²å½•åˆ¶çš„éŸ³é¢‘
            checkExistingRecording(sentence.id);
            
            // é‡ç½®å½•éŸ³æŒ‰é’®çŠ¶æ€
            elements.recordBtn.disabled = false;
            elements.stopBtn.disabled = true;
        }

        // ==================== éŸ³é¢‘å¤„ç† ====================
        function checkExistingRecording(sentenceId) {
            const audioKey = `audio_${AppState.todayDate}_${sentenceId}`;
            const audioData = localStorage.getItem(audioKey);
            
            if (audioData) {
                console.log('æ‰¾åˆ°æœ¬åœ°å½•éŸ³:', audioKey);
                
                // å°†DataURLè½¬æ¢ä¸ºBlob
                try {
                    const byteString = atob(audioData.split(',')[1]);
                    const mimeString = audioData.split(',')[0].split(':')[1].split(';')[0];
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    
                    AppState.audioBlob = new Blob([ab], { type: mimeString });
                    
                    // å¯ç”¨æŒ‰é’®
                    elements.playBtn.disabled = false;
                    elements.uploadBtn.disabled = false;
                    
                    // æ ¹æ®æ˜¯å¦å·²ä¸Šä¼ æ˜¾ç¤ºä¸åŒæ–‡æœ¬
                    if (AppState.currentSentence && AppState.currentSentence.hasUploaded) {
                        elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                    } else {
                        elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°GitHub';
                    }
                    
                    console.log('æœ¬åœ°å½•éŸ³å·²åŠ è½½ï¼Œå¤§å°:', AppState.audioBlob.size, 'bytes');
                } catch (error) {
                    console.error('åŠ è½½æœ¬åœ°å½•éŸ³å¤±è´¥:', error);
                }
            } else {
                console.log('æ²¡æœ‰æ‰¾åˆ°æœ¬åœ°å½•éŸ³');
                elements.playBtn.disabled = true;
                elements.uploadBtn.textContent = 'ğŸ“¤ ä¸Šä¼ åˆ°GitHub';
                elements.uploadBtn.disabled = true;
            }
        }

        // ==================== å½•éŸ³åŠŸèƒ½ ====================
        async function startRecording() {
            try {
                console.log('å¼€å§‹å½•éŸ³...');
                
                // é‡ç½®çŠ¶æ€
                AppState.audioChunks = [];
                AppState.audioBlob = null;
                
                // ä½¿ç”¨å…¼å®¹çš„éŸ³é¢‘é…ç½®
                const audioConstraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100,
                        channelCount: 1,
                        // è®¾å¤‡å…¼å®¹æ€§é…ç½®
                        autoGainControl: true
                    }
                };
                
                // è¯·æ±‚éº¦å…‹é£æƒé™
                const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                
                // é€‰æ‹©å…¼å®¹çš„MIMEç±»å‹
                let mimeType = 'audio/webm';
                
                // æ£€æµ‹è®¾å¤‡å¹¶é€‰æ‹©æœ€åˆé€‚çš„æ ¼å¼
                if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    mimeType = 'audio/mp4;codecs=mp4a.40.2'; // AACç¼–ç ï¼ŒiOSå’ŒAndroidéƒ½æ”¯æŒ
                } else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    mimeType = 'audio/webm;codecs=opus'; // Opusç¼–ç ï¼ŒAndroidå’ŒChromeæ”¯æŒ
                } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                    mimeType = 'audio/wav'; // WAVæ ¼å¼ï¼Œæ‰€æœ‰è®¾å¤‡éƒ½æ”¯æŒ
                } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
                    mimeType = 'audio/ogg;codecs=opus'; // Oggæ ¼å¼
                }
                
                console.log('é€‰æ‹©çš„éŸ³é¢‘æ ¼å¼:', mimeType);
                
                // åˆ›å»ºå½•éŸ³å™¨
                const recorderOptions = {
                    mimeType: mimeType,
                    audioBitsPerSecond: 128000 // 128kbpsï¼Œè´¨é‡ä¸å¤§å°å¹³è¡¡
                };
                
                // æ£€æŸ¥MIMEç±»å‹æ˜¯å¦æ”¯æŒ
                if (!MediaRecorder.isTypeSupported(recorderOptions.mimeType)) {
                    console.warn('MIMEç±»å‹ä¸æ”¯æŒï¼Œä½¿ç”¨é»˜è®¤æ ¼å¼');
                    delete recorderOptions.mimeType; // è®©æµè§ˆå™¨é€‰æ‹©é»˜è®¤æ ¼å¼
                }
                
                AppState.recorder = new MediaRecorder(stream, recorderOptions);
                
                // æ”¶é›†éŸ³é¢‘æ•°æ®
                AppState.recorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        AppState.audioChunks.push(event.data);
                        updateWaveform();
                    }
                };
                
                // å½•éŸ³åœæ­¢æ—¶çš„å¤„ç†
                AppState.recorder.onstop = () => {
                    console.log('å½•éŸ³å™¨åœæ­¢ï¼Œæ•°æ®å—æ•°é‡:', AppState.audioChunks.length);
                    
                    if (AppState.audioChunks.length > 0) {
                        // åˆ›å»ºéŸ³é¢‘Blob
                        AppState.audioBlob = new Blob(AppState.audioChunks, { 
                            type: AppState.recorder.mimeType || 'audio/webm'
                        });
                        
                        console.log('éŸ³é¢‘Blobåˆ›å»ºæˆåŠŸï¼Œå¤§å°:', AppState.audioBlob.size, 'bytes');
                        console.log('éŸ³é¢‘æ ¼å¼:', AppState.audioBlob.type);
                        
                        // ä¿å­˜åˆ°æœ¬åœ°
                        saveRecordingLocally();
                        
                        // åœæ­¢éŸ³è½¨
                        stream.getTracks().forEach(track => track.stop());
                    } else {
                        console.warn('æ²¡æœ‰å½•éŸ³æ•°æ®');
                        showStatus('å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                    }
                };
                
                // å¼€å§‹å½•éŸ³
                AppState.recorder.start(100); // æ¯100msæ”¶é›†æ•°æ®
                AppState.isRecording = true;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.recordBtn.disabled = true;
                elements.stopBtn.disabled = false;
                elements.uploadBtn.disabled = true;
                elements.playBtn.disabled = true;
                
                // å¼€å§‹è®¡æ—¶
                startTimer();
                
                showStatus('æ­£åœ¨å½•éŸ³...', 'info');
                
            } catch (error) {
                console.error('å½•éŸ³é”™è¯¯:', error);
                showStatus('æ— æ³•è®¿é—®éº¦å…‹é£ï¼š' + error.message, 'error');
            }
        }

        function stopRecording() {
            if (AppState.recorder && AppState.isRecording) {
                console.log('åœæ­¢å½•éŸ³...');
                
                AppState.recorder.stop();
                AppState.isRecording = false;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.recordBtn.disabled = false;
                elements.stopBtn.disabled = true;
                
                // åœæ­¢å½•éŸ³è®¡æ—¶å™¨
                stopTimer();
                
                // é‡ç½®è®¡æ—¶å™¨æ˜¾ç¤º
                elements.timer.textContent = '00:00';
                elements.progressFill.style.width = '0%';
            }
        }

        function saveRecordingLocally() {
            if (AppState.currentSentence && AppState.audioBlob) {
                const reader = new FileReader();
                
                reader.onload = () => {
                    const audioKey = `audio_${AppState.todayDate}_${AppState.currentSentence.id}`;
                    localStorage.setItem(audioKey, reader.result);
                    
                    // æ›´æ–°å¥å­çŠ¶æ€
                    AppState.currentSentence.recorded = true;
                    AppState.currentSentence.lastRecorded = new Date().toISOString();
                    
                    // ä¿å­˜å¹¶æ›´æ–°æ˜¾ç¤º
                    saveSentences();
                    renderSentenceList();
                    updateStats();
                    
                    console.log('å½•éŸ³å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨:', audioKey);
                    
                    // å¯ç”¨æ’­æ”¾æŒ‰é’®
                    elements.playBtn.disabled = false;
                    
                    // åˆ¤æ–­æ˜¯å¦ä¸ºç¬¬ä¸€æ¬¡å½•åˆ¶
                    const isFirstRecording = !AppState.currentSentence.hasUploaded;
                    
                    if (isFirstRecording) {
                        // ç¬¬ä¸€æ¬¡å½•åˆ¶ï¼Œè‡ªåŠ¨ä¸Šä¼ 
                        console.log('ç¬¬ä¸€æ¬¡å½•åˆ¶ï¼Œè‡ªåŠ¨ä¸Šä¼ åˆ°GitHub');
                        showStatus('å½•éŸ³å®Œæˆï¼Œæ­£åœ¨è‡ªåŠ¨ä¸Šä¼ åˆ°GitHub...', 'success');
                        setTimeout(() => {
                            uploadToGitHub();
                        }, 500);
                    } else {
                        // ç¬¬äºŒæ¬¡åŠä»¥åï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å‡»ä¸Šä¼ 
                        console.log('éç¬¬ä¸€æ¬¡å½•åˆ¶ï¼Œç­‰å¾…æ‰‹åŠ¨ä¸Šä¼ ');
                        elements.uploadBtn.disabled = false;
                        elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                        showStatus('å½•éŸ³å®Œæˆï¼å¦‚éœ€æ›´æ–°åˆ°GitHubè¯·ç‚¹å‡»"é‡æ–°ä¸Šä¼ "', 'success');
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('ä¿å­˜å½•éŸ³å¤±è´¥:', error);
                    showStatus('ä¿å­˜å½•éŸ³å¤±è´¥', 'error');
                };
                
                reader.readAsDataURL(AppState.audioBlob);
            }
        }

        // ==================== æ’­æ”¾åŠŸèƒ½ ====================
        // ==================== æ’­æ”¾åŠŸèƒ½ ====================
function playRecording() {
    if (AppState.isPlaying) {
        console.log('å·²ç»åœ¨æ’­æ”¾ä¸­');
        return;
    }
    
    if (!AppState.currentSentence) {
        showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¥å­', 'error');
        return;
    }
    
    let audioToPlay = null;
    
    // ä¼˜å…ˆä½¿ç”¨å†…å­˜ä¸­çš„Blob
    if (AppState.audioBlob) {
        console.log('ä½¿ç”¨å†…å­˜ä¸­çš„éŸ³é¢‘æ’­æ”¾');
        audioToPlay = AppState.audioBlob;
    } else {
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½
        const audioKey = `audio_${AppState.todayDate}_${AppState.currentSentence.id}`;
        const audioData = localStorage.getItem(audioKey);
        
        if (!audioData) {
            showStatus('æ²¡æœ‰æ‰¾åˆ°å½•éŸ³æ–‡ä»¶', 'error');
            return;
        }
        
        try {
            const byteString = atob(audioData.split(',')[1]);
            const mimeString = audioData.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            
            audioToPlay = new Blob([ab], { type: mimeString });
            AppState.audioBlob = audioToPlay; // ç¼“å­˜
        } catch (error) {
            console.error('åŠ è½½éŸ³é¢‘å¤±è´¥:', error);
            showStatus('åŠ è½½éŸ³é¢‘å¤±è´¥', 'error');
            return;
        }
    }
    
    if (!audioToPlay) {
        showStatus('æ²¡æœ‰å¯æ’­æ”¾çš„éŸ³é¢‘', 'error');
        return;
    }
    
    // åˆ›å»ºéŸ³é¢‘å¯¹è±¡
    const audioUrl = URL.createObjectURL(audioToPlay);
    const audio = new Audio(audioUrl);
    
    // é‡ç½®æ’­æ”¾æ—¶é—´
    AppState.audioCurrentTime = 0;
    AppState.audioDuration = 0;
    
    // è®¾ç½®æ’­æ”¾çŠ¶æ€
    AppState.isPlaying = true;
    AppState.currentAudio = audio;
    elements.playBtn.innerHTML = '<span>â¸ï¸ æ­£åœ¨æ’­æ”¾...</span>';
    elements.playBtn.classList.add('playing');
    elements.playbackIndicator.style.display = 'block';
    
    // æ·»åŠ æ’­æ”¾åŠ¨ç”»
    document.querySelector('.recording-area').classList.add('playing');
    
    // æ’­æ”¾äº‹ä»¶å¤„ç†
    audio.onloadedmetadata = () => {
        // è·å–éŸ³é¢‘æ€»æ—¶é•¿
        AppState.audioDuration = audio.duration;
        console.log('éŸ³é¢‘æ—¶é•¿:', AppState.audioDuration, 'ç§’');
    };
    
    audio.onplay = () => {
        console.log('éŸ³é¢‘å¼€å§‹æ’­æ”¾');
        
        // å¼€å§‹æ’­æ”¾è®¡æ—¶å™¨
        startPlaybackTimer();
    };
    
    audio.ontimeupdate = () => {
        // æ›´æ–°å½“å‰æ’­æ”¾æ—¶é—´
        AppState.audioCurrentTime = audio.currentTime;
        
        // æ›´æ–°è®¡æ—¶å™¨æ˜¾ç¤º
        updatePlaybackTimer();
    };
    
    audio.onended = () => {
        console.log('éŸ³é¢‘æ’­æ”¾ç»“æŸ');
        stopPlayback();
        URL.revokeObjectURL(audioUrl);
    };
    
    audio.onerror = (error) => {
        console.error('æ’­æ”¾é”™è¯¯:', error);
        stopPlayback();
        showStatus('æ’­æ”¾å¤±è´¥', 'error');
        URL.revokeObjectURL(audioUrl);
    };
    
    // å¼€å§‹æ’­æ”¾
    audio.play().catch(error => {
        console.error('æ’­æ”¾å¤±è´¥:', error);
        stopPlayback();
        showStatus('æ’­æ”¾å¤±è´¥ï¼š' + error.message, 'error');
        URL.revokeObjectURL(audioUrl);
    });
}

        // ==================== æ’­æ”¾è®¡æ—¶å™¨å‡½æ•° ====================
        function startPlaybackTimer() {
            // åœæ­¢ä¹‹å‰çš„è®¡æ—¶å™¨
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
            }
            
            // é‡ç½®æ’­æ”¾æ—¶é—´
            AppState.playbackTime = 0;
            
            // æ¯100msæ›´æ–°ä¸€æ¬¡è®¡æ—¶å™¨
            AppState.playbackTimerInterval = setInterval(() => {
                AppState.playbackTime += 0.1;
                updatePlaybackTimer();
            }, 100);
        }

        function updatePlaybackTimer() {
            // å¦‚æœéŸ³é¢‘å·²ç»åŠ è½½äº†æ—¶é•¿ï¼Œä½¿ç”¨éŸ³é¢‘çš„å®é™…æ’­æ”¾æ—¶é—´
            let displayTime = AppState.audioCurrentTime || AppState.playbackTime;
            
            // ç¡®ä¿æ—¶é—´ä¸ä¼šè¶…è¿‡éŸ³é¢‘æ€»æ—¶é•¿
            if (AppState.audioDuration && displayTime > AppState.audioDuration) {
                displayTime = AppState.audioDuration;
            }
            
            // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
            const minutes = Math.floor(displayTime / 60).toString().padStart(2, '0');
            const seconds = Math.floor(displayTime % 60).toString().padStart(2, '0');
            const milliseconds = Math.floor((displayTime % 1) * 100).toString().padStart(2, '0');
            
            // æ˜¾ç¤ºæ’­æ”¾æ—¶é—´
            // elements.timer.textContent = `${minutes}:${seconds}.${milliseconds}`;
            elements.timer.textContent = `${minutes}:${seconds}`;
            
            // å¦‚æœéŸ³é¢‘æœ‰æ€»æ—¶é•¿ï¼Œæ˜¾ç¤ºè¿›åº¦ç™¾åˆ†æ¯”
            if (AppState.audioDuration) {
                const progressPercent = (displayTime / AppState.audioDuration) * 100;
                elements.progressFill.style.width = `${progressPercent}%`;
            }
        }

        // ==================== åœæ­¢æ’­æ”¾å‡½æ•° ====================
        function stopPlayback() {
            AppState.isPlaying = false;
            
            // åœæ­¢éŸ³é¢‘
            if (AppState.currentAudio) {
                AppState.currentAudio.pause();
                AppState.currentAudio.currentTime = 0;
                AppState.currentAudio = null;
            }
            
            // åœæ­¢æ’­æ”¾è®¡æ—¶å™¨
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
                AppState.playbackTimerInterval = null;
            }
            
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
            elements.playBtn.classList.remove('playing');
            elements.playbackIndicator.style.display = 'none';
            
            // ç§»é™¤åŠ¨ç”»
            document.querySelector('.recording-area').classList.remove('playing');
            
            // é‡ç½®è®¡æ—¶å™¨æ˜¾ç¤º
            elements.timer.textContent = '00:00';
            elements.progressFill.style.width = '0%';
        }

        function stopPlayback() {
            AppState.isPlaying = false;
            
            // åœæ­¢éŸ³é¢‘
            if (AppState.currentAudio) {
                AppState.currentAudio.pause();
                AppState.currentAudio.currentTime = 0;
                AppState.currentAudio = null;
            }
            
            // æ¢å¤æŒ‰é’®çŠ¶æ€
            elements.playBtn.innerHTML = '<span>â–¶ï¸ æ’­æ”¾å½•éŸ³</span>';
            elements.playBtn.classList.remove('playing');
            elements.playbackIndicator.style.display = 'none';
            
            // ç§»é™¤åŠ¨ç”»
            document.querySelector('.recording-area').classList.remove('playing');
        }

        // ==================== GitHubä¸Šä¼  ====================
        async function uploadToGitHub() {
            // éªŒè¯çŠ¶æ€
            if (!AppState.audioBlob) {
                showStatus('è¯·å…ˆå½•åˆ¶éŸ³é¢‘ï¼', 'error');
                return;
            }
            
            if (!AppState.currentSentence) {
                showStatus('è¯·é€‰æ‹©ä¸€ä¸ªå¥å­ï¼', 'error');
                return;
            }
            
            if (!AppState.config.REPOSITORY || !AppState.config.TOKEN) {
                showStatus('GitHubé…ç½®ä¸æ­£ç¡®', 'error');
                return;
            }
            
            try {
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                elements.uploadBtn.innerHTML = '<span>â³ ä¸Šä¼ ä¸­...</span>';
                elements.uploadBtn.disabled = true;
                
                // ç»Ÿä¸€ä½¿ç”¨.wavæ ¼å¼ï¼Œç¡®ä¿æœ€å¤§å…¼å®¹æ€§
                const fileName = `${AppState.todayDate}_${AppState.currentSentence.id}.wav`;
                const filePath = `recordings/${AppState.todayDate}/${fileName}`;
                
                console.log('å‡†å¤‡ä¸Šä¼ æ–‡ä»¶:', filePath, 'åŸå§‹æ ¼å¼:', AppState.audioBlob.type);
                
                // å¦‚æœå½“å‰ä¸æ˜¯WAVæ ¼å¼ï¼Œè½¬æ¢ä¸ºWAVæ ¼å¼
                let finalBlob = AppState.audioBlob;
                
                if (!AppState.audioBlob.type.includes('wav') && 
                    !AppState.audioBlob.type.includes('x-wav')) {
                    console.log('è½¬æ¢ä¸ºWAVæ ¼å¼ä»¥ç¡®ä¿å…¼å®¹æ€§');
                    try {
                        finalBlob = await convertToWav(AppState.audioBlob);
                        console.log('è½¬æ¢ä¸ºWAVæˆåŠŸï¼Œæ–°æ ¼å¼:', finalBlob.type);
                    } catch (conversionError) {
                        console.warn('WAVè½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', conversionError);
                        // ç»§ç»­ä½¿ç”¨åŸå§‹æ ¼å¼
                    }
                }
                
                // è½¬æ¢Blobä¸ºBase64
                const base64Data = await blobToBase64(finalBlob);
                
                // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
                const existingSHA = await getFileSHA(filePath);
                
                // å‡†å¤‡è¯·æ±‚æ•°æ®
                const requestData = {
                    message: `å½•éŸ³ä¸Šä¼ : ${AppState.currentSentence.id} - ${new Date().toLocaleString('zh-CN')}`,
                    content: base64Data,
                    committer: {
                        name: 'Audio Recording App',
                        email: 'audio@example.com'
                    }
                };
                
                // å¦‚æœæ–‡ä»¶å­˜åœ¨ï¼Œéœ€è¦SHAæ¥æ›´æ–°
                if (existingSHA) {
                    requestData.sha = existingSHA;
                }
                
                // å‘é€è¯·æ±‚åˆ°GitHub API
                console.log('å‘é€è¯·æ±‚åˆ°GitHub API...');
                const response = await fetch(
                    `https://api.github.com/repos/${AppState.config.REPOSITORY}/contents/${filePath}`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${AppState.config.TOKEN}`,
                            'Content-Type': 'application/json; charset=utf-8',
                            'Accept': 'application/vnd.github.v3+json',
                            'User-Agent': 'AudioRecordingApp/1.0'
                        },
                        body: JSON.stringify(requestData)
                    }
                );
                
                const result = await response.json();
                
                if (response.ok) {
                    console.log('ä¸Šä¼ æˆåŠŸ:', result);
                    showStatus('âœ… ä¸Šä¼ æˆåŠŸï¼æ–‡ä»¶å·²ä¿å­˜åˆ°GitHub', 'success');
                    
                    // æ›´æ–°å¥å­çŠ¶æ€ - æ ‡è®°ä¸ºå·²ä¸Šä¼ 
                    AppState.currentSentence.uploaded = true;
                    AppState.currentSentence.hasUploaded = true;
                    AppState.currentSentence.uploadedAt = new Date().toISOString();
                    
                    // æ›´æ–°ä¸Šä¼ æŒ‰é’®æ–‡æœ¬
                    elements.uploadBtn.textContent = 'ğŸ“¤ é‡æ–°ä¸Šä¼ ';
                    elements.uploadBtn.disabled = false;
                    
                    saveSentences();
                    renderSentenceList();
                    updateStats();
                    
                } else {REPOSITORY
                    console.error('ä¸Šä¼ å¤±è´¥:', result);
                    throw new Error(result.message || 'ä¸Šä¼ å¤±è´¥');
                }
                
            } catch (error) {
                console.error('ä¸Šä¼ é”™è¯¯:', error);
                showStatus(`âŒ ä¸Šä¼ å¤±è´¥ï¼š${error.message}`, 'error');
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                elements.uploadBtn.innerHTML = '<span>ğŸ“¤ ä¸Šä¼ åˆ°GitHub</span>';
                elements.uploadBtn.disabled = false;
            }
        }

        // ==================== éŸ³é¢‘è½¬æ¢å·¥å…·å‡½æ•° ====================
        async function convertToWav(audioBlob) {
            return new Promise((resolve, reject) => {
                console.log('å¼€å§‹è½¬æ¢ä¸ºWAVæ ¼å¼');
                
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    audioContext.decodeAudioData(e.target.result)
                        .then(buffer => {
                            // è·å–éŸ³é¢‘å‚æ•°
                            const sampleRate = buffer.sampleRate;
                            const numberOfChannels = buffer.numberOfChannels;
                            const length = buffer.length;
                            
                            // åˆ›å»ºWAVæ–‡ä»¶
                            const wavData = encodeWAV(buffer, sampleRate, numberOfChannels);
                            const wavBlob = new Blob([wavData], { type: 'audio/wav' });
                            
                            console.log('WAVè½¬æ¢æˆåŠŸï¼Œå¤§å°:', wavBlob.size);
                            audioContext.close();
                            resolve(wavBlob);
                        })
                        .catch(error => {
                            console.error('è§£ç éŸ³é¢‘å¤±è´¥:', error);
                            audioContext.close();
                            
                            // å¦‚æœè§£ç å¤±è´¥ï¼Œåˆ›å»ºä¸€ä¸ªç®€å•çš„WAVå¤´éƒ¨
                            const fakeWavBlob = createSimpleWav(audioBlob);
                            resolve(fakeWavBlob);
                        });
                };
                
                reader.onerror = function(error) {
                    console.error('è¯»å–æ–‡ä»¶å¤±è´¥:', error);
                    reject(error);
                };
                
                reader.readAsArrayBuffer(audioBlob);
            });
        }

        function encodeWAV(buffer, sampleRate, numChannels) {
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = buffer.length * blockAlign;
            
            const bufferSize = 44 + dataSize;
            const arrayBuffer = new ArrayBuffer(bufferSize);
            const view = new DataView(arrayBuffer);
            
            // RIFFæ ‡è¯†ç¬¦
            writeString(view, 0, 'RIFF');
            // RIFFå—å¤§å°
            view.setUint32(4, 36 + dataSize, true);
            // RIFFç±»å‹
            writeString(view, 8, 'WAVE');
            // æ ¼å¼å—æ ‡è¯†ç¬¦
            writeString(view, 12, 'fmt ');
            // æ ¼å¼å—å¤§å°
            view.setUint32(16, 16, true);
            // éŸ³é¢‘æ ¼å¼
            view.setUint16(20, format, true);
            // å£°é“æ•°
            view.setUint16(22, numChannels, true);
            // é‡‡æ ·ç‡
            view.setUint32(24, sampleRate, true);
            // å­—èŠ‚ç‡
            view.setUint32(28, byteRate, true);
            // å—å¯¹é½
            view.setUint16(32, blockAlign, true);
            // ä½æ·±
            view.setUint16(34, bitDepth, true);
            // æ•°æ®å—æ ‡è¯†ç¬¦
            writeString(view, 36, 'data');
            // æ•°æ®å—å¤§å°
            view.setUint32(40, dataSize, true);
            
            // å†™å…¥éŸ³é¢‘æ•°æ®
            floatTo16BitPCM(view, 44, buffer, numChannels);
            
            return arrayBuffer;
        }

        function createSimpleWav(originalBlob) {
            // åˆ›å»ºä¸€ä¸ªç®€å•çš„WAVå¤´éƒ¨ï¼Œä¸è¿›è¡Œå®é™…éŸ³é¢‘è½¬æ¢
            // è¿™å¯¹äºå¤§å¤šæ•°æƒ…å†µå·²ç»è¶³å¤Ÿäº†
            const sampleRate = 44100;
            const numChannels = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            
            // è¯»å–åŸå§‹blobä½œä¸ºæ•°æ®
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const originalData = new Uint8Array(e.target.result);
                    const dataSize = originalData.length;
                    
                    // åˆ›å»ºWAVæ–‡ä»¶
                    const bufferSize = 44 + dataSize;
                    const arrayBuffer = new ArrayBuffer(bufferSize);
                    const view = new DataView(arrayBuffer);
                    
                    // å†™å…¥WAVå¤´éƒ¨
                    writeString(view, 0, 'RIFF');
                    view.setUint32(4, 36 + dataSize, true);
                    writeString(view, 8, 'WAVE');
                    writeString(view, 12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, 1, true);
                    view.setUint16(22, numChannels, true);
                    view.setUint32(24, sampleRate, true);
                    view.setUint32(28, byteRate, true);
                    view.setUint16(32, blockAlign, true);
                    view.setUint16(34, bitDepth, true);
                    writeString(view, 36, 'data');
                    view.setUint32(40, dataSize, true);
                    
                    // å¤åˆ¶åŸå§‹æ•°æ®
                    for (let i = 0; i < dataSize; i++) {
                        view.setUint8(44 + i, originalData[i]);
                    }
                    
                    const wavBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
                    resolve(wavBlob);
                };
                reader.readAsArrayBuffer(originalBlob);
            });
        }

        function floatTo16BitPCM(output, offset, buffer, numChannels) {
            for (let channel = 0; channel < numChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                for (let i = 0; i < channelData.length; i++, offset += 2) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    output.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                }
            }
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // ==================== è®¾å¤‡å…¼å®¹æ€§æ£€æµ‹ ====================
        function checkAudioCompatibility() {
            const supportedFormats = [
                'audio/mp4;codecs=mp4a.40.2',  // AACï¼ŒiOSå’ŒAndroidéƒ½æ”¯æŒ
                'audio/webm;codecs=opus',      // WebM Opusï¼ŒAndroidæ”¯æŒ
                'audio/webm',                   // WebMï¼ŒåŸºæœ¬æ”¯æŒ
                'audio/wav',                    // WAVï¼Œæ‰€æœ‰è®¾å¤‡æ”¯æŒ
                'audio/ogg;codecs=opus'        // Ogg Opus
            ];
            
            console.log('è®¾å¤‡éŸ³é¢‘æ ¼å¼æ”¯æŒæƒ…å†µ:');
            supportedFormats.forEach(format => {
                console.log(`${format}: ${MediaRecorder.isTypeSupported(format) ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`);
            });
            
            // é€‰æ‹©æœ€ä½³æ ¼å¼
            for (const format of supportedFormats) {
                if (MediaRecorder.isTypeSupported(format)) {
                    console.log('æ¨èçš„éŸ³é¢‘æ ¼å¼:', format);
                    return format;
                }
            }
            
            console.log('æ²¡æœ‰æ‰¾åˆ°æ”¯æŒçš„æ ¼å¼ï¼Œä½¿ç”¨æµè§ˆå™¨é»˜è®¤');
            return null;
        }


        async function getFileSHA(filePath) {
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${AppState.config.REPOSITORY}/contents/${filePath}`,
                    {
                        headers: {
                            'Authorization': `token ${AppState.config.TOKEN}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (response.ok) {
                    const data = await response.json();
                    return data.sha;
                }
                return null; // æ–‡ä»¶ä¸å­˜åœ¨
            } catch (error) {
                console.log('æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†åˆ›å»ºæ–°æ–‡ä»¶');
                return null;
            }
        }

        // ==================== å·¥å…·å‡½æ•° ====================
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // ==================== ç•Œé¢æ›´æ–° ====================
        function startTimer() {
            // åœæ­¢æ’­æ”¾è®¡æ—¶å™¨ï¼ˆå¦‚æœæ­£åœ¨æ’­æ”¾ï¼‰
            if (AppState.playbackTimerInterval) {
                clearInterval(AppState.playbackTimerInterval);
                AppState.playbackTimerInterval = null;
            }
            
            // é‡ç½®å½•éŸ³æ—¶é—´
            AppState.recordingTime = 0;
            updateTimer();
            
            // å¼€å§‹å½•éŸ³è®¡æ—¶å™¨
            AppState.timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            AppState.recordingTime++;
            const minutes = Math.floor(AppState.recordingTime / 60).toString().padStart(2, '0');
            const seconds = (AppState.recordingTime % 60).toString().padStart(2, '0');
            
            // å½•éŸ³æ—¶æ˜¾ç¤ºç®€å•çš„æ—¶é—´æ ¼å¼
            elements.timer.textContent = `${minutes}:${seconds}`;
            
            // å½•éŸ³æ—¶è¿›åº¦æ¡æ˜¾ç¤ºå½•åˆ¶æ—¶é—´ç™¾åˆ†æ¯”ï¼ˆå‡è®¾æœ€é•¿å½•åˆ¶5åˆ†é’Ÿï¼‰
            const maxRecordingTime = 300; // 5åˆ†é’Ÿ
            const progressPercent = Math.min((AppState.recordingTime / maxRecordingTime) * 100, 100);
            elements.progressFill.style.width = `${progressPercent}%`;
        }

        function stopTimer() {
            if (AppState.timerInterval) {
                clearInterval(AppState.timerInterval);
                AppState.timerInterval = null;
            }
        }

        function updateWaveform() {
            if (!AppState.isRecording) return;
            
            elements.waveform.innerHTML = '';
            const barCount = 20 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < barCount; i++) {
                const bar = document.createElement('div');
                bar.className = 'waveform-bar';
                bar.style.left = `${(i / barCount) * 100}%`;
                bar.style.height = `${30 + Math.random() * 70}%`;
                bar.style.animation = `waveform ${0.5 + Math.random() * 1.5}s infinite`;
                elements.waveform.appendChild(bar);
            }
        }

        function updateStats() {
            const total = AppState.sentences.length;
            const recorded = AppState.sentences.filter(s => s.recorded).length;
            const uploaded = AppState.sentences.filter(s => s.hasUploaded).length;
            
            elements.totalSentences.textContent = total;
            elements.completedSentences.textContent = recorded;
            elements.uploadedSentences.textContent = uploaded;
            elements.progressText.textContent = `${recorded}/${total} å·²å®Œæˆ`;
            
            // æ›´æ–°è¿›åº¦æ¡
            const progressPercent = total > 0 ? (recorded / total) * 100 : 0;
            elements.progressFill.style.width = `${progressPercent}%`;
        }

        // ==================== çŠ¶æ€æç¤º ====================
        function showStatus(message, type = 'info') {
            const element = elements.statusMessage;
            
            element.textContent = message;
            element.className = 'status-message';
            
            if (type === 'success') {
                element.classList.add('status-success');
            } else if (type === 'error') {
                element.classList.add('status-error');
            } else if (type === 'info') {
                element.classList.add('status-info');
            }
            
            element.style.display = 'block';
            
            // è‡ªåŠ¨éšè—
            setTimeout(() => {
                element.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    element.style.display = 'none';
                    element.style.animation = '';
                }, 300);
            }, 3000);
        }

        // ==================== äº‹ä»¶ç›‘å¬å™¨ ====================
        function setupEventListeners() {
            // å½•éŸ³æŒ‰é’®
            elements.recordBtn.addEventListener('click', startRecording);
            
            // åœæ­¢æŒ‰é’®
            elements.stopBtn.addEventListener('click', stopRecording);
            
            // ä¸Šä¼ æŒ‰é’®
            elements.uploadBtn.addEventListener('click', uploadToGitHub);
            
            // æ’­æ”¾æŒ‰é’®
            elements.playBtn.addEventListener('click', playRecording);
            
            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                // ç©ºæ ¼é”®ï¼šå¼€å§‹/åœæ­¢å½•éŸ³
                if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    if (AppState.isRecording) {
                        stopRecording();
                    } else if (!elements.recordBtn.disabled) {
                        startRecording();
                    }
                }
                
                // Escé”®ï¼šåœæ­¢æ’­æ”¾
                if (e.code === 'Escape' && AppState.isPlaying) {
                    stopPlayback();
                }
                
                // æ•°å­—é”®1-9ï¼šé€‰æ‹©å¥å­
                if (e.code.startsWith('Digit') && e.code.length === 6) {
                    const num = parseInt(e.code[5]);
                    if (num >= 1 && num <= AppState.sentences.length) {
                        selectSentence(AppState.sentences[num - 1]);
                    }
                }
            });
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
